////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) Microsoft Corporation.  All rights reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Interrupt Handlers


#include <led/stm32f10x_led.h>
#include <exti/stm32f10x_exti.h>
#include <tim/stm32f10x_tim.h>
#include <tim/netmf_timers.h>
#include <gpio/stm32f10x_gpio.h>
#include <test_native_drivers/main.h>
//#include <radio/radio.h>

#include "netmf_time.h"
#include "int_time.h"
#include "stm32f10x_rtc.h"

extern void TimeLinkDequeueAndExec();
void radio_irq_handler();

int LEDState = 1;
int global_flag = 0;

uint16_t capture = 0;

extern UINT16 CCR1_Val;
extern UINT16 CCR2_Val;


/**
  * @brief  This function handles RTC global interrupt request.
  * @param  None
  * @retval None
  */
void RTC_IRQHandler(void) {
	/* Clear SysTick to start sub-second timing from 0 this
		is the first thing that needs to be done in this ISR */
	SysTick->VAL = 0;

	if(LEDState) {
		GPIOF->BRR = (0x1 << 6);
		LEDState = 0;
	} else {
		GPIOF->BSRR = (0x1 << 6);
		LEDState = 1;
	}

	if (READ_BIT(RTC->CRL, 0x0001)) {
		/* Clear the RTC Second interrupt */
		CLEAR_BIT(RTC->CRL, 0x0001);
		/* Wait until last write operation on RTC registers has finished */
		RTC_WaitForLastTask();
	}
}

/**
  * @brief  This function handles TIM1 update interrupt request.
  * @param  None
  * @retval None
  */
void TIM1_UP_IRQHandler(void) {
	/* Clear UIF */
	CLEAR_BIT(TIM1->SR, 0x0001); // TIM1->SR = 0x0000;
	/* CEN bit */
	CLEAR_BIT(TIM1->CR1, 0x0001); // TIM1->CR1 = 0x0000; // timing stop

	GPIOF->BSRR = (0x1 << 7);
	/* HAL Execution */
	TimeLinkDequeueAndExec(); // This also schedules next SetCompare @todo: call function directly (problem is with c/c++ calling)

	GPIOF->BRR = (0x1 << 7);
}

void EXTI9_5_IRQHandler(void)
{
   if(EXTI_GetITStatus(EXTI_Line8) != RESET)
  {

	//STM_EVAL_LEDInit((Led_TypeDef)1);
	//STM_EVAL_LEDToggle((Led_TypeDef)1);
	//LED_GREEN_OFF();
    EXTI_ClearITPendingBit(EXTI_Line8);
  }
}

void EXTI0_IRQHandler()
{
  if(EXTI_GetITStatus(EXTI_Line0) != RESET)
  {
	//STM_EVAL_LEDInit(0);

	//STM_EVAL_LEDToggle(0);

	radio_irq_handler();

	//irq_handler();

	/*if(global_flag == 0)
	{
		STM_EVAL_LEDToggle(0);
		global_flag = 1;
	}
	*/
	/*else
	{
		STM_EVAL_LEDToggle(0);
	}*/
	//LED_GREEN();
	//radio_irq_handler();
    EXTI_ClearITPendingBit(EXTI_Line0);
  }
}


void TIM2_IRQHandler(void)
{
  STM_EVAL_LEDInit((Led_TypeDef)0);
  STM_EVAL_LEDInit((Led_TypeDef)1);
  //STM_EVAL_LEDInit(3);
  //STM_EVAL_LEDToggle(3);

  if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
  {
	  TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
	  GPIO_ResetBits(GPIOC, GPIO_Pin_6);
	  STM_EVAL_LEDToggle((Led_TypeDef)1);
  }

  if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)
  {
      TIM_ClearITPendingBit(TIM2, TIM_IT_CC1 );
      capture = TIM_GetCapture1(TIM2);
      TIM_SetCompare1(TIM2, capture + CCR1_Val );
      STM_EVAL_LEDToggle((Led_TypeDef)1);
      //Timer_Driver :: Timer_IRQ_Handler(2);
  }

  if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)
  {
      TIM_ClearITPendingBit(TIM2, TIM_IT_CC1 );
      capture = TIM_GetCapture1(TIM2);
      TIM_SetCompare1(TIM2, capture + CCR1_Val );
      STM_EVAL_LEDToggle((Led_TypeDef)0);

  }

}
