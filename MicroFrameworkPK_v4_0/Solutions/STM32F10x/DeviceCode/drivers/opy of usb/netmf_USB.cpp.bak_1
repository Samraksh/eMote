////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) Microsoft Corporation.  All rights reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <netmf_usb.h>

// the v3.1 arm compiler optimizations for RTM cause the USB not to work
#if !defined(DEBUG)
#pragma O1
#endif

USBCS_Driver g_USB_Driver;

USB_CONTROLLER_STATE UsbControllerState[1];     // Only 1 USB Controller for this device

Hal_Queue_KnownSize<USB_PACKET64,USB_QUEUE_PACKET_COUNT> QueueBuffers[USBCS_Driver::c_Used_Endpoints-1];

//Kartik : This points to the USB Configuration (UNION), need to remap!
//static USB_Driver::EndpointConfiguration EndpointInit[USBCS_Driver::c_Used_Endpoints];     // Corresponds to endpoint configuration RAM at PXA271_USB::UDCCRx

//--//

USB_CONTROLLER_STATE* USBCS_Driver::GetState( int Controller )
{
    if( Controller != 0 )       // There is only one controller for this device
        return NULL;
    return &UsbControllerState[0];
}

HRESULT USBCS_Driver::Initialize( int Controller )
{   
	int endpointsUsed = 0;

    const USB_ENDPOINT_DESCRIPTOR  *ep    = NULL;
    const USB_INTERFACE_DESCRIPTOR *itfc  = NULL;

	USB_CONTROLLER_STATE &State = UsbControllerState[0];
	ASSERT(0 == Controller);	

	//Set up GPIO
	Set_System();
	//Enable Clock
	USB_Clock();
	//Enable uC Interrupts
	USB_Interrupts_Config();

	/* Connect the device */
	StartHardware();
	
	/* Perform basic device initialization operations */
	USB_SIL_Init();


	//TODO: Initialize all end points to unused

	//Configure other end points (endpoint no 1)
	while( USB_NextEndpoint( &State, ep, itfc) ) // && logicalEndpoint < 11 )
    {
        // Figure out which endpoint we are initializing
        UINT8 endpointNum = ep->bEndpointAddress & 0x7F;

		UINT16 endpointSize = ep->wMaxPacketSize;
        
        // Check interface and endpoint numbers against hardware capability
        if( endpointNum >= USBCS_Driver::c_Used_Endpoints || itfc->bInterfaceNumber > 3 )
            return S_FALSE;

	    // Set the maximum size of the endpoint hardware FIFO
        if( (ep->bmAttributes & 0x03) == USB_ENDPOINT_ATTRIBUTE_BULK )
        {
			if( endpointSize != 8 && endpointSize != 16 && endpointSize != 32 && endpointSize != 64 )
			{
				return S_FALSE;
			}
            //TODO : Move this value (endpointSize) to the packet size in the EP register
			State.MaxPacketSize[endpointNum]   = endpointSize;
		}
		else if( (ep->bmAttributes & 0x03) == USB_ENDPOINT_ATTRIBUTE_INTERRUPT )
        {
            if( endpointSize == 0 || endpointSize > 64 )
			{
                return S_FALSE;
			}
            //TODO : Move this value (endpointSize) to the packet size in the EP register
            State.MaxPacketSize[endpointNum]   = endpointSize;
        }
        else        // Isochronous endpoint
        {
            if( endpointSize > 64 )
                endpointSize = 64;
            //TODO : Move this value (endpointSize) to the packet size in the EP register
            State.MaxPacketSize[endpointNum]   = endpointSize;
        }

		// Since endpoint 0 is only used for control, there is never a need to allocate a buffer for it
        // In fact State.Queues[0] is always NULL - it is a cheap placeholder to make the queueIndex = endpointIndex
        QueueBuffers[endpointNum-1].Initialize();                       // Clear queue before use
        State.Queues[endpointNum] = &QueueBuffers[endpointNum-1];       // Attach queue to endpoint

		if( (ep->bEndpointAddress & 0x80) ? 1 : 0 )        // If transmit endpoint
        {
            State.IsTxQueue[endpointNum] = TRUE;
			//TODO : Enable the interrupt for the end point, based on the KIND (ep->bmAttributes & 0x03)
			//TODO : Set direction of the end point
		}
		else        // Receive endpoint
        {
            State.IsTxQueue[endpointNum] = FALSE;
			//TODO : Enable the interrupt for the end point, based on the KIND (ep->bmAttributes & 0x03)
			//TODO : Set direction of the end point
		}

		//endpointsUsed++;

	}

    g_USB_Driver.pUsbControllerState  = &State;
    g_USB_Driver.PinsProtected        = TRUE;

    State.EndpointStatus = &g_USB_Driver.EndpointStatus[0];
    State.EndpointCount  = c_Used_Endpoints;
    //State->DeviceStatus   = USB_STATUS_DEVICE_SELF_POWERED;
    State.PacketSize     = c_default_ctrl_packet_size;
    
    State.FirstGetDescriptor = TRUE;

	//Kartik : Commented for now
    //ProtectPins( Controller, FALSE );

    return S_OK;    
}

HRESULT USBCS_Driver::Uninitialize( int Controller )
{ 
    ASSERT( 0 == Controller );
    
    GLOBAL_LOCK(irq);

    ProtectPins( Controller, TRUE );

    g_USB_Driver.pUsbControllerState = NULL;

	//TODO : Disable Interrupts 
	//TODO : Disable Clocks

    return S_OK;
}

BOOL USBCS_Driver::StartOutput( USB_CONTROLLER_STATE* State, int endpoint )
{ 
    ASSERT( State );
    ASSERT(endpoint < c_Used_Endpoints);

    GLOBAL_LOCK(irq);

    // If endpoint is not an output
    if( State->Queues[endpoint] == NULL || !State->IsTxQueue[endpoint] )
        return FALSE;

    /* if the halt feature for this endpoint is set, then just
       clear all the characters */
    if(State->EndpointStatus[endpoint] & USB_STATUS_ENDPOINT_HALT)
    {
        ClearTxQueue( State, endpoint );
        return TRUE;
    }

    //If TxRunning, interrupts will drain the queue
    if(!g_USB_Driver.TxRunning[endpoint])
    {
        g_USB_Driver.TxRunning[endpoint] = TRUE;

        // Calling both TxPacket & EP_TxISR in this routine could cause a TX FIFO overflow
        TxPacket( State, endpoint );
    }
    else if(irq.WasDisabled())
    {                        
        //PXA271_USB& USB = PXA271::USB();
        
        // This could be called during Flush with all interrupts off.  Just taking care of the endpoint
        // in question may cause a logjam if the host is expecting a response from another endpoint.
        
		
		//TODO : Check All endpoints for activity.

        //if( USB.UDCISR0 & USB.UDCICR0 & USB.UDCICR__BOTH )        // If endpoint 0 needs attention
        //    EP0_ISR( 0 );
        //for( int ep = 1; ep < c_Used_Endpoints; ep++ )
        //{
        //    // If no interrupt for this endpoint
        //    if( (((USB.UDCISR0 & USB.UDCICR0) >> (ep * 2)) & USB.UDCICR__BOTH) == 0 )
        //        continue;
        //    
        //    if(State->Queues[ep])
        //    {
        //        if( State->IsTxQueue[endpoint] )
        //            EP_TxISR( endpoint );
        //        else
        //            EP_RxISR( endpoint );
        //    }
        //}
    }

    return TRUE;

}

BOOL USBCS_Driver::GetInterruptState()
{
    GLOBAL_LOCK(irq);

    if(GetISTR()) 
    {
        return TRUE;
    }
    
    return FALSE;
}

//--//

void USBCS_Driver::ClearTxQueue( USB_CONTROLLER_STATE* State, int endpoint )
{
    ASSERT(State);    
    State->Queues[endpoint]->Initialize();
}

//--//
void USBCS_Driver::StartHardware()
{       
  uint16_t wRegVal;
  
  /*** cable plugged-in ? ***/
  /*while(!CablePluggedIn());*/
  USB_Cable_Config(ENABLE);

  /*** CNTR_PWDN = 0 ***/
  wRegVal = CNTR_FRES;
  _SetCNTR(wRegVal);

  /*** CNTR_FRES = 0 ***/
  wInterrupt_Mask = 0;
  _SetCNTR(wInterrupt_Mask);
  /*** Clear pending interrupts ***/
  _SetISTR(0);
  /*** Set interrupt mask ***/
  wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM | CNTR_ERRM;
	  //| CNTR_CTRM | CNTR_DOVRM | CNTR_ESOFM | CNTR_SOFM | CNTR_RESUME | CNTR_FSUSP | CNTR_LPMODE | CNTR_PDWN | CNTR_FRES;
  _SetCNTR(wInterrupt_Mask);

}

/*
This functions turns off the USB core
*/
void USBCS_Driver::StopHardware()
{    
	SetCNTR(CNTR_PDWN);
}

void USBCS_Driver::TxPacket( USB_CONTROLLER_STATE* State, int endpoint )
{
    ASSERT( endpoint < c_Used_Endpoints );    
    ASSERT( State );

    //PXA271_USB& USB = PXA271::USB();
    
    GLOBAL_LOCK(irq); 

    // transmit a packet on UsbPortNum, if there are no more packets to transmit, then die    
    USB_PACKET64* Packet64;


    // If this is not a legal transmit endpoint, there is nothing to do
    if( State->Queues[endpoint] == NULL || !State->IsTxQueue[endpoint] )
        return;

    for(;;)
    {
        Packet64 = USB_TxDequeue( State, endpoint, TRUE );

        if( Packet64 == NULL || Packet64->Size > 0 )
            break;
    }
    
    if( Packet64 )
    {
		// If a packet has been sent
        //if(USB.UDCCSRx[endpoint] & USB.UDCCSR__PC)              
		//{
			// Clear the Packet Complete bit
			//USB.UDCCSRx[endpoint] = USB.UDCCSR__PC;             
		//}
            
        // We should absolutely have an empty buffer to use
        //ASSERT((USB.UDCCSRx[endpoint] & USB.UDCCSR__FS) != 0);  

		// FIFO may only be loaded with full words
        UINT32* packet4 = (UINT32*)Packet64->Buffer;            
        int nLeft = Packet64->Size;
        
        while( nLeft >= 4 )
        {
			// Shove packet into FIFO 4 bytes at a time
            //USB.UDCDRx[endpoint] = *packet4++;                  
            nLeft -= 4;
        }

		// If packet is not the full size
        if( Packet64->Size < State->MaxPacketSize[endpoint] )   
        {
            UINT16* packet2 = (UINT16*)packet4;
            
            if( nLeft >= 2 )
            {
                //*(volatile UINT16*)&USB.UDCDRx[endpoint] = *packet2++;
                nLeft -= 2;
            }
            if( nLeft > 0)
            {
                //*(volatile UINT8*)&USB.UDCDRx[endpoint] = *(UINT8*)packet2;
            }
			// Send a short packet (full length packets are automatically sent)
            //USB.UDCCSRx[endpoint] = USB.UDCCSR__SP;             
        }

        g_USB_Driver.TxNeedZLPS[endpoint] = (Packet64->Size == State->MaxPacketSize[endpoint]);
    }
    else
    {
        // send the zero length packet since we landed on the FIFO boundary before
        // (and we queued a zero length packet to transmit) 
        if(g_USB_Driver.TxNeedZLPS[endpoint])
        {
			// If a packet has been sent
            //if(USB.UDCCSRx[endpoint] & USB.UDCCSR__PC)              
			//{
				// Clear the Packet Complete bit
				//USB.UDCCSRx[endpoint] = USB.UDCCSR__PC;             
			//}
            
            
			// We should absolutely have an empty buffer to use
            //ASSERT((USB.UDCCSRx[endpoint] & USB.UDCCSR__FS) != 0);  

			// Send a short (zero length) packet
            //USB.UDCCSRx[endpoint] = USB.UDCCSR__SP;                 
            g_USB_Driver.TxNeedZLPS[endpoint] = FALSE;
        }

        // no more data
        g_USB_Driver.TxRunning[endpoint] = FALSE;
    }

    
}

void USBCS_Driver::ControlNext()
{    
    ASSERT(g_USB_Driver.pUsbControllerState);
    //PXA271_USB& USB = PXA271::USB();
    USB_CONTROLLER_STATE *State = g_USB_Driver.pUsbControllerState;

    if( State->DataCallback )
    {
        /* this call can't fail */
        State->DataCallback( State );


        if( State->DataSize == 0 )
        {
			// Send zero length packet
            //USB.UDCCSRx[0] = PXA271_USB::UDCCSR__IPR;         
			// Stop sending stuff if we're done
            State->DataCallback = NULL;                         
        }
        else
        {
			// FIFO may only be loaded with full words
            UINT32* packet4 = (UINT32*)State->Data;             
            int     nLeft   = State->DataSize;
            while( nLeft >= 4 )
            {
				// Shove packet into FIFO 4 bytes at a time
                //USB.UDCDRx[0] = *packet4++;                     
                nLeft -= 4;
            }

			// If packet is less than full length
            if(State->DataSize < c_default_ctrl_packet_size)    
            {
                UINT16* packet2 = (UINT16*)packet4;
                
                if( nLeft >= 2 )
                {
                    //*(volatile UINT16*)&USB.UDCDRx[0] = *packet2++;
                    nLeft -= 2;
                }
                if( nLeft > 0)
                {
                    //*(volatile UINT8*)&USB.UDCDRx[0] = *(UINT8*)packet2;
                }
				// Send a short packet (full length packets are automatically sent)
                //USB.UDCCSRx[0] = USB.UDCCSR__IPR;

				// Stop sending stuff if we're done
                State->DataCallback = NULL;                     
            }


            // special handling the USB driver set address test, cannot use the first descriptor as the ADDRESS state is handle in the hardware
            if(g_USB_Driver.FirstDescriptorPacket)
            {
                State->DataCallback = NULL;
            }

       }
    }


}

void USBCS_Driver::SuspendEvent()
{
    ASSERT(g_USB_Driver.pUsbControllerState);

    //PXA271_USB& USB = PXA271::USB();
    
	USB_CONTROLLER_STATE *State = g_USB_Driver.pUsbControllerState;

    // SUSPEND event only happened when Host(PC) set the device to SUSPEND
    // as there is always SOF every 1ms on the BUS to keep the device from
    // suspending. Therefore, the REMOTE wake up is not necessary at the ollie side

    //USB.UDCICR1 = PXA271_USB::UDCICR1__IECC | PXA271_USB::UDCICR1__IERS | PXA271_USB::UDCICR1__IERU | PXA271_USB::UDCICR1__IESU;

    g_USB_Driver.PreviousDeviceState = State->DeviceState;

    State->DeviceState = USB_DEVICE_STATE_SUSPENDED;

    USB_StateCallback( State );

#if defined(DEBUG_USB)
    USB_debug_printf("In suspend event previous %d\n\r", g_USB_Driver.PreviousDeviceState);
#endif    
}

void USBCS_Driver::ResumeEvent()
{
	ASSERT(g_USB_Driver.pUsbControllerState);
	USB_CONTROLLER_STATE *State = g_USB_Driver.pUsbControllerState;

#if defined(DEBUG_USB)
    USB_debug_printf(" in Resume\r\n");
#endif

    //USB.UDCICR1 = PXA271_USB::UDCICR1__IECC | PXA271_USB::UDCICR1__IERS | PXA271_USB::UDCICR1__IERU | PXA271_USB::UDCICR1__IESU;

    State->DeviceState = g_USB_Driver.PreviousDeviceState;

    USB_StateCallback( State );
}



void USBCS_Driver::ResetEvent()
{
	USB_CONTROLLER_STATE *State = g_USB_Driver.pUsbControllerState;
	// The hardware handles most of the reset procedure.

	// flush whatever is in the FIFO
    //USB.UDCCSRx[0] = PXA271_USB::UDCCSR__FTF;                   // Flush endpoint 0 FIFO

	for(int ep = 1; ep < c_Used_Endpoints; ep++)
    {
        //if( EndpointInit[ep].bits.EE )       // If this endpoint is enabled
        //{
        //    USB.UDCCSRx[ep] = PXA271_USB::UDCCSR__FEF;
        //    while( USB.UDCCSRx[ep] & PXA271_USB::UDCCSR__FEF ) ;     // Wait for the FIFO to clear
        //}
    }

	// Clear all EP0 status
	//USB.UDCCSRx[0] = USB.UDCCSRx[0];        

    //USB.UDCICR1 = PXA271_USB::UDCICR1__IECC | PXA271_USB::UDCICR1__IERS | PXA271_USB::UDCICR1__IERU | PXA271_USB::UDCICR1__IESU;
    //USB.UDCISR0 = USB.UDCISR0;
	
	// Clear all pending interrupts
    //USB.UDCISR1 = USB.UDCISR1;           

	SetBTABLE(BTABLE_ADDRESS);
	// Initialize Endpoint 0 
	SetEPType(ENDP0, EP_CONTROL);
	SetEPTxStatus(ENDP0, EP_TX_NAK);
	SetEPRxAddr(ENDP0, ENDP0_RXADDR);
	SetEPRxCount(ENDP0, 0x40);
	SetEPTxAddr(ENDP0, ENDP0_TXADDR);
	Clear_Status_Out(ENDP0);
	SetEPRxValid(ENDP0);

    /* Initialize Endpoint 1 */
    SetEPType(ENDP1, EP_BULK);
    SetEPTxAddr(ENDP1, ENDP1_TXADDR);
    SetEPTxStatus(ENDP1, EP_TX_NAK);
    SetEPRxStatus(ENDP1, EP_RX_DIS);

    /* Initialize Endpoint 2 */
    SetEPType(ENDP2, EP_BULK);
    SetEPRxAddr(ENDP2, ENDP2_RXADDR);
    SetEPRxCount(ENDP2, 0x40);
    SetEPRxStatus(ENDP2, EP_RX_VALID);
    SetEPTxStatus(ENDP2, EP_TX_DIS);


    SetEPRxCount(ENDP0, 0x40);
    SetEPRxValid(ENDP0);

    /* Set the device to response on default address */
    SetDeviceAddress(0);


	/* clear all flags */
    USB_ClearEvent( 0, USB_EVENT_ALL);

#if defined(DEBUG_USB)
    USB_debug_printf(" in Reset\r\n");

    if( State->DeviceState >= USB_DEVICE_STATE_ADDRESS )
    {
        static int count = 0;
        USB_debug_printf("\fRESET: %d  \r\n", ++count);
    }
#endif

    for(int ep = 0; ep < c_Used_Endpoints; ep++)
    {
        g_USB_Driver.TxRunning [ep] = FALSE;
        g_USB_Driver.TxNeedZLPS[ep] = FALSE;
    }


    State->DeviceState        = USB_DEVICE_STATE_DEFAULT;
    State->Address            = 0;
    USB_StateCallback( State );    
    
}

//--//

BOOL USBCS_Driver::RxEnable( USB_CONTROLLER_STATE *State, int endpoint )
{
	if( NULL == State || endpoint >= c_Used_Endpoints )
        return FALSE;
    
    GLOBAL_LOCK(irq);

    /* unmask receive event */
    //USB.Set_Interrupt(endpoint, PXA271_USB::UDCICR__BOTH);      // Enable both interrupts for this endpoint
    
    return TRUE;        
}

BOOL USBCS_Driver::ProtectPins( int Controller, BOOL On )
{
    ASSERT( 0 == Controller );
    USB_CONTROLLER_STATE *State = g_USB_Driver.pUsbControllerState;
    
    GLOBAL_LOCK(irq);

    // Initialized yet?
    if( State )
    {
        if( On )
        {
            if(!g_USB_Driver.PinsProtected)
            {
                // Disable the USB com, state change from Not protected to Protected

                g_USB_Driver.PinsProtected = TRUE;

                // clear USB Txbuffers
                for(int ep = 0; ep < c_Used_Endpoints; ep++)
                {
                    if( State->IsTxQueue[ep] )
                        ClearTxQueue( State, ep );
                }

                // stop clock, disable interrupt, dettach USB port
                // set the USBBus->DeviceState = DETACHED
				//Kartik: Set the correct pin number here; For signalling the host
                //CPU_GPIO_EnableInputPin(PXA271_USB::c_USBC_GPIOX_EN, FALSE, NULL, GPIO_INT_NONE, RESISTOR_DISABLED);     // Disable host signal driver
                State->DeviceState = USB_DEVICE_STATE_DETACHED;
                USB_StateCallback( State );

#if defined(DEBUG_USB)
                USB_debug_printf(" DETACHED USB in protect pin\n\r");
                lcd_printf("Detached USB in protect pin\n\r");
#endif
                StopHardware();
            }
        }
        else
        {
            if( g_USB_Driver.PinsProtected )
            {
                // Ready for USB to enable, state change from Protected to Not protected
                g_USB_Driver.PinsProtected = FALSE;

                // enable the clock,
                // set USB to attached/powered
                // set the device to a known state- Attached before it is set to the powered state (USB specf 9.1.1)

                //CPU_GPIO_EnableInputPin(PXA271_USB::c_USBC_GPION_DET, FALSE, NULL, GPIO_INT_NONE, RESISTOR_DISABLED);
                //CPU_GPIO_EnableOutputPin(PXA271_USB::c_USBC_GPIOX_EN, FALSE);       // Don't signal the host yet
                
				State->DeviceState = USB_DEVICE_STATE_ATTACHED;
                
                USB_StateCallback( State );

                StartHardware();
            }
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void USBCS_Driver::Global_ISR( void* Param )
{ 

}


void USBCS_Driver::EP0_ISR( UINT32 Param )
{   
 
}

void USBCS_Driver::EP_TxISR( UINT32 endpoint )
{
    
}

void USBCS_Driver::EP_RxISR( UINT32 endpoint )
{
    
}

void USB_Interrupts_Config()
{
	//Replace with calls to Interrupt controller

	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
	NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	NVIC_InitStructure.NVIC_IRQChannel = USB_HP_CAN1_TX_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}

void USB_Clock()
{
	RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
	/* Enable the USB clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
}

void Set_System()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	//This configuration sets the USB GPIO to not use USB_USE_EXTERNAL_PULLUP, the external Pull up has a different configurations
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);

    /* Configure USB pull-up pin */
    GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);

}

void USB_Cable_Config(bool state)
{
  if (state != false)
  {
    GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
  }
  else
  {
    GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
  }
}

void SetDeviceAddress(UINT8 Val)
{
  UINT32 i;
  UINT32 nEP = 2;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */

}

void usb_irq_handler()
{
   wIstr = _GetISTR();

#if (IMR_MSK & ISTR_CTR)
  if (wIstr & ISTR_CTR & wInterrupt_Mask)
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */    
	ctr_lp();
#ifdef CTR_CALLBACK
    CTR_Callback();
#endif
  }
#endif  
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_RESET)
  if (wIstr & ISTR_RESET & wInterrupt_Mask)
  {
    _SetISTR((uint16_t)CLR_RESET);
    USBCS_Driver::ResetEvent();
#ifdef RESET_CALLBACK
    RESET_Callback();
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_DOVR)
  if (wIstr & ISTR_DOVR & wInterrupt_Mask)
  {
    _SetISTR((uint16_t)CLR_DOVR);
#ifdef DOVR_CALLBACK
    DOVR_Callback();
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_ERR)
  if (wIstr & ISTR_ERR & wInterrupt_Mask)
  {
    _SetISTR((uint16_t)CLR_ERR);
#ifdef ERR_CALLBACK
    ERR_Callback();
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_WKUP)
  if (wIstr & ISTR_WKUP & wInterrupt_Mask)
  {
    _SetISTR((uint16_t)CLR_WKUP);
    //Resume(RESUME_EXTERNAL);
#ifdef WKUP_CALLBACK
    WKUP_Callback();
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_SUSP)
  if (wIstr & ISTR_SUSP & wInterrupt_Mask)
  {

    /* check if SUSPEND is possible */
    //if (fSuspendEnabled)
    //{
    //  //Suspend();
    //}
    //else
    //{
    //  /* if not possible then resume after xx ms */
    //  //Resume(RESUME_LATER);
    //}
    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    _SetISTR((uint16_t)CLR_SUSP);
#ifdef SUSP_CALLBACK
    SUSP_Callback();
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_SOF)
  if (wIstr & ISTR_SOF & wInterrupt_Mask)
  {
    _SetISTR((uint16_t)CLR_SOF);
    //bIntPackSOF++;

#ifdef SOF_CALLBACK
    SOF_Callback();
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (IMR_MSK & ISTR_ESOF)
  if (wIstr & ISTR_ESOF & wInterrupt_Mask)
  {
    _SetISTR((uint16_t)CLR_ESOF);
    /* resume handling timing is made with ESOFs */
    //Resume(RESUME_ESOF); /* request without change of the machine state */

#ifdef ESOF_CALLBACK
    ESOF_Callback();
#endif
  }
#endif
} /* USB_Istr */

void ctr_lp()
{
   UINT16 wEPVal = 0;
   UINT8 EPindex;
  
   /* stay in loop while pending interrupts */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
  {
    /* extract highest priority endpoint number */
    EPindex = (UINT8)(wIstr & ISTR_EP_ID);
    if (EPindex == 0)
    {
      /* Decode and service control endpoint interrupt */
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
	    SaveTState = SaveRState & EPTX_STAT;
	    SaveRState &=  EPRX_STAT;	

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
      {
        /* DIR = 0 */

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */


        _ClearEP_CTR_TX(ENDP0);		
        In0_Process();

           /* before terminate set Tx & Rx status */

            _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
		  return;
      }
      else
      {
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
        
        if ((wEPVal &EP_SETUP) != 0)
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
          Setup0_Process();
          /* before terminate set Tx & Rx status */

		      _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
        {
          _ClearEP_CTR_RX(ENDP0);
          //Out0_Process();
          /* before terminate set Tx & Rx status */
     
		     _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
          return;
        }
      }
	}
  }
}

UINT8 Setup0_Process(void)
{
  union
  {
    UINT8* b;
    UINT16* w;
  } pBuf;

  UINT16 offset = 1;

  //Kartik : Debug purpose; remove when done
  UINT8 retVal;
  pInformation = &Device_Info;
  //
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */

  
  pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
  pInformation->USBbRequest = *pBuf.b++; /* bRequest */
  pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
  pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */ //ByteSwap(*pBuf.w++); 
  pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
  pInformation->USBwIndex  = ByteSwap(*pBuf.w++); //ByteSwap(*pBuf.w++); /* wIndex */
  pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
  pInformation->USBwLength = *pBuf.w; /* wLength */

  pInformation->ControlState = SETTING_UP;
  if (pInformation->USBwLength == 0)
  {
    /* Setup with no data stage */
    NoData_Setup0();
  }
  else
  {
    /* Setup with data stage */
    //Kartik : Make the MF control packet structure point to the pBuf structure 
	//Kartik : TODO : Debug this; the values of length and index are inter-changed

	g_USB_Driver.ControlPacketBuffer[0] = pInformation->USBbmRequestType;	
	g_USB_Driver.ControlPacketBuffer[1] = pInformation->USBbRequest;		
	g_USB_Driver.ControlPacketBuffer[2] = pInformation->USBwValues.bw.bb1;
	g_USB_Driver.ControlPacketBuffer[3] = pInformation->USBwValues.bw.bb0;
	g_USB_Driver.ControlPacketBuffer[4] = pInformation->USBwIndexs.bw.bb1;	
	g_USB_Driver.ControlPacketBuffer[5] = pInformation->USBwIndexs.bw.bb0;	
	g_USB_Driver.ControlPacketBuffer[6] = pInformation->USBwLengths.bw.bb1;
	g_USB_Driver.ControlPacketBuffer[7] = pInformation->USBwLengths.bw.bb0;
	
	Data_Setup0();	
	
  }
  return Post0_Process();
  //return retVal;
}

void Data_Setup0(void)
{
  
  USB_CONTROLLER_STATE *State = g_USB_Driver.pUsbControllerState;

  UINT8* (*CopyRoutine)(uint16_t);
  RESULT Result;
  UINT32 Request_No = pInformation->USBbRequest;

  UINT32 Related_Endpoint, Reserved;
  UINT32 wOffset, Status;
  UINT8 result;

  CopyRoutine = NULL;
  wOffset = 0;

  /*GET DESCRIPTOR*/
  if (Request_No == GET_DESCRIPTOR)
  {	
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      UINT8 wValue1 = pInformation->USBwValue1;
      if (wValue1 == DEVICE_DESCRIPTOR)
      {
		STM_EVAL_LEDToggle((Led_TypeDef)1);
	    State->FirstGetDescriptor = TRUE;		
		State->Data = (UINT8 *) g_USB_Driver.ControlPacketBuffer;		
		State->DataSize = 16; //Kartik : Hardcoded
        //CopyRoutine = pProperty->GetDeviceDescriptor;
		//Kartik : Calling PAL now with the data for Device Descriptors
		result = USB_ControlCallback( State );

		switch(result)
        {
        case USB_STATE_DATA:
            /* setup packet was handled and the upper layer has data to send */
            break;

        case USB_STATE_ADDRESS:
            /* upper layer needs us to change the address */
            // address stage handles in hardware
            break;

        case USB_STATE_DONE:
            State->DataCallback = NULL;
            break;

        case USB_STATE_STALL:
            // since the setup command all handled in the hardware, should not have this state 
            //
            // setup packet failed to process successfully
            // set stall condition on the default control
            // endpoint
            //
            break;

        case USB_STATE_STATUS:
            // handle by hardware            
            break;
        case USB_STATE_CONFIGURATION:
            // handle partly by hardware and the GLOBAL_ISR will take care.
            /* USB spec 9.4.5 SET_CONFIGURATION resets halt conditions, resets toggle bits */
            break;

        case USB_STATE_REMOTE_WAKEUP:
            // It is not using currently as the device side won't go into SUSPEND mode unless
            // the PC is purposely to select it to SUSPEND, as there is always SOF in the bus
            // to keeping the device from SUSPEND.
            break;

        default:
            ASSERT(0);
            break;            
            // the status change is only seen and taken care in hardware
        }

		//Check if the upper layer has data to be sent. 
		if (State->DataCallback)
		{
			UINT32 Length = 0x40; //Kartik
			State->DataCallback( State );

			if( State->DataSize == 0 )
			{
				//Send zero length packet 
			}

			else			
			{
				State->DataSize = 18;
				ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
				UserToPMABufferCopy(State->Data, GetEPTxAddr(ENDP0), State->DataSize);
				SetEPTxCount(ENDP0, State->DataSize);
				pEPinfo->Usb_wLength -= State->DataSize;
				pEPinfo->Usb_wOffset += State->DataSize;
				vSetEPTxStatus(EP_TX_VALID);
				USB_StatusOut();
				return;
			}

		}



      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
      {
        //CopyRoutine = pProperty->GetConfigDescriptor;
		//LED_RED();
      }
      else if (wValue1 == STRING_DESCRIPTOR)
      {
        //CopyRoutine = pProperty->GetStringDescriptor;
      }  /* End of GET_DESCRIPTOR */
    }
  }  

  if (ValBit(pInformation->USBbmRequestType, 7)) //Kartik : Indicates the value of the 7th Bit (D->H Xfer)
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;

	//Kartik : Adding the value of pInformation->Ctrl_Info.Usb_wLength from PAL (*Device's length)
	pInformation->Ctrl_Info.Usb_wLength = State->ResidualCount;
         
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    }
    
    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    {
      if (pInformation->Ctrl_Info.Usb_wLength < 0x40)//pProperty->MaxPacketSize)
      {
        Data_Mul_MaxPacketSize = FALSE;
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % 0x40) == 0) //pProperty->MaxPacketSize
      {
        Data_Mul_MaxPacketSize = TRUE;
      }
    }   

	//Kartik : Commented because we don't have a pProperty structure in MF
    pInformation->Ctrl_Info.PacketSize = 0x40; //Kartik : commenting pProperty->MaxPacketSize;
	
    DataStageIn();
  }
  else //Kartik : The transfer is from H->D
  {
    pInformation->ControlState = OUT_DATA;
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
  }

  return;
}

UINT16 ByteSwap(UINT16 wSwW)
{
  UINT8 bTemp;
  UINT16 wRet;
  bTemp = (UINT8)(wSwW & 0xff);
  wRet =  (wSwW >> 8) | ((UINT16)bTemp << 8);
  return(wRet);
}

void DataStageIn()
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  uint32_t save_wLength = pEPinfo->Usb_wLength;
  uint32_t ControlState = pInformation->ControlState;

  uint8_t *DataBuffer;
  uint32_t Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    {
      /* No more data to send and empty packet */
      Send0LengthData();
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    }
    else 
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;

    #ifdef STM32F10X_CL      
      PCD_EP_Read (ENDP0, 0, 0);
    #endif  /* STM32F10X_CL */ 
    
    #ifndef STM32F10X_CL 
      vSetEPTxStatus(EP_TX_STALL);
    #endif  /* STM32F10X_CL */ 
    }
    
    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;

  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  //Kartik : Commenting because we will get the pointer to the data from the PAL using a call to ControlNext
  //DataBuffer = (*pEPinfo->CopyData)(Length);  

#ifdef STM32F10X_CL
  PCD_EP_Write (ENDP0, DataBuffer, Length);
#else   
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */

Expect_Status_Out:
  pInformation->ControlState = ControlState;
}

UINT8 Post0_Process(void)
{
  //SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
  //Kartik : Hardcoded the packet size
  SetEPRxCount(ENDP0, 0x40);

  if (pInformation->ControlState == STALLED)
  {
    vSetEPRxStatus(EP_RX_STALL);
    vSetEPTxStatus(EP_TX_STALL);
  }
  return (pInformation->ControlState == PAUSE);
}


void NoData_Setup0()
{  
  RESULT Result = USB_UNSUPPORT;
  uint32_t RequestNo = pInformation->USBbRequest;
  uint32_t ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    {
      //Result = Standard_SetConfiguration();
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
        goto exit_NoData_Setup0;
      }
      else
      {
        Result = USB_SUCCESS;
		STM_EVAL_LEDToggle((Led_TypeDef)3);
		//Kartik : Calling SetDeviceAddress(pInformation->USBwValue0) anyways. 
		SetDeviceAddress(pInformation->USBwValue0);

      //#ifdef STM32F10X_CL
         //SetDeviceAddress(pInformation->USBwValue0);
      //#endif  /* STM32F10X_CL */
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP) \
          && (pInformation->USBwIndex == 0))
      {
        //Result = Standard_SetDeviceFeature();
      }
      else
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
          && pInformation->USBwIndex == 0
          && ValBit(pInformation->Current_Feature, 5))
      {
        //Result = Standard_ClearFeature();
      }
      else
      {
        Result = USB_UNSUPPORT;
      }
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    {
      //Result = Standard_SetInterface();
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    {
      //Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    {
      //Result = Standard_SetEndPointFeature();
    }
  }
  else
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
  {
    //Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
  return;

}

UINT8 In0_Process(void)
{

  STM_EVAL_LEDToggle((Led_TypeDef)2);
  UINT32 ControlState = pInformation->ControlState;

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    DataStageIn();
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
	  //Kartik :
      //pUser_Standard_Requests->User_SetDeviceAddress();
    }
    //(*pProperty->Process_Status_IN)();
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
}
