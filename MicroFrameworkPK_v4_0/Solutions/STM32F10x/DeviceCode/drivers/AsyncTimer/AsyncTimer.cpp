//-----------------------------------------------------------------------------
//
//    ** DO NOT EDIT THIS FILE! **
//    This file was generated by a tool
//    re-running the tool will overwrite this file.
//
//-----------------------------------------------------------------------------


#include "AsyncTimer.h"
#include <gpio/stm32f10x_gpio.h>
#include <tim/netmf_timers.h>
#include <TinyCLR_Hardware.h>
#include <TinyCLR_Runtime.h>


static bool g_AsyncTimerEnalbed = false;
static CLR_RT_HeapBlock_NativeEventDispatcher *g_Context = NULL;
CLR_RT_ApplicationInterrupt interrupt;
static UINT64 g_UserData = 0;
UINT16 AsyncTimerTicks, RollOverTicks;
UINT32 ManagedTimerMicroSeconds;
UINT32 ManagedTimerTicks;
UINT64 asyncCount=0;
UINT16 RollOverCount=0;
UINT16 RollOver=0;
#define SystemClock  48000000
#define TICKS_PER_MICROSECOND SystemClock/1000000

void ISR_ASYNC_TIMER (void* Param);
//void ISR_PendSV_Handler (void* Param);

BOOL InitializeTimer (){
	if (!Timer_Driver :: Initialize (3, TRUE, 0, 0, ISR_ASYNC_TIMER, NULL))
	{
		return FALSE;
	}
	Timer_Driver::SetCounter(3,0);
	Timer_Driver::SetCompare( 3, (UINT16)(AsyncTimerTicks));

	return TRUE;
}

static HRESULT InitializeAsyncTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, UINT64 userData )
{
   g_Context  = pContext;
   g_UserData = userData;
   ManagedTimerMicroSeconds= userData;
   ManagedTimerTicks= TICKS_PER_MICROSECOND*ManagedTimerMicroSeconds;
   if(ManagedTimerTicks < 65536) {
	   AsyncTimerTicks = ManagedTimerTicks;
	   RollOverCount=0;
   }else {
	   AsyncTimerTicks=65535;
	   RollOverCount= ManagedTimerTicks/65535;
	   RollOverTicks= ManagedTimerTicks - (RollOverCount* 65535);
   }
   InitializeTimer();

   //Register the PendSV interrupt Handler

   if(!CPU_INTC_ActivateInterrupt(60, ISR_PendSV_Handler, NULL)){
	   int x;
	   //debug_print('Error Registering ISR');
   }

   //Protect interrupt from GC
   //CLR_RT_ProtectFromGC gc1(*(&interrupt));

   //Initialize GPIO pins
   CPU_GPIO_SetPinState( 0, FALSE);
   CPU_GPIO_SetPinState( 0, TRUE);
   CPU_GPIO_SetPinState( 0, FALSE);
   CPU_GPIO_SetPinState( 0, TRUE);

   CPU_GPIO_EnableOutputPin (7, FALSE);
   CPU_GPIO_SetPinState( 7, TRUE);
   CPU_GPIO_SetPinState( 7, FALSE);

   CPU_GPIO_EnableOutputPin (23, FALSE);
   CPU_GPIO_SetPinState( 23, TRUE);
   CPU_GPIO_SetPinState( 23, FALSE);

   return S_OK;
}


static HRESULT EnableDisableAsyncTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, bool fEnable )
{
   g_AsyncTimerEnalbed = fEnable;
   return S_OK;
}


static HRESULT CleanupAsyncTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )
{
    g_Context = NULL;
    g_UserData = 0;
    CleanupNativeEventsFromHALQueue( pContext );
    return S_OK;
}

static void ISR_AsyncTimerProc( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )

{
    //GLOBAL_LOCK(irq);

#if defined(NETMF_RTOS)  //Samraksh
	//Garbage Collector is running, dont mess with it, return immediately.
	if (g_CLR_RT_ExecutionEngine.m_heapState == g_CLR_RT_ExecutionEngine.c_HeapState_UnderGC) {
		return;
	}

	//CLR_RT_ApplicationInterrupt interrupt;
    interrupt.m_interruptPortInterrupt.m_context = pContext;
    interrupt.m_interruptPortInterrupt.m_time= Time_GetUtcTime();
    interrupt.m_interruptPortInterrupt.m_data1 = UINT32(g_UserData >> 16);
    interrupt.m_interruptPortInterrupt.m_data2 =  UINT32(g_UserData & 0xFFFFFFFF);

    //Dispatch interrupt to RTOSThread
    HRESULT hr;
    CPU_GPIO_SetPinState(23,TRUE);
    if(g_CLR_RT_ExecutionEngine.m_rtosInterruptThread){
    	g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_status =  CLR_RT_Thread::TH_S_Terminated;
    }
    hr = g_CLR_HW_Hardware.SpawnRTOSDispatcher(&interrupt);
    CPU_GPIO_SetPinState(23,FALSE);
    asyncCount++;

    /*if(FAILED(hr))
    {
    	//Dispatch has failed what should we do now?? Try dispatch again??
    	hr = g_CLR_HW_Hardware.SpawnRTOSDispatcher(&interrupt);
    }*/
    //Execute Thread

    //if(SUCCEEDED(hr)){
		CPU_GPIO_SetPinState(7,TRUE);
		//g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->Execute();
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_timeQuantumExpired=FALSE;
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_isRtosThread=TRUE;
		//g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->Execute_Inner();
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->RTOS_Thread_Execute();
		CPU_GPIO_SetPinState(7,FALSE);
    //}
#else
    //Generate a Software Interrupt and Add to HAL Queue
    SaveNativeEventToHALQueue( pContext, UINT32(g_UserData >> 16), UINT32(g_UserData & 0xFFFFFFFF) );

    //Events_Set(SYSTEM_EVENT_FLAG_TIMER2);
    //Process the Interrupt Too
    //g_CLR_HW_Hardware.ProcessInterrupts();
#endif

}

void GeneratePendSVInterrupt(){
	//E000ED04
	//*((uint32_t volatile *)0x00000038) = 0x10000000;
	SCB->ICSR |= SCB_ICSR_PENDSVSET;
	//*((uint32_t volatile *)SCB->ICSR = SCB_ICSR_PENDSVSET;
}

void GenerateInterrupt( HRESULT &hr )
{
    if ( g_Context == NULL )
    {
        // Generates exception if context not set.
        hr = CLR_E_DRIVER_NOT_REGISTERED;
        return;
    }

    ISR_AsyncTimerProc( g_Context );
}

void ISR_PendSV_Handler (void* Param){
	HRESULT hresult;
	GenerateInterrupt(hresult);
}

void ISR_ASYNC_TIMER (void* Param){
	if (TIM_GetITStatus(TIM3, TIM_IT_CC1) != RESET)
	{
		TIM_ClearITPendingBit(TIM3, TIM_IT_CC1 );
	}
	//HRESULT hresult;

	if(RollOverCount==0){
		CPU_GPIO_SetPinState( 0, FALSE );
		Timer_Driver::SetCompare( 3, (UINT16)(Timer_Driver::GetCounter(3))+ AsyncTimerTicks);

		//Generate PendSV interrupt
		GeneratePendSVInterrupt();

	}else {
		if(RollOver==RollOverCount){
				CPU_GPIO_SetPinState( 0, FALSE );
				Timer_Driver::SetCounter(3,0);
				Timer_Driver::SetCompare( 3, 65535);
				RollOver=0;

				//Generate PendSV Interrupt
				GeneratePendSVInterrupt();

		}else if (RollOver==RollOverCount-1){
				Timer_Driver::SetCompare( 3, RollOverTicks);
				RollOver++;
		}else{
				RollOver++;
				Timer_Driver::SetCompare( 3, 65535);
		}
	}
}

static const CLR_RT_DriverInterruptMethods g_InteropAsyncTimerDriverMethods =

{ InitializeAsyncTimerDriver,
  EnableDisableAsyncTimerDriver,
  CleanupAsyncTimerDriver
};

static const CLR_RT_MethodHandler method_lookup[] =
{
    NULL,
    Library_AsyncTimer_Microsoft_SPOT_Interop_AsyncTimer::GenerateInterrupt___STATIC__VOID,
};


const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_AsyncTimer =
{
    "AsyncTimer",
    0x6848EA00,
    //DRIVER_INTERRUPT_METHODS_CHECKSUM,
    //&g_InteropAsyncTimerDriverMethods
    method_lookup
};

const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_AsyncInteropTimer  =
{
    "AsyncInteropTimer",
    //0x6848EA00,
    DRIVER_INTERRUPT_METHODS_CHECKSUM,
    &g_InteropAsyncTimerDriverMethods
    //method_lookup
};
