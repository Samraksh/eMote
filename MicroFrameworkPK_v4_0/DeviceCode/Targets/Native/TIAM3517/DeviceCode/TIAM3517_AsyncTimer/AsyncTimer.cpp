//-----------------------------------------------------------------------------
//
//    ** DO NOT EDIT THIS FILE! **
//    This file was generated by a tool
//    re-running the tool will overwrite this file.
//
//-----------------------------------------------------------------------------


#include "AsyncTimer.h"
#include "..\TIAM3517.h"
#include <TinyCLR_Hardware.h>
#include <TinyCLR_Runtime.h>

#define ASYNCTIMER 2
#define SystemClock  13000000
#define TICKS_PER_MICROSECOND SystemClock/1000000
#define SOFT_INTERRUPT_INDEX 47 //GPT11

static bool g_AsyncTimerEnalbed = false;
static CLR_RT_HeapBlock_NativeEventDispatcher *g_Context = NULL;
CLR_RT_ApplicationInterrupt interrupt;
static UINT64 g_UserData = 0;
UINT32 AsyncTimerTicks, RollOverTicks;
UINT32 ManagedTimerMicroSeconds;
UINT64 ManagedTimerTicks;
UINT64 asyncCount=0;
UINT32 RollOverCount=0;
UINT32 RollOver=0;

void ISR_ASYNC_TIMER (void* Param);


BOOL InitializeTimer (){
	if (!TIAM3517_TIMER_Driver :: Initialize (ASYNCTIMER, TRUE, 0, 0, ISR_ASYNC_TIMER, NULL))
	{
		return FALSE;
	}
	TIAM3517_TIMER_Driver::SetCounter(ASYNCTIMER,0);
	TIAM3517_TIMER_Driver::SetCompare( ASYNCTIMER, (UINT32)(AsyncTimerTicks));
	TIAM3517_TIMER_Driver::EnableCompareInterrupt(ASYNCTIMER);

	return TRUE;
}

static HRESULT InitializeAsyncTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, UINT64 userData )
{
   g_Context  = pContext;
   g_UserData = userData;
   ManagedTimerMicroSeconds= userData;
   ManagedTimerTicks= TICKS_PER_MICROSECOND*ManagedTimerMicroSeconds;


   CPU_GPIO_SetPinState( 56, FALSE);
   CPU_GPIO_SetPinState( 56, TRUE);
   CPU_GPIO_SetPinState( 56, FALSE);
   CPU_GPIO_SetPinState( 56, TRUE);

   CPU_GPIO_EnableOutputPin (57, FALSE);
   CPU_GPIO_SetPinState( 57, TRUE);
   CPU_GPIO_SetPinState( 57, FALSE);

   CPU_GPIO_EnableOutputPin (157, FALSE);
   CPU_GPIO_SetPinState( 157, TRUE);
   CPU_GPIO_SetPinState( 157, FALSE);

   if(ManagedTimerTicks < 0xFFFFFFFF) {
	   AsyncTimerTicks = ManagedTimerTicks;
	   RollOverCount=0;
   }else {
	   AsyncTimerTicks=0xFFFFFFFF;
	   RollOverCount= ManagedTimerTicks/0xFFFFFFFF;
	   RollOverTicks= ManagedTimerTicks - (RollOverCount * 0xFFFFFFFF);
   }
   InitializeTimer();

    //Register the Soft interrupt Handler
   if(!CPU_INTC_ActivateInterrupt(SOFT_INTERRUPT_INDEX, ISR_SoftInterrupt_Handler, NULL)){
	   int x;
	   //debug_print('Error Registering ISR');
   }

   //Protect interrupt from GC
   //CLR_RT_ProtectFromGC gc1(*(&interrupt));

   //Initialize GPIO pins


   return S_OK;
}


static HRESULT EnableDisableAsyncTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, bool fEnable )
{
   g_AsyncTimerEnalbed = fEnable;
   return S_OK;
}


static HRESULT CleanupAsyncTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )
{
    g_Context = NULL;
    g_UserData = 0;
    CleanupNativeEventsFromHALQueue( pContext );
    return S_OK;
}

static void ISR_AsyncTimerProc( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )

{
    //GLOBAL_LOCK(irq);

#if defined(NETMF_RTOS)  //Samraksh
	//Garbage Collector is running, dont mess with it, return immediately.
	if (g_CLR_RT_ExecutionEngine.m_heapState == g_CLR_RT_ExecutionEngine.c_HeapState_UnderGC) {
		return;
	}

	//CLR_RT_ApplicationInterrupt interrupt;
    interrupt.m_interruptPortInterrupt.m_context = pContext;
    interrupt.m_interruptPortInterrupt.m_time= Time_GetUtcTime();
    interrupt.m_interruptPortInterrupt.m_data1 = UINT32(g_UserData >> 16);
    interrupt.m_interruptPortInterrupt.m_data2 =  UINT32(g_UserData & 0xFFFFFFFF);

    //Dispatch interrupt to RTOSThread
    HRESULT hr;
    CPU_GPIO_SetPinState(157,TRUE);
    if(g_CLR_RT_ExecutionEngine.m_rtosInterruptThread){
    	g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_status =  CLR_RT_Thread::TH_S_Terminated;
    }
    hr = g_CLR_HW_Hardware.SpawnRTOSDispatcher(&interrupt);
    CPU_GPIO_SetPinState(157,FALSE);
    asyncCount++;

    /*if(FAILED(hr))
    {
    	//Dispatch has failed what should we do now?? Try dispatch again??
    	hr = g_CLR_HW_Hardware.SpawnRTOSDispatcher(&interrupt);
    }*/
    //Execute Thread

    //if(SUCCEEDED(hr)){


		CPU_GPIO_SetPinState(57,TRUE);
		//g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->Execute();
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_timeQuantumExpired=FALSE;
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_isRtosThread=TRUE;
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->Execute_Inner();
		//g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->RTOS_Thread_Execute();
		CPU_GPIO_SetPinState(57,FALSE);
    //}
#else
    //Generate a Software Interrupt and Add to HAL Queue
    SaveNativeEventToHALQueue( pContext, UINT32(g_UserData >> 16), UINT32(g_UserData & 0xFFFFFFFF) );

    //Events_Set(SYSTEM_EVENT_FLAG_TIMER2);
    //Process the Interrupt Too
    //g_CLR_HW_Hardware.ProcessInterrupts();
#endif

}

void GenerateSoftInterrupt(){
	TIAM3517_AITC &INTC = TIAM3517::AITC();
	INTC.Reg[1].INTCPS_ISR_SET |= (1 << (SOFT_INTERRUPT_INDEX &31)); //using interrupt 85 on AM3517 which is a reserved interrupt
}

void GenerateInterrupt( HRESULT &hr )
{
    if ( g_Context == NULL )
    {
        // Generates exception if context not set.
        hr = CLR_E_DRIVER_NOT_REGISTERED;
        return;
    }

    ISR_AsyncTimerProc( g_Context );
}

void ISR_SoftInterrupt_Handler (void* Param){
	CPU_GPIO_SetPinState( 57, TRUE );
	CPU_GPIO_SetPinState( 57, FALSE );
	TIAM3517_AITC &INTC = TIAM3517::AITC();
	//Clear the Software register
	INTC.Reg[1].INTCPS_ISR_CLEAR |= (1 << (SOFT_INTERRUPT_INDEX &31)); //using interrupt 85 on AM3517 which is a reserved interrupt
	HRESULT hresult;
	GenerateInterrupt(hresult);
}

void ISR_ASYNC_TIMER (void* Param){
	//Reset timer interrupt
	HRESULT hresult;
	if(TIAM3517_TIMER_Driver::DidCompareHit( ASYNCTIMER))
	{
	        TIAM3517_TIMER_Driver::ResetCompareHit( ASYNCTIMER );
	}

	if(RollOverCount==0){
		CPU_GPIO_SetPinState( 56, FALSE );

		UINT32 Counter= TIAM3517_TIMER_Driver::GetCounter(ASYNCTIMER);
		Counter= Counter +  AsyncTimerTicks;
		TIAM3517_TIMER_Driver::SetCompare( ASYNCTIMER, Counter);

		//Generate Soft interrupt
		GenerateSoftInterrupt();
		//GenerateInterrupt(hresult);

	}else {
		if(RollOver==RollOverCount){
				CPU_GPIO_SetPinState( 56, FALSE );

				TIAM3517_TIMER_Driver::SetCounter(ASYNCTIMER,0);
				TIAM3517_TIMER_Driver::SetCompare( ASYNCTIMER, 0xFFFFFFFF);
				RollOver=0;

				//Generate Soft Interrupt
				GenerateSoftInterrupt();
				//GenerateInterrupt(hresult);

		}else if (RollOver==RollOverCount-1){
				TIAM3517_TIMER_Driver::SetCompare( ASYNCTIMER, RollOverTicks);
				RollOver++;
		}else{
				RollOver++;
				TIAM3517_TIMER_Driver::SetCompare( ASYNCTIMER, 0xFFFFFFFF);
		}
	}
}

static const CLR_RT_DriverInterruptMethods g_InteropAsyncTimerDriverMethods =

{ InitializeAsyncTimerDriver,
  EnableDisableAsyncTimerDriver,
  CleanupAsyncTimerDriver
};

static const CLR_RT_MethodHandler method_lookup[] =
{
    NULL,
    Library_AsyncTimer_Microsoft_SPOT_Interop_AsyncTimer::GenerateInterrupt___STATIC__VOID,
};


const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_AsyncTimer =
{
    "AsyncTimer",
    0x6848EA00,
    //DRIVER_INTERRUPT_METHODS_CHECKSUM,
    //&g_InteropAsyncTimerDriverMethods
    method_lookup
};

const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_AsyncInteropTimer  =
{
    "AsyncInteropTimer",
    //0x6848EA00,
    DRIVER_INTERRUPT_METHODS_CHECKSUM,
    &g_InteropAsyncTimerDriverMethods
    //method_lookup
};
