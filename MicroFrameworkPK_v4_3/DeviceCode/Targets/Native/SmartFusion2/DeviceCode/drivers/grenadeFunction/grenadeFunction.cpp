#include <tinyhal.h>
#include <cmsis/m2sxxx.h>
#include <drivers/mss_spi/mss_spi.h>
#include <sys_services/SysServices.h>
#include <crypto.h>
#include "../microsemi_lib/CMSIS/mss_assert.h"

#define KERNEL_SIZE 50000
#define SIGSIZE 32
#define eNVMAddress 0x60000000
#define RoT_Offset 0x0F000
#define STANDARD_SERV_RESP_LENGTH                       6u
#define HMAC_KEY_LENGTH     32u
#define HMAC_REQUEST_CMD                                12u

UINT8 dKey[SIGSIZE] = {
		0xC6, 0x29, 0x73, 0xE3, 0xC8, 0xD4, 0xFC, 0xB6,
        0x89, 0x36, 0x46, 0xF9, 0x58, 0xE5, 0xF5, 0xE5,
        0x25, 0xC2, 0xE4, 0x1E, 0xCC, 0xA8, 0xC3, 0xEF,
        0xA2, 0x8D, 0x24, 0xDE, 0xFD, 0x19, 0xDA, 0x08
};

UINT8 badSig[SIGSIZE] = {
		0x35, 0x75, 0xb3, 0xf7, 0x52, 0xdb, 0xd8, 0x95,
		0x09, 0x2e, 0xfd, 0x90, 0xf5, 0xe6, 0x95, 0x7f,
		0x10, 0x91, 0xe3, 0x42, 0x46, 0x9f, 0xff, 0x5e,
		0xa6, 0xe3, 0xcf, 0xa5, 0xf4, 0x0b, 0xc3, 0x1f
};

UINT8 correctSig[SIGSIZE] = {
		0xf4, 0xf6, 0x66, 0xd0, 0x38, 0x94, 0xee, 0x4e,
		0xf9, 0x32, 0x61, 0xfd, 0x28, 0x97, 0x6a, 0x05,
		0x60, 0xc0, 0xc3, 0x45, 0x79, 0xc6, 0x44, 0x90,
		0x03, 0x46, 0x16, 0xe2, 0x83, 0x64, 0x40, 0xc0
};

UINT8* dSig=correctSig;

void PrintHex(uint8_t* data, int size){
	for (int j=0;j<size; j++){
		hal_printf("0x%.2X , ",data[j]);
	}
	hal_printf("\n");
}

static volatile uint8_t mSig[SIGSIZE];

int codeIntegrityCheck(uint8_t* memory, uint32_t memorySize){
	int status=0;
	
	return 0;
	//status = generate_hmac(dKey, (uint8_t*)eNVMAddress, KERNEL_SIZE, (uint8_t*)mSig);
	if (status != 0){
		PrintHex((uint8_t*)mSig, SIGSIZE);
		memset((uint8_t*)mSig, 0, SIGSIZE);
	}

	return 0;
}

