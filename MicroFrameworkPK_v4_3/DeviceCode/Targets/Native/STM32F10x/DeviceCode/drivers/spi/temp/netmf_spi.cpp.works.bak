/*

Fill program information here

FIXME - As of now some parts of SPI_StructInit irrespective of SPI_CONFIG
        Try to map the whole thing to .NET MF GPIO APIS, right now using lower level APIs directly

*/

/*--------- Includes ----------- */

#include "spi/netmf_spi.h"

/*--------- Macros ----------- */

#define DEBUG_SPI 
#define MAX_SPI_PORTS 3


/* SPI peripheral Configuration */
#define SPIx             SPI1
#define SPIx_CLK         RCC_APB2Periph_SPI1
#define SPIx_GPIO        GPIOA  
#define SPIx_GPIO_CLK    RCC_APB2Periph_GPIOA 
#define SPIx_NSS	     GPIO_Pin_4
#define SPIx_PIN_MOSI    GPIO_Pin_5
#define SPIx_PIN_MISO	 GPIO_Pin_6
#define SPIx_PIN_SCK     GPIO_Pin_7 

#define SPIy             SPI2
#define SPIy_CLK         RCC_APB1Periph_SPI2
#define SPIy_GPIO        GPIOB
#define SPIy_GPIO_CLK    RCC_APB2Periph_GPIOB 
#define SPIy_NSS	     GPIO_Pin_12
#define SPIy_PIN_MOSI    GPIO_Pin_13
#define SPIy_PIN_MISO	 GPIO_Pin_14
#define SPIy_PIN_SCK     GPIO_Pin_15

/*Not defining SPI3 as of now
#define SPIz             SPI1
#define SPIz_CLK         RCC_APB1Periph_SPI3
#define SPIz_GPIO        GPIOA  
#define SPIz_GPIO_CLK    RCC_ABP2Periph_GPIOA 
#define SPIz_NSS	     GPIO_Pin_4
#define SPIz_MOSI        GPIO_Pin_5
#define SPIz_MISO	     GPIO_Pin_6
#define SPIz_SCK         GPIO_Pin_7
*/

/*--------- Global Variables ----------- */
SPI_InitTypeDef SPI_InitStructure;

//index indicates the SPI peripheral initialized
int SPI_Initialized[] = {0};


/*--------- Internal fucntion prototypes ----------- */

BOOL CPU_SPI_Initialize ()
{

	/*

	Set the GPIO pins for the SPI

	Note:
	Turns out that for SPI we need to 
	only set the GPIO Pins in Initialize()
	The RCC and SPI enable will be called
	from XStart()

	TODO: Right now we have no way to know if the pins are stolen by any other device
	before we are restting it. Handle tht in future.

	*/
#if defined(DEBUG_SPI)
	hal_printf("SPI Initialize\n");
#endif

	NATIVE_PROFILE_HAL_PROCESSOR_SPI();
	
	//Initialize Clocks for SPI and GPIO
	RCC_Config();
		
	//Initialize NVIC
	NVIC_Config();
		
	//TODO Make sure the GPIO pins are available and if they are put them in safe state
	/*
	CPU_GPIO_EnableInputPin(SPIx_NSS, FALSE, NULL, 0, GPIO_Mode_AIN);
    CPU_GPIO_EnableInputPin(SPIx_PIN_MOSI, FALSE, NULL, 0, GPIO_Mode_AIN);
    CPU_GPIO_EnableInputPin(SPIx_PIN_MISO, FALSE, NULL, 0, GPIO_Mode_AIN);
	CPU_GPIO_EnableInputPin(SPIx_PIN_SCK, FALSE, NULL, 0, GPIO_Mode_AIN);

	CPU_GPIO_EnableInputPin(SPIy_NSS, FALSE, NULL, 0, GPIO_Mode_AIN);
    CPU_GPIO_EnableInputPin(SPIy_PIN_MOSI, FALSE, NULL, 0, GPIO_Mode_AIN);
    CPU_GPIO_EnableInputPin(SPIy_PIN_MISO, FALSE, NULL, 0, GPIO_Mode_AIN);
	CPU_GPIO_EnableInputPin(SPIy_PIN_SCK, FALSE, NULL, 0, GPIO_Mode_AIN);
	*/
    SPI_Initialized[0]= 1; //SPIx
	SPI_Initialized[1]= 1; //SPIy

    
}

void CPU_SPI_Uninitialize()
{
	/* Reset the SPI peripherals */
#if defined(DEBUG_SPI)
	hal_printf("SPI Uninitialize\n");
#endif

	//Enable and Disable Reset States for all the SPI peripherals
	
	//SPI1
	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);    
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);

	//SPI2
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);

	//SPI3
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
	RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
	
}

void CPU_SPI_GetPins (UINT32 spi_mod, GPIO_PIN& msk, GPIO_PIN& miso, GPIO_PIN& mosi)
{
	/* Return the GPIO pin for selected SPI */

#if defined(DEBUG_SPI)
	hal_printf("SPI GetPins\n");
#endif

	switch (spi_mod)
	{
	case 0:
		msk = GPIO_Pin_7;
		miso = GPIO_Pin_6;
		mosi = GPIO_Pin_5;
		break;

	case 1:
		msk = GPIO_Pin_15;
		miso = GPIO_Pin_14;
		mosi = GPIO_Pin_13;
		break;
	
	default:
		break;

	}
}

UINT32 CPU_SPI_PortsCount()
{
	/* Returns the total no. of SPI peripherals */
#if defined(DEBUG_SPI)
	hal_printf("SPI PortsCount\n");
#endif

	return (UINT32)MAX_SPI_PORTS;
}

BOOL CPU_SPI_nWrite16_nRead16( const SPI_CONFIGURATION& Configuration, UINT16* Write16, INT32 WriteCount, UINT16* Read16, INT32 ReadCount, INT32 ReadStartOffset )
{

	/* Performs a read/write operation on 16-bit word data.  */
	
#if defined(DEBUG_SPI)
	hal_printf("SPI nWrite16_nRead16\n");
#endif

	if(SPI_Initialized[Configuration.SPI_mod] == 0)
	{
#if defined(DEBUG_SPI)
		hal_printf("SPI peripheral uninitialized\n");
#endif
		return false;
	}

	if(Configuration.SPI_mod > MAX_SPI_PORTS)
	{
#if defined(DEBUG_SPI)
		hal_printf("Ports specified exceeds total number of ports\n");
#endif
		return false;
	}

	if(!CPU_SPI_Xaction_Start(Configuration))
	{
#if defined(DEBUG_SPI)
		hal_printf("Could not start X\n");
#endif
		return false;
	}

	else
	{
		SPI_XACTION_16 Transaction;

		Transaction.Read16 = Read16;
		Transaction.ReadCount = ReadCount;
		Transaction.ReadStartOffset = ReadStartOffset;
		Transaction.Write16 = Write16;
        Transaction.WriteCount = WriteCount;
        Transaction.SPI_mod = Configuration.SPI_mod;
        Transaction.BusyPin = Configuration.BusyPin;

		if(!CPU_SPI_Xaction_nWrite16_nRead16(Transaction))
		{
			return FALSE;
		}		
		
	}	

	return CPU_SPI_Xaction_Stop(Configuration);
	
}

BOOL CPU_SPI_nWrite8_nRead8( const SPI_CONFIGURATION& Configuration, UINT8* Write8, INT32 WriteCount, UINT8* Read8, INT32 ReadCount, INT32 ReadStartOffset )
{

	/* Performs a read/write operation on 8-bit word data.  */
#if defined(DEBUG_SPI)	
	hal_printf("SPI nWrite16_nRead16\n");
#endif

	if(SPI_Initialized[Configuration.SPI_mod] == 0)
	{
#if defined(DEBUG_SPI)
		hal_printf("SPI peripheral uninitialized\n");
#endif
		return false;
	}

	if(Configuration.SPI_mod > MAX_SPI_PORTS)
	{
#if defined(DEBUG_SPI)
		hal_printf("Ports specified exceeds total number of ports\n");
#endif
		return false;
	}

	if(!CPU_SPI_Xaction_Start(Configuration))
	{
#if defined(DEBUG_SPI)
		hal_printf("Could not start X\n");
#endif
		return false;
	}

	else
	{
		SPI_XACTION_8 Transaction;

		Transaction.Read8 = Read8;
		Transaction.ReadCount = ReadCount;
		Transaction.ReadStartOffset = ReadStartOffset;
		Transaction.Write8 = Write8;
        Transaction.WriteCount = WriteCount;
        Transaction.SPI_mod = Configuration.SPI_mod;
        Transaction.BusyPin = Configuration.BusyPin;

		if(!CPU_SPI_Xaction_nWrite8_nRead8(Transaction))
		{
			return FALSE;
		}		
		
	}	

	return CPU_SPI_Xaction_Stop(Configuration);
	
}

BOOL CPU_SPI_Xaction_Start( const SPI_CONFIGURATION& Configuration )
{
	/*

	Sets up and starts a read/write operation using the specified configuration. 

	TODO: 
	- Map the Configuration Value to the SPI Struct values, 
	as of now initializing with default values in SPI_StructInit
	- Set the CS wait in uS, pull it from the time driver

	*/

	//Set pins to correct state
	GPIO_Config(Configuration);
	
	//Initialize default SPI Struct, this configures SPIx as Master
	SPI_StructInit(Configuration);

	//Initialize the SPI 1
	SPI_Init(SPIx, &SPI_InitStructure);	

	//Enable
	SPI_Cmd(SPIx, ENABLE); 

	//I don't know if we really need to do it, but still I am halting for CS_Setup_uSecs

	if(Configuration.CS_Setup_uSecs)
	{
		HAL_Time_Sleep_MicroSeconds_InterruptEnabled(Configuration.CS_Setup_uSecs);        
	}

	return true;
	
}

BOOL CPU_SPI_Xaction_Stop( const SPI_CONFIGURATION& Configuration )
{
	/*
	
	Completes a read/write operation using the specified configuration. 

	TODO: 
	- Map the configuration to SPI Struct Values
	- Wait till time in uS, pull it from the time driver
	*/

	if(Configuration.CS_Hold_uSecs)
    {
		HAL_Time_Sleep_MicroSeconds_InterruptEnabled(Configuration.CS_Hold_uSecs);
    }

	SPI_I2S_DeInit(SPIx);
	return true;
}

BOOL CPU_SPI_Xaction_nWrite16_nRead16( SPI_XACTION_16& Transaction )
{
	/*
	Performs a low-level read/write operation on 16-bit word data
	*/
	UINT16 Data16;
    INT32 i;
    INT32 d;

	/*
	//check if SPI is initialized
	if(SPI_Initialized[0] == 0) //TODO: Index hard-coded for now
	{
#if defined(DEBUG_SPI)
		hal_printf("SPI peripheral uninitialized\n");
#endif
		return false;
	}
	*/
	
	UINT16 *Write16 = Transaction.Write16;
    INT32 WriteCount = Transaction.WriteCount;
    UINT16 *Read16 = Transaction.Read16;
    INT32 ReadCount = Transaction.ReadCount;
    INT32 ReadStartOffset = Transaction.ReadStartOffset;

	// check for boudary error conditions

    if(WriteCount <= 0)
    {
        //ASSERT(FALSE); commenting for now as I am not sure of the handling
        return FALSE;
    }

    if(Write16 == NULL)
    {
        //ASSERT(FALSE);
        return FALSE;
    }

	if((ReadCount > 0) && (Read16 == NULL))
    {
        //ASSERT(FALSE);
        return FALSE;
    }

    if(ReadCount)
    {
        i = ReadCount + ReadStartOffset; // we need to read as many bytes as the buffer is long, plus the offset at which we start
        d = ReadCount; // 
    }
    else
    {
        i = WriteCount;
        d =  - 1;
    }

    // we will use WriteCount to move in the Write16 array
    // so we do no want to go past the end when we will check for 
    // WriteCount to be bigger than zero
    WriteCount -= 1;

	while(i--)
    {		
		//wait till data is transmitted
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_TXE) == RESET);        
		SPI_I2S_SendData(SPIx, Write16[0]);

		//wait till we are ready to recieve		
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_RXNE) == RESET);
		Data16 = SPI_I2S_ReceiveData(SPIx);		

        // repeat last write word for all subsequent reads
        if(WriteCount)
        {
            WriteCount--;
            Write16++;
        }

        // only save data once we have reached ReadCount-1 portion of words
        if(i < d)
        {
            Read16[0] = Data16;
            Read16++;
        }
    }

	return true;
}

BOOL CPU_SPI_Xaction_nWrite8_nRead8( SPI_XACTION_8& Transaction )
{
	/*
	Performs a low-level read/write operation on 8-bit word data
	*/
	INT32 i;
    INT32 d;
    UINT8 Data8;

/*
//check if SPI is initialized
	if(SPI_Initialized[1] == 0) //TODO: Index hard-coded for now
	{
#if defined(DEBUG_SPI)
		hal_printf("SPI peripheral uninitialized\n");
#endif
		return false;
	}
*/
	UINT8 *Write8 = Transaction.Write8;
    INT32 WriteCount = Transaction.WriteCount;
    UINT8 *Read8 = Transaction.Read8;
    INT32 ReadCount = Transaction.ReadCount;
    INT32 ReadStartOffset = Transaction.ReadStartOffset;

	if(WriteCount <= 0)
    {		
        //ASSERT(FALSE);
        return FALSE;
    }
    if(Write8 == NULL)
    {		
        //ASSERT(FALSE);
        return FALSE;
    }
    if((ReadCount > 0) && (Read8 == NULL))
    {			
        //ASSERT(FALSE);
        return FALSE;
    }

    if(ReadCount)
    {
        i = ReadCount + ReadStartOffset; // we need to read as many bytes as the buffer is long, plus the offset at which we start
        d = ReadCount; // 
    }
    else
    {
        i = WriteCount;
        d =  - 1;
    }

    // we will use WriteCount to move in the Write8 array
    // so we do no want to go past the end when we will check for 
    // WriteCount to be bigger than zero
    WriteCount -= 1;

    // Start transmission 
    while(i--)
    {		
		// wait while the transmit buffer is empty
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_TXE) == RESET);        
		SPI_I2S_SendData(SPIx, (UINT16)Write8[0]); //TODO:	Need to check on the cast, just casting as of now
	    
		// wait for data reception
		while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_RXNE) == RESET);
        Data8 = (UINT8) SPI_I2S_ReceiveData(SPIx);

        // repeat last write word for all subsequent reads
        if(WriteCount)
        {
            WriteCount--;
            Write8++;
        }

        // only save data once we have reached ReadCount-1 portion of words
        if(i < d)
        {
            Read8[0] = Data8;
            Read8++;
        }
    }

	return true;
}

void SPI_StructInit(const SPI_CONFIGURATION& Configuration)
{
#if 0
  /* Initialize the SPI_Direction member */
  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //this is not specified by the framework, we need it to initialize
  /* initialize the SPI_Mode member */
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master; //this is not specified by the framework, we need it to initialize
  /* initialize the SPI_DataSize member */
  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; //this is not specified by the framework, we need it to initialize
  /* Initialize the SPI_CPOL member */
  SPI_InitStructure.SPI_CPOL = Configuration.MSK_IDLE; //SPI_CPOL_Low;
  /* Initialize the SPI_CPHA member */
  SPI_InitStructure.SPI_CPHA = Configuration.MSK_SampleEdge; //SPI_CPHA_2Edge;
  /* Initialize the SPI_NSS member */
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; //How do we need to set NSS? In H/W or S/W?
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; // TODO: Right now we are pre-scaling map it to configuration clock
  /* Initialize the SPI_FirstBit member */
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStructure.SPI_CRCPolynomial = 7;	
#endif  
  /* Initialize the SPI_Direction member */
  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //this is not specified by the framework, we need it to initialize
  /* initialize the SPI_Mode member */
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master; //this is not specified by the framework, we need it to initialize
  /* initialize the SPI_DataSize member */
  if(Configuration.MD_16bits == false)
  {
	  SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; 
  }
  else
  {
	  SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
  }

  /* Initialize the SPI_CPOL member */
  SPI_InitStructure.SPI_CPOL = Configuration.MSK_IDLE; //SPI_CPOL_Low;
  /* Initialize the SPI_CPHA member */
  SPI_InitStructure.SPI_CPHA = Configuration.MSK_SampleEdge; //SPI_CPHA_2Edge;
  /* Initialize the SPI_NSS member */
  //FIXME: Check the SSOE bit value and make sure this is the right state
#if defined(SPI_NSS_SOFTWARE)
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft; 
#else
  SPI_InitStructure.SPI_NSS = SPI_NSS_Hard;
#endif 
  /* Initialize the SPI_BaudRatePrescaler member */
  //FIXME: // TODO: Right now we are pre-scaling map it to configuration clock
  switch (Configuration.Clock_RateKHz)
  {
  case 2:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
	  break;
  case 4:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
	  break;
  case 8:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	  break;
  case 16:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;
	  break;
  case 32:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_32;
	  break;
  case 64:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
	  break;
  case 128:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;
	  break;
  case 256:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
	  break;
  default:
	  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
	  break;
  }
   
  /* Initialize the SPI_FirstBit member */
#if defined(FIRST_BIT_LSB)
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;
#else
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
#endif
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStructure.SPI_CRCPolynomial = 7;		

}


void GPIO_Config(const SPI_CONFIGURATION& Configuration)
{
  GPIO_InitTypeDef GPIO_InitStructure;   
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

  switch(Configuration.SPI_mod)
  {
	  case 0:
		  /* Configure SPIx pins: SCK, MISO and MOSI */
		  GPIO_InitStructure.GPIO_Pin = SPIx_PIN_SCK | SPIx_PIN_MISO | SPIx_PIN_MOSI;          
          GPIO_Init(SPIx_GPIO, &GPIO_InitStructure);
		  break;

	  case 1:
		  /* Configure SPIy pins: SCK, MISO and MOSI */
		  GPIO_InitStructure.GPIO_Pin = SPIy_PIN_SCK | SPIy_PIN_MISO | SPIy_PIN_MOSI;
          GPIO_Init(SPIy_GPIO, &GPIO_InitStructure); 
		  break;

	  default:
#if defined(SPI_DEBUG)
		  hal_printf("Should not be here");
#endif
		  break;
  }


}

void RCC_Config()
{
  /* PCLK2 = HCLK/2 */
  RCC_PCLK2Config(RCC_HCLK_Div2); 
  
  /* Enable SPIx clock and GPIO clock for SPIx and SPIy */
  RCC_APB2PeriphClockCmd(SPIx_GPIO_CLK | SPIy_GPIO_CLK | SPIx_CLK, ENABLE);

  /* Enable SPIx Periph clock */
  RCC_APB1PeriphClockCmd(SPIy_CLK, ENABLE);
  
}

void NVIC_Config()
{
	/*
	TODO yet
	*/
	
}