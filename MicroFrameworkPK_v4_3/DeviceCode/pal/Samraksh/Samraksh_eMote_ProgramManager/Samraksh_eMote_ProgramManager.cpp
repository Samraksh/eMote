//-----------------------------------------------------------------------------
//
//    ** DO NOT EDIT THIS FILE! **
//    This file was generated by a tool
//    re-running the tool will overwrite this file.
//
//-----------------------------------------------------------------------------


#include "Samraksh_eMote_ProgramManager.h"


static const CLR_RT_MethodHandler method_lookup[] =
{
    NULL,
    NULL,
    NULL,
    Library_Samraksh_eMote_ProgramManager_Samraksh_eMote_ProgramManager_ProgramManager::UpdaterStart___BOOLEAN,
    Library_Samraksh_eMote_ProgramManager_Samraksh_eMote_ProgramManager_ProgramManager::UpdaterStart___BOOLEAN__U4,
    Library_Samraksh_eMote_ProgramManager_Samraksh_eMote_ProgramManager_ProgramManager::UpdaterSetDestination___VOID__U2,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_Samraksh_eMote_ProgramManager =
{
	"Samraksh_eMote_ProgramManager",
	0xDD4C0E62,
	method_lookup
};

#include <TinyCLR_Interop.h>
#include <PAK_decl.h>


CLR_RT_HeapBlock_NativeEventDispatcher* g_UpdateManagerContext = NULL;
UINT64 g_UpdateManagerUserData = 0;
BOOL g_UpdateManagerInterruptEnabled = FALSE;  //TODO: check this.
BOOL g_UpdateManager_Driver_Initialized = FALSE;


void NativeToManagedUpdaterProgressHandler(UINT32 updateID, UINT16 destAddr, UINT8 u4_cmd, UINT16 u12_data)
{
	hal_printf("NativeToManagedUpdaterProgressHandler.\r\n"); // Bill

	//TODO: filter messages based on user data?
	GLOBAL_LOCK(irq);
	SaveNativeEventToHALQueue( g_UpdateManagerContext, updateID, (((UINT32)destAddr) << 16) | (((UINT32)(u4_cmd & 0xF)) << 12) | ((UINT32)(u12_data & 0xFFF)) );
}

static HRESULT Initialize_UpdateManager_Driver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, UINT64 userData )
{
	g_UpdateManagerContext  = pContext;
    g_UpdateManagerUserData = userData;
    Samraksh_Emote_Update::s_UpdaterProgressHandler = &NativeToManagedUpdaterProgressHandler;
    g_UpdateManager_Driver_Initialized = TRUE;
    return S_OK;
}

static HRESULT EnableDisable_UpdateManager_Driver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, bool fEnable )
{
	g_UpdateManagerInterruptEnabled = fEnable;
	return S_OK;
}

static HRESULT Cleanup_UpdateManager_Driver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )
{
	if (g_UpdateManager_Driver_Initialized == TRUE) {
		g_UpdateManagerContext = NULL;
		g_UpdateManagerUserData = 0;
		CleanupNativeEventsFromHALQueue( pContext );
		g_UpdateManager_Driver_Initialized = FALSE;
	}
	return S_OK;
}


static const CLR_RT_DriverInterruptMethods g_CLR_UpdateManager_DriverMethods =
{
	Initialize_UpdateManager_Driver,
	EnableDisable_UpdateManager_Driver,
	Cleanup_UpdateManager_Driver
};

const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_UpdaterProgressCallback =
{
    "UpdaterProgressCallback",
    DRIVER_INTERRUPT_METHODS_CHECKSUM,
    &g_CLR_UpdateManager_DriverMethods
};
