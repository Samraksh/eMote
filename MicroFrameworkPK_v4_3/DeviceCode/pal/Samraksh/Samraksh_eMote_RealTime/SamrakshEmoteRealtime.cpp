//-----------------------------------------------------------------------------
//
//    ** DO NOT EDIT THIS FILE! **
//    This file was generated by a tool
//    re-running the tool will overwrite this file.
//
//-----------------------------------------------------------------------------

// The real-time timer is unable to be run under Visual Studios in debugger mode. It overrides the debugger messages causing VS to timeout.
// We look to see if we are running in debugger mode, and if so we print out a warning to the user stating that the real-time timer will
// have poor jitter and timing accuracy while in debug mode and we change the real-time timer to just a normal timer.

#include <tinyhal.h>
#include <TinyCLR_Hardware.h>
#include <TinyCLR_Runtime.h>
#include "../Include/Samraksh/VirtualTimer.h"

#include "SamrakshEmoteRealtime.h"

#ifdef PLATFORM_ARM_EmoteDotNow
#include <stm32f10x.h>
#endif

#define PEND_SV_INTERRUPT 60			//For .Now

//#define DEBUG_RT_TIMER

static bool g_RealTimeTimerEnalbed = false;
static CLR_RT_HeapBlock_NativeEventDispatcher *g_Context = NULL;
CLR_RT_ApplicationInterrupt interrupt;
static UINT64 g_UserData = 0;
UINT32 RealTimeTimerTicks;
UINT32 RealTimeTimerMicrosecs;
UINT32 ManagedTimerPeriodMicroSeconds;
UINT32 ManagedTimerDueTimeMicroSeconds;
UINT32 ManagedTimerTicks = 0, ManagedTimerMicrosecs = 0;
UINT64 RealTimeCount=0;

UINT32 maxTicks = 0;
UINT64 maxMicroseconds = 0;

void ISR_REALTIME_TIMER (void* Param);
void ISR_RT_Debugger (void* Param);
void ISR_SoftwareInterrupt_Handler (void* Param);
static void EnqueueEventToCLR( CLR_RT_HeapBlock_NativeEventDispatcher *pContext );
static int realTimeID = VIRT_TIMER_REALTIME;
static bool debuggerAttached = false;
#define REALTIME_TIMER_CNT_MAX 1
static int realtimeTimerCnt = 0;

BOOL InitializeTimer ()
{
	if (debuggerAttached == true)
	{
		realTimeID = VIRT_TIMER_REALTIME_DEBUGGER;
		if(VirtTimer_Change(realTimeID, 0, RealTimeTimerMicrosecs, false, ADVTIMER_32BIT) != TimerSupported)
		{
			if(VirtTimer_SetTimer(realTimeID, 0, RealTimeTimerMicrosecs, FALSE, TRUE, ISR_RT_Debugger, ADVTIMER_32BIT) != TimerSupported)
			{
				ASSERT(FALSE);
			}
		}
	} else {
		realTimeID = VIRT_TIMER_REALTIME;
		if(VirtTimer_Change(realTimeID, 0, RealTimeTimerMicrosecs, false, ADVTIMER_32BIT) != TimerSupported)
		{
			if(VirtTimer_SetTimer(realTimeID, 0, RealTimeTimerMicrosecs, FALSE, TRUE, ISR_REALTIME_TIMER, ADVTIMER_32BIT) != TimerSupported)
			{
				ASSERT(FALSE);
			}
		}
	}
		
	VirtTimer_Start( realTimeID );
	realtimeTimerCnt++;

	return TRUE;
}


BOOL RT_Dispose ()
{
	VirtTimer_Stop( realTimeID );
	if (debuggerAttached == false){
#ifdef PLATFORM_ARM_EmoteDotNow
		CPU_INTC_DeactivateInterrupt(PEND_SV_INTERRUPT);
#else
		//Need something similar to above for Adapt
#endif
	}
	g_RealTimeTimerEnalbed = false;
	CleanupNativeEventsFromHALQueue( g_Context );
	if (realtimeTimerCnt > 0){
		realtimeTimerCnt--;
	}
	return TRUE;
}

BOOL RT_Change(uint dueTime, uint period)
{
	VirtTimer_Change(realTimeID, dueTime, period, false, ADVTIMER_32BIT);

	return 1;
}

static HRESULT InitializeRealTimeTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, UINT64 userData )
{
   g_Context  = pContext;
   g_UserData = userData;

   if (realtimeTimerCnt >= REALTIME_TIMER_CNT_MAX){
		CLR_Debug::Printf("The maximum number of real-time timers allowed is: %d. %d real-time timers are currently running\r\n", REALTIME_TIMER_CNT_MAX, realtimeTimerCnt);
		return S_FALSE;
   }
   // We check here to see if we have a debugger attached.
   if(CLR_EE_DBG_IS( SourceLevelDebugging ))
	{
		debuggerAttached = true;
		CLR_Debug::Printf("Notice: the real-time timer is running in debugger mode!\r\n");
	} else 
	{
		debuggerAttached = false;
	}
   RealTimeTimerMicrosecs = userData;
   InitializeTimer();

#ifdef PLATFORM_ARM_EmoteDotNow
   //Register the software interrupt Handler
   //On eMote .Now, it is pendSV interrupt.
	if (debuggerAttached == false)
	{
		if(!CPU_INTC_ActivateInterrupt(PEND_SV_INTERRUPT, ISR_SoftwareInterrupt_Handler, NULL))
   		{
	   		debug_printf("Error Registering ISR Realtime hardware handler");
		}
	}
#else
   //Need something similar to above for Adapt
#endif
   return S_OK;
}

void ISR_SoftwareInterrupt_Handler (void* Param)
{
	HRESULT hresult;
	EnqueueEventToCLR( g_Context );
}

void ISR_RT_Debugger (void* Param)
{
	//Generate a Software Interrupt and Add to HAL Queue
    SaveNativeEventToHALQueue( g_Context, UINT32(g_UserData >> 16), UINT32(g_UserData & 0xFFFFFFFF) );
}


void GenerateInterrupt( HRESULT &hr )
{
    EnqueueEventToCLR( g_Context );
}

void GenerateSoftwareInterrupt()
{
#ifdef PLATFORM_ARM_EmoteDotNow
	SCB->ICSR |= SCB_ICSR_PENDSVSET;
#else
	//Below is temporary. Need something similar to above (.Now) for Adapt
	HRESULT hresult;
	GenerateInterrupt(hresult);
#endif
}

static void EnqueueEventToCLR( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )
{
    GLOBAL_LOCK(irq);

    HRESULT hr;
    if ( g_Context == NULL )
	{
		// Generates exception if context not set.
		hr = CLR_E_DRIVER_NOT_REGISTERED;
		return;
	}

#ifdef SAMRAKSH_RTOS_EXT  //Samraksh
	//Garbage Collector is running, dont mess with it, return immediately.
	if (g_CLR_RT_ExecutionEngine.m_heapState == g_CLR_RT_ExecutionEngine.c_HeapState_UnderGC) {
		return;
	}

	//CLR_RT_ApplicationInterrupt interrupt;
    interrupt.m_interruptPortInterrupt.m_context = pContext;
    interrupt.m_interruptPortInterrupt.m_time= Time_GetUtcTime();
    interrupt.m_interruptPortInterrupt.m_data1 = UINT32(g_UserData >> 16);
    interrupt.m_interruptPortInterrupt.m_data2 =  UINT32(g_UserData & 0xFFFFFFFF);

    //Dispatch interrupt to RTOSThread
    ////HRESULT hr;
#ifdef DEBUG_RT_TIMER
    CPU_GPIO_SetPinState(4,TRUE);
#endif
    if(g_CLR_RT_ExecutionEngine.m_rtosInterruptThread){
    	g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_status =  CLR_RT_Thread::TH_S_Terminated;
    }
    hr = g_CLR_HW_Hardware.SpawnRTOSDispatcher(&interrupt);
#ifdef DEBUG_RT_TIMER
    CPU_GPIO_SetPinState(4,FALSE);
#endif
    RealTimeCount++;

    //Execute Thread

    //if(SUCCEEDED(hr)){
#ifdef DEBUG_RT_TIMER
		CPU_GPIO_SetPinState(7,TRUE);
#endif
		//g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->Execute();
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_timeQuantumExpired=FALSE;
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->m_isRtosThread=TRUE;
		//g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->Execute_Inner();
		g_CLR_RT_ExecutionEngine.m_rtosInterruptThread->RTOS_Thread_Execute();
#ifdef DEBUG_RT_TIMER
		CPU_GPIO_SetPinState(7,FALSE);
#endif
    //}
#else
    //Generate a Software Interrupt and Add to HAL Queue
    SaveNativeEventToHALQueue( pContext, UINT32(g_UserData >> 16), UINT32(g_UserData & 0xFFFFFFFF) );
#endif
}


void ISR_REALTIME_TIMER (void* Param)
{
#ifdef DEBUG_RT_TIMER
	CPU_GPIO_SetPinState((GPIO_PIN) 30, FALSE);
#endif
		GenerateSoftwareInterrupt();
#ifdef DEBUG_RT_TIMER
	CPU_GPIO_SetPinState((GPIO_PIN) 30, FALSE);
#endif
}

static HRESULT EnableDisableRealTimeTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext, bool fEnable )
{
	if(fEnable)
		g_RealTimeTimerEnalbed = fEnable;
	else
		RT_Dispose();

   return S_OK;
}

static HRESULT CleanupRealTimeTimerDriver( CLR_RT_HeapBlock_NativeEventDispatcher *pContext )
{
	// If a user disposes of a real-time timer, usually this function will get called tens of seconds later to make sure all 
	// events are cleaned up. If we are currently running a new timer this function will break that timer.
	if (g_RealTimeTimerEnalbed == false){
	    g_Context = NULL;
	    g_UserData = 0;
	    CleanupNativeEventsFromHALQueue( pContext );
	}
    return S_OK;
}

static const CLR_RT_DriverInterruptMethods g_InteropRealTimeTimerDriverMethods =
{
	InitializeRealTimeTimerDriver,
	EnableDisableRealTimeTimerDriver,
	CleanupRealTimeTimerDriver
};

static const CLR_RT_MethodHandler method_lookup[] =
{
    NULL,
    NULL,
    NULL,
    Library_SamrakshEmoteRealtime_Samraksh_eMote_RealTime_Timer::Dispose___VOID,
    Library_SamrakshEmoteRealtime_Samraksh_eMote_RealTime_Timer::Change___BOOLEAN__U4__U4,
    Library_SamrakshEmoteRealtime_Samraksh_eMote_RealTime_Timer::GenerateInterrupt___VOID,
};

const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_Samraksh_eMote_RealTime =
{
    "Samraksh_eMote_RealTime", 
    0xB0BCF226,
    method_lookup
};

const CLR_RT_NativeAssemblyData g_CLR_AssemblyNative_RealTimeInteropTimer  =
{
    "RealTimeInteropTimer",
    //0x6848EA00,
    DRIVER_INTERRUPT_METHODS_CHECKSUM,
    &g_InteropRealTimeTimerDriverMethods
    //method_lookup
};
