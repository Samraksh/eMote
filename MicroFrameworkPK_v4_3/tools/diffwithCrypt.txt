diff --git a/MicroFrameworkPK_v4_3/Application/RoT/RoT_Services.cpp b/MicroFrameworkPK_v4_3/Application/RoT/RoT_Services.cpp
new file mode 100644
index 000000000..6e5e5efd0
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Application/RoT/RoT_Services.cpp
@@ -0,0 +1,18 @@
+/*
+ * RoT_Services.cpp
+ *
+ *  Created on: Apr 25, 2018
+ *      Author: MukundanSridharan
+ */
+
+#include "RoT_Services.h"
+
+bool AttestBinary(PBYTE  pData, PBYTE pSig, SigType st, KeyType kt, PBYTE key ){
+	return FALSE;
+}
+
+bool ComputeHMAC(PBYTE  pData, UINT32 ulDataLen, PBYTE pDigest, SigType mtype, KeyType kt, PBYTE key, UINT32 keyLen){
+	return FALSE;
+}
+
+
diff --git a/MicroFrameworkPK_v4_3/Application/RoT/RoT_Services.h b/MicroFrameworkPK_v4_3/Application/RoT/RoT_Services.h
new file mode 100644
index 000000000..9bf8a2608
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Application/RoT/RoT_Services.h
@@ -0,0 +1,14 @@
+#ifndef _ROT_SERVICES_H_
+#define _ROT_SERVICES_H_
+
+#include <tinyhal_types.h>
+
+enum KeyType{Symetric, PK };
+enum SigType{HMAC, SHA256};
+
+bool AttestBinary(PBYTE  pData, PBYTE pSig, SigType st, KeyType kt, PBYTE key );
+bool ComputeHMAC(PBYTE  pData, UINT32 ulDataLen, PBYTE pDigest, SigType mtype, KeyType kt, PBYTE key, UINT32 keyLen);
+
+
+
+#endif /* _ROT_SERVICES_H_ */
diff --git a/MicroFrameworkPK_v4_3/Application/RoT/dotNetMF.proj b/MicroFrameworkPK_v4_3/Application/RoT/dotNetMF.proj
new file mode 100644
index 000000000..b2dd61103
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Application/RoT/dotNetMF.proj
@@ -0,0 +1,49 @@
+ï»¿<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <AssemblyName>RoT</AssemblyName>
+    <ProjectGuid>070804E5-0025-48ee-8619-77C50DA8AC9E</ProjectGuid>
+    <Size>
+    </Size>
+    <Description>Root of Trust Application</Description>
+    <Level>CLR</Level>
+    <LibraryFile>RoT.$(LIB_EXT)</LibraryFile>
+    <ProjectPath>$(SPOCLIENT)\Application\RoT\dotNetMF.proj</ProjectPath>
+    <ManifestFile>RoT.$(LIB_EXT).manifest</ManifestFile>
+    <Groups>Cryptography</Groups>
+    <LibraryCategory>
+      <MFComponent xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Name="Crypto" Guid="{997AE9B5-A4A7-4540-AACA-6D8D2110E19F}" ProjectPath="" Conditional="" xmlns="">
+        <VersionDependency xmlns="http://schemas.microsoft.com/netmf/InventoryFormat.xsd">
+          <Major>4</Major>
+          <Minor>3</Minor>
+          <Revision>0</Revision>
+          <Build>0</Build>
+          <Extra />
+          <Date>2009-04-30</Date>
+        </VersionDependency>
+        <ComponentType xmlns="http://schemas.microsoft.com/netmf/InventoryFormat.xsd">LibraryCategory</ComponentType>
+      </MFComponent>
+    </LibraryCategory>
+    <Documentation>
+    </Documentation>
+    <PlatformIndependent>False</PlatformIndependent>
+    <CustomSpecific>
+    </CustomSpecific>
+    <Required>False</Required>
+    <IgnoreDefaultLibPath>False</IgnoreDefaultLibPath>
+    <IsStub>True</IsStub>
+    <Directory>Crypto\stubs</Directory>
+    <OutputType>Library</OutputType>
+    <HasAuxTargets>true</HasAuxTargets>
+    <NoOptForParserTarget>Release</NoOptForParserTarget>
+    <PlatformIndependentBuild>false</PlatformIndependentBuild>
+    <Version>4.0.0.0</Version>
+  </PropertyGroup>
+  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Settings" />
+  <PropertyGroup />
+  <ItemGroup>
+    <Compile Include="RoT_Services.cpp" />
+    <!--<IncludePaths Include="DeviceCode\PAL" />-->
+  </ItemGroup>
+  <ItemGroup />
+  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Targets" />
+</Project>
diff --git a/MicroFrameworkPK_v4_3/Crypto/Inc/crypto.h b/MicroFrameworkPK_v4_3/Crypto/Inc/crypto.h
index cc0f7d74b..9baea82fb 100644
--- a/MicroFrameworkPK_v4_3/Crypto/Inc/crypto.h
+++ b/MicroFrameworkPK_v4_3/Crypto/Inc/crypto.h
@@ -19,7 +19,7 @@
 #endif
 
 #define WATCH_ID_SIZE			5	// size in bytes of the watch ID string. It's obtained by getting the watch key signature and using the upper 40 bits
-#define AES_KEY_SIZE_BYTES		16	// size in bytes of the keys for AES symmetric encryption
+#define AES_KEY_SIZE_BYTES		32	// size in bytes of the keys for AES symmetric encryption
 #define TEA_KEY_SIZE_BYTES		16	// size in bytes of the keys for TEA symmetric encryption
 
 #define ACTIVATION_STRING_SIZE	17	// XXXXXXXXXXXXXXXX + zero termination
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2.cpp b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2.cpp
index f503e05a0..a0bf1a82e 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2.cpp
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2.cpp
@@ -1,13 +1,44 @@
-#include <tinyhal.h>
-#include <stm32f10x.h>
+#include <tinyhal_types.h>
+#include <SmartPtr_irq.h>
 
-#if defined(SAMRAKSH_RTOS_EXT)
-#warning "GLOBAL_LOCK may interfere with real time. Need a new version of SmartPtr that utilizes the BASEPRI register to disable all interrupts except realtime."
-#endif
+//#include <tinyhal.h>
 
 //--//
 
-const uint32_t DISABLED_MASK = 0x1;
+#define DISABLED_MASK 0x1
+#define __ASM __asm
+#define __INLINE inline
+
+
+#if (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+static __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
+static __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
+
+static __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
+static __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
+
+static __INLINE void __NOP()                      { __ASM volatile ("nop"); }
+static __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
+static __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
+static __INLINE void __SEV()                      { __ASM volatile ("sev"); }
+static __INLINE void __ISB()                      { __ASM volatile ("isb"); }
+static __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
+static __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
+static __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
+
+UINT32 __get_PRIMASK(void)
+{
+  UINT32 result=0;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+#endif
+
+
 
 SmartPtr_IRQ::SmartPtr_IRQ(void* context)
 {
@@ -41,7 +72,10 @@ void SmartPtr_IRQ::Release()
 
     if ((Cp & DISABLED_MASK) == 0)
     {
-        m_state = __get_PRIMASK();
+        register UINT32 Cs = __get_PRIMASK();
+
+        m_state = Cs;
+
         __enable_irq();
     }
 }
@@ -52,7 +86,9 @@ void SmartPtr_IRQ::Probe()
 
     if ((Cp & DISABLED_MASK) == 0)
     {
-        register UINT32 state = __get_PRIMASK();
+        register UINT32 Cs =__get_PRIMASK();
+
+        UINT32 s = Cs;
 
         __enable_irq();
 
@@ -60,13 +96,13 @@ void SmartPtr_IRQ::Probe()
         __NOP();
 
         // restore irq state
-        __set_PRIMASK( state );
+        Cs = s;
     }
 }
 
 BOOL SmartPtr_IRQ::GetState(void* context)
 {
-	register UINT32 Cp = __get_PRIMASK();
+    register UINT32 Cp = __get_PRIMASK();
     return (0 == (Cp & DISABLED_MASK));
 }
 
@@ -84,7 +120,9 @@ BOOL SmartPtr_IRQ::ForceEnabled(void* context)
 
 void SmartPtr_IRQ::Disable()
 {
-    m_state = __get_PRIMASK();
+    register UINT32 Cp = __get_PRIMASK();
+
+    m_state = Cp;
 
     __disable_irq();
 }
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2_sf2_hal.cpp b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2_sf2_hal.cpp
new file mode 100644
index 000000000..efd4b8044
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/SmartPtr_thumb2_sf2_hal.cpp
@@ -0,0 +1,98 @@
+#include <tinyhal_types.h>
+#include <SmartPtr_irq.h>
+#include <hal.h>
+
+#if defined(SAMRAKSH_RTOS_EXT)
+#warning "GLOBAL_LOCK may interfere with real time. Need a new version of SmartPtr that utilizes the BASEPRI register to disable all interrupts except realtime."
+#endif
+
+//--//
+
+const uint32_t DISABLED_MASK = 0x1;
+
+SmartPtr_IRQ::SmartPtr_IRQ(void* context)
+{
+    m_context = context;
+    Disable();
+}
+
+SmartPtr_IRQ::~SmartPtr_IRQ()
+{
+    Restore();
+}
+
+BOOL SmartPtr_IRQ::WasDisabled()
+{
+    return (m_state & DISABLED_MASK) == DISABLED_MASK;
+}
+
+void SmartPtr_IRQ::Acquire()
+{
+    UINT32 Cp = m_state;
+
+    if ((Cp & DISABLED_MASK) == DISABLED_MASK)
+    {
+        Disable();
+    }
+}
+
+void SmartPtr_IRQ::Release()
+{
+    UINT32 Cp = m_state;
+
+    if ((Cp & DISABLED_MASK) == 0)
+    {
+        m_state = (UINT32)HAL_get_interrupts();
+        HAL_restore_interrupts((psr_t)m_state);
+    }
+}
+
+//Not sure what the whole purpose is
+void SmartPtr_IRQ::Probe()
+{
+   /*
+	UINT32 Cp = m_state;
+
+    if ((Cp & DISABLED_MASK) == 0)
+    {
+        register UINT32 state = __get_PRIMASK();
+
+        __enable_irq();
+
+        // just to allow an interupt to an occur
+        __NOP();
+
+        // restore irq state
+        __set_PRIMASK( state );
+    }
+    */
+}
+
+BOOL SmartPtr_IRQ::GetState(void* context)
+{
+	register UINT32 Cp = (UINT32)HAL_get_interrupts();
+    return (0 == (Cp & DISABLED_MASK));
+}
+
+BOOL SmartPtr_IRQ::ForceDisabled(void* context)
+{
+	HAL_disable_interrupts();
+    return true;
+}
+
+BOOL SmartPtr_IRQ::ForceEnabled(void* context)
+{
+	HAL_enable_interrupts();
+    return true;
+}
+
+void SmartPtr_IRQ::Disable()
+{
+    m_state = (UINT32) HAL_disable_interrupts();
+}
+
+void SmartPtr_IRQ::Restore()
+{
+    HAL_restore_interrupts((psr_t)m_state);
+}
+
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/dotNetMF.proj b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/dotNetMF.proj
index 3ded9974c..25e0d863b 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/dotNetMF.proj
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/cores/arm/Common/GlobalLock/gcc-thumb2/dotNetMF.proj
@@ -1,7 +1,7 @@
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
 
   <PropertyGroup>
-    <Directory>DeviceCode\Targets\Native\STM32F10x\DeviceCode\cores\arm\Common\GlobalLock\gcc-thumb2</Directory>
+    <Directory>DeviceCode\Targets\Native\SmartFusion2\DeviceCode\cores\arm\Common\GlobalLock\gcc-thumb2</Directory>
   </PropertyGroup>
 
   <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Settings" />
@@ -13,11 +13,14 @@
 
   <ItemGroup>
     <Compile Include="SmartPtr_thumb2.cpp" />
+ 	<!--<Compile Include="..\..\..\..\..\microsemi_lib\hal\CortexM3\GNU\hal.S" />-->
  </ItemGroup>
 
   <ItemGroup>
     <IncludePaths Include="DeviceCode\include"/>
-    <IncludePaths Include="DeviceCode\Targets\Native\STM32F10x\DeviceCode\cmsis"/>  
+    <!--<IncludePaths Include="DeviceCode\Targets\Native\SmartFusion2\DeviceCode\microsemi_lib\cmsis"/>  
+    <IncludePaths Include="DeviceCode\Targets\Native\SmartFusion2\DeviceCode\microsemi_lib\hal"/>
+    -->
   </ItemGroup>
 
   <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Targets" />
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/intc/SF2__AITC.cpp b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/intc/SF2__AITC.cpp
index e5528fd04..e74df447b 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/intc/SF2__AITC.cpp
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/intc/SF2__AITC.cpp
@@ -17,6 +17,9 @@
 #undef  DEBUG_TRACE
 #define DEBUG_TRACE (TRACE_ALWAYS)
 
+#define INTERRUPT_START GLOBAL_LOCK(x)
+#define INTERRUPT_END
+
 ////////////////////////////////////////////////////////////////////////////////
 
 //#define DEBUG_DOTNOW_ISR
@@ -372,8 +375,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC& AITC = SF2::AITC();
 
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 		
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_SVCall]++;
@@ -388,8 +391,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 
 		//ISR_PendSV_Handler(NULL);
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END
+
 
 	}
 
@@ -402,8 +405,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC& AITC = SF2::AITC();
 
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 		
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_PendSV]++;
@@ -418,8 +421,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 
 		//ISR_PendSV_Handler(NULL);
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END
+
 	}
 
 
@@ -442,8 +445,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 
 		GLOBAL_LOCK(irq);
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 		irq.Release();
 
 #ifdef DEBUG_DOTNOW_ISR
@@ -457,8 +460,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		IsrVector->Handler.Execute();
 
 		irq.Acquire();
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END
+
 	}
 
 	void __irq ENVM0_IRQHandler()
@@ -467,8 +470,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC& AITC = SF2::AITC();
 
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 		
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_FLASH]++;
@@ -482,8 +485,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		IsrVector->Handler.Execute();
 
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END
+
 	}
 
 	void __irq TIM1_CC_IRQHandler()
@@ -492,8 +495,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC& AITC = SF2::AITC();
 		GLOBAL_LOCK(irq);
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_TIM1_CC]++;
@@ -502,8 +505,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC_Driver::IRQ_VECTORING* IsrVector = &SF2_AITC_Driver::s_IsrTable[VectorIndex::c_IRQ_INDEX_TIM1_CC];
 		IsrVector->Handler.Execute();
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END;
+
 	}
 
 	void __irq  TIM2_IRQHandler()
@@ -512,8 +515,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC& AITC = SF2::AITC();
 		GLOBAL_LOCK(irq);
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_TIM1_CC]++;
@@ -522,8 +525,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC_Driver::IRQ_VECTORING* IsrVector = &SF2_AITC_Driver::s_IsrTable[VectorIndex::c_IRQ_INDEX_TIM2];
 		IsrVector->Handler.Execute();
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END;
+
 	}
 
 
@@ -535,8 +538,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 		SF2_AITC& AITC = SF2::AITC();
 
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 
 #ifdef DEBUG_DOTNOW_ISR
 	interrupt_count[c_IRQ_INDEX_USART1]++;
@@ -548,8 +551,8 @@ void HardFault_HandlerC(unsigned long *hardfault_args)
 
 		IsrVector->Handler.Execute();
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END;
+
 	}
 
 void __irq USB_IRQHandler()
@@ -560,8 +563,8 @@ void __irq USB_IRQHandler()
 		//LED_GREEN();
 
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_USB_LP_CAN_RX0]++;
@@ -574,8 +577,8 @@ void __irq USB_IRQHandler()
 		IsrVector->Handler.Execute();
 
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END;
+
 	}
 
 	void __irq DMA_IRQHandler()
@@ -586,8 +589,8 @@ void __irq USB_IRQHandler()
 
 		// set before jumping elsewhere or allowing other interrupts
 		GLOBAL_LOCK(irq);
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 		irq.Release();
 
 #ifdef DEBUG_DOTNOW_ISR
@@ -599,8 +602,8 @@ void __irq USB_IRQHandler()
 		IsrVector->Handler.Execute();
 
 		irq.Acquire();
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END;
+
 		irq.Release();
 	}
 
@@ -611,8 +614,8 @@ void __irq USB_IRQHandler()
 		SF2_AITC& AITC = SF2::AITC();
 
 		// set before jumping elsewhere or allowing other interrupts
-		SystemState_SetNoLock( SYSTEM_STATE_ISR              );
-		SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+		INTERRUPT_START;
+
 
 #ifdef DEBUG_DOTNOW_ISR
 		interrupt_count[c_IRQ_INDEX_ComBlk]++;
@@ -626,8 +629,8 @@ void __irq USB_IRQHandler()
 		IsrVector->Handler.Execute();
 
 
-		SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); // nestable
-		SystemState_ClearNoLock( SYSTEM_STATE_ISR              ); // nestable
+		INTERRUPT_END;
+
 	}
 
 
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/sys_services/SysServices.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/sys_services/SysServices.h
index 8e10fddef..03ff17b87 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/sys_services/SysServices.h
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/drivers/sys_services/SysServices.h
@@ -12,7 +12,7 @@
 #include <drivers/mss_sys_services/mss_comblk.h>
 
 void MSS_COMBLK_init (comblk_async_event_handler_t async_event_handler,uint8_t* p_response);
-static void asynchronous_event_handler(uint8_t event_opcode);
+void asynchronous_event_handler(uint8_t event_opcode);
 
 struct SF2_Services {
 
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/CMSIS/mss_assert.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/CMSIS/mss_assert.h
index edec5c160..1068699e3 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/CMSIS/mss_assert.h
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/CMSIS/mss_assert.h
@@ -26,6 +26,7 @@
 /*
  * SoftConsole assertion handling
  */
+#ifndef ASSERT
 #define ASSERT(CHECK)  \
     do { \
         if (!(CHECK)) \
@@ -33,7 +34,7 @@
             __asm volatile ("BKPT\n\t"); \
         } \
     } while (0);
-    
+#endif
 #elif defined ( __ICCARM__ )
 /*
  * IAR Embedded Workbench assertion handling.
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/dotNetMF.proj b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/dotNetMF.proj
index 33eb9d157..9363c92f3 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/dotNetMF.proj
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/dotNetMF.proj
@@ -62,9 +62,10 @@
 	<HFiles Include="drivers_config/sys_config/sysconfig_mss_clocks.h" />
 	<HFiles Include="drivers_config/sys_config/sys_config.h" />
 	<HFiles Include="hal/hw_reg_access.h" />
-	<!--<HFiles Include="hal/hal.h" />
+	<HFiles Include="hal/hal.h" />
 	<HFiles Include="hal/hal_assert.h" />
 	
+	<!--
 	<HFiles Include="hal/CortexM3/.h" />
 	<HFiles Include="hal/CortexM3/.h" />
 	-->
@@ -80,6 +81,7 @@
     <Compile Include="drivers_config/sys_config/sys_config.c" />  
 	<Compile Include="drivers_config/sys_config/sys_config.c" />  
 	<Compile Include="hal\CortexM3\GNU\hw_reg_access.S" />
+	<Compile Include="hal\CortexM3\GNU\hal.S" />
     
   </ItemGroup>
   <ItemGroup />
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/CortexM3/GNU/hal.S b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/CortexM3/GNU/hal.S
index 40c01b896..f61c4de8e 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/CortexM3/GNU/hal.S
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/CortexM3/GNU/hal.S
@@ -6,16 +6,24 @@
 # SVN $Revision: 6667 $
 # SVN $Date: 2014-07-04 11:48:08 +0100 (Fri, 04 Jul 2014) $
 #
-    .text
-    .global HAL_disable_interrupts
-    .global HAL_restore_interrupts
-    .code 16
-    .syntax unified
-    .type HAL_disable_interrupts, function
-    .type HAL_restore_interrupts, function
+.section .text
+.globl HAL_get_interrupts
+.globl HAL_disable_interrupts
+.globl HAL_restore_interrupts
+#.code 16
+#.syntax unified
+.type HAL_get_interrupts, function
+.type HAL_disable_interrupts, function
+.type HAL_restore_interrupts, function
 #-------------------------------------------------------------------------------
 # 
 #
+HAL_get_interrupts:
+    mrs r0, PRIMASK
+
+#-------------------------------------------------------------------------------
+#
+#
 HAL_disable_interrupts:    
     mrs r0, PRIMASK
     cpsid I
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/hal.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/hal.h
index 6b94de285..784d6b279 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/hal.h
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/microsemi_lib/hal/hal.h
@@ -15,21 +15,26 @@
 /***************************************************************************//**
  * Enable all interrupts at the processor level.
  */
-void HAL_enable_interrupts( void );
+static void HAL_enable_interrupts( void );
+
+
+//Added by Samraksh/Mukundan, just returns status without disabling
+static psr_t HAL_get_interrupts( void );
+
 
 /***************************************************************************//**
  * Disable all interrupts at the processor core level.
  * Return the interrupts enable state before disabling occured so that it can 
  * later be restored. 
  */
-psr_t HAL_disable_interrupts( void );
+static psr_t HAL_disable_interrupts( void );
 
 /***************************************************************************//**
  * Restore the interrupts enable state at the processor core level.
  * This function is normally passed the value returned from a previous call to
  * HAL_disable_interrupts(). 
  */
-void HAL_restore_interrupts( psr_t saved_psr );
+static void HAL_restore_interrupts( psr_t saved_psr );
 
 /***************************************************************************//**
  */
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/dotNetMF.proj b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/dotNetMF.proj
deleted file mode 100644
index 47724b925..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/dotNetMF.proj
+++ /dev/null
@@ -1,93 +0,0 @@
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <AssemblyName>SmartFusion2</AssemblyName>
-    <ProjectGuid>{36101ca5-349a-4471-aeb0-3babba567477}</ProjectGuid>
-    <Size>
-    </Size>
-    <Description>SmartFusion2 Library</Description>
-    <Level>HAL</Level>
-    <LibraryFile>SmartFusion2.$(LIB_EXT)</LibraryFile>
-    <ProjectPath>$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\stmlib\dotNetMF.proj</ProjectPath>
-    <ManifestFile>SmartFusion2.$(LIB_EXT).manifest</ManifestFile>
-    <Groups>Processor\STM32F10x</Groups>
-    <LibraryCategory>
-      <MFComponent xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Name="pwr_HAL" Guid="{15AB3FEB-4D7A-40AD-B1A0-4BF663A6EF93}" ProjectPath="" Conditional="" xmlns="">
-        <VersionDependency xmlns="http://schemas.microsoft.com/netmf/InventoryFormat.xsd">
-          <Major>4</Major>
-          <Minor>0</Minor>
-          <Revision>0</Revision>
-          <Build>0</Build>
-          <Extra />
-          <Date>2010-07-01</Date>
-        </VersionDependency>
-        <ComponentType xmlns="http://schemas.microsoft.com/netmf/InventoryFormat.xsd">LibraryCategory</ComponentType>
-      </MFComponent>
-    </LibraryCategory>
-    <Documentation>
-    </Documentation>
-    <PlatformIndependent>False</PlatformIndependent>
-    <CustomFilter>
-    </CustomFilter>
-    <Required>False</Required>
-    <IgnoreDefaultLibPath>False</IgnoreDefaultLibPath>
-    <IsStub>False</IsStub>
-    <Directory>DeviceCode\Targets\Native\SmartFusion2\DeviceCode\stmlib</Directory>
-    <OutputType>Library</OutputType>
-    <PlatformIndependentBuild>false</PlatformIndependentBuild>
-    <Version>4.0.0.0</Version>
-  </PropertyGroup>
-  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Settings" />
-  <PropertyGroup />
-  <ItemGroup>
-    <HFiles Include="stm32f10x.h" />
-	<HFiles Include="stm32f10x_adc.h" />
-	<HFiles Include="stm32f10x_bkp.h" />
-	<HFiles Include="stm32f10x_can.h" />
-	<HFiles Include="stm32f10x_cec.h" />
-	<HFiles Include="stm32f10x_crc.h" />
-	<HFiles Include="stm32f10x_dac.h" />
-	<HFiles Include="stm32f10x_dbgmcu.h" />
-	<HFiles Include="stm32f10x_dma.h" />
-	<HFiles Include="stm32f10x_exti.h" />
-	<HFiles Include="stm32f10x_flash.h" />
-	<HFiles Include="stm32f10x_fsmc.h" />
-	<HFiles Include="stm32f10x_gpio.h" />
-	<HFiles Include="stm32f10x_i2c.h" />
-	<HFiles Include="stm32f10x_iwdg.h" />
-	<HFiles Include="stm32f10x_pwr.h" />
-	<HFiles Include="stm32f10x_rcc.h" />
-	<HFiles Include="stm32f10x_rtc.h" />
-	<HFiles Include="stm32f10x_sdio.h" />
-	<HFiles Include="stm32f10x_spi.h" />
-	<HFiles Include="stm32f10x_tim.h" />
-	<HFiles Include="stm32f10x_usart.h" />
-	<HFiles Include="stm32f10x_wwdg.h" />
-	<HFiles Include="core_cm3.h" />
-    <Compile Include="misc.c" />
-    <Compile Include="stm32f10x_adc.c" />
-    <Compile Include="stm32f10x_bkp.c" />
-    <Compile Include="stm32f10x_can.c" />
-	<Compile Include="stm32f10x_cec.c" />
-	<Compile Include="stm32f10x_crc.c" />
-	<Compile Include="stm32f10x_dac.c" />
-	<Compile Include="stm32f10x_dbgmcu.c" />
-	<Compile Include="stm32f10x_dma.c" />
-	<Compile Include="stm32f10x_exti.c" />
-	<Compile Include="stm32f10x_flash.c" />
-	<Compile Include="stm32f10x_fsmc.c" />
-	<Compile Include="stm32f10x_gpio.c" />
-	<Compile Include="stm32f10x_i2c.c" />
-	<Compile Include="stm32f10x_iwdg.c" />
-	<Compile Include="stm32f10x_pwr.c" />
-	<Compile Include="stm32f10x_rcc.c" />
-	<Compile Include="stm32f10x_rtc.c" />
-	<Compile Include="stm32f10x_sdio.c" />
-	<Compile Include="stm32f10x_spi.c" />
-	<Compile Include="stm32f10x_tim.c" />
-	<Compile Include="stm32f10x_usart.c" />
-	<Compile Include="stm32f10x_wwdg.c" />
-	<Compile Include="core_cm3.c" />
-  </ItemGroup>
-  <ItemGroup />
-  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Targets" />
-</Project>
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x.h
deleted file mode 100644
index cca2823ad..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x.h
+++ /dev/null
@@ -1,8330 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File. 
-  *          This file contains all the peripheral register's definitions, bits 
-  *          definitions and memory mapping for STM32F10x Connectivity line, 
-  *          High density, High density value line, Medium density, 
-  *          Medium density Value line, Low density, Low density Value line 
-  *          and XL-density devices.
-  *
-  *          The file is the unique include file that the application programmer
-  *          is using in the C source code, usually in main.c. This file contains:
-  *           - Configuration section that allows to select:
-  *              - The device used in the target application
-  *              - To use or not the peripherals drivers in application code(i.e. 
-  *                code will be based on direct access to peripherals registers 
-  *                rather than drivers API), this option is controlled by 
-  *                "#define USE_STDPERIPH_DRIVER"
-  *              - To change few application-specific parameters such as the HSE 
-  *                crystal frequency
-  *           - Data structures and the address mapping for all peripherals
-  *           - Peripheral's registers declarations and bits definition
-  *           - Macros to access peripherals registers hardware
-  *
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/** @addtogroup CMSIS
-  * @{
-  */
-
-/** @addtogroup stm32f10x
-  * @{
-  */
-
-#ifndef __STM32F10x_H
-#define __STM32F10x_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif 
-  
-/** @addtogroup Library_configuration_section
-  * @{
-  */
-  
-/* Uncomment the line below according to the target STM32 device used in your
-   application 
-  */
-
-#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL) 
-  /* #define STM32F10X_LD */     /*!< STM32F10X_LD: STM32 Low density devices */
-  /* #define STM32F10X_LD_VL */  /*!< STM32F10X_LD_VL: STM32 Low density Value Line devices */  
-  /* #define STM32F10X_MD */     /*!< STM32F10X_MD: STM32 Medium density devices */
-  /* #define STM32F10X_MD_VL */  /*!< STM32F10X_MD_VL: STM32 Medium density Value Line devices */  
-  /* #define STM32F10X_HD */     /*!< STM32F10X_HD: STM32 High density devices */
-  /* #define STM32F10X_HD_VL */  /*!< STM32F10X_HD_VL: STM32 High density value line devices */  
-  #define STM32F10X_XL
-  /* #define STM32F10X_CL */     /*!< STM32F10X_CL: STM32 Connectivity line devices */
-#endif
-/*  Tip: To avoid modifying this file each time you need to switch between these
-        devices, you can define the device in your toolchain compiler preprocessor.
-
- - Low-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
-   where the Flash memory density ranges between 16 and 32 Kbytes.
- - Low-density value line devices are STM32F100xx microcontrollers where the Flash
-   memory density ranges between 16 and 32 Kbytes.
- - Medium-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers
-   where the Flash memory density ranges between 64 and 128 Kbytes.
- - Medium-density value line devices are STM32F100xx microcontrollers where the 
-   Flash memory density ranges between 64 and 128 Kbytes.   
- - High-density devices are STM32F101xx and STM32F103xx microcontrollers where
-   the Flash memory density ranges between 256 and 512 Kbytes.
- - High-density value line devices are STM32F100xx microcontrollers where the 
-   Flash memory density ranges between 256 and 512 Kbytes.   
- - XL-density devices are STM32F101xx and STM32F103xx microcontrollers where
-   the Flash memory density ranges between 512 and 1024 Kbytes.
- - Connectivity line devices are STM32F105xx and STM32F107xx microcontrollers.
-  */
-
-#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)
- #error "Please select first the target STM32F10x device used in your application (in stm32f10x.h file)"
-#endif
-
-#if !defined  USE_STDPERIPH_DRIVER
-/**
- * @brief Comment the line below if you will not use the peripherals drivers.
-   In this case, these drivers will not be included and the application code will 
-   be based on direct access to peripherals registers 
-   */
-  #define USE_STDPERIPH_DRIVER
-#endif
-
-/**
- * @brief In the following line adjust the value of External High Speed oscillator (HSE)
-   used in your application 
-   
-   Tip: To avoid modifying this file each time you need to use different HSE, you
-        can define the HSE value in your toolchain compiler preprocessor.
-  */
-
-#define HSE_VALUE 8000000
-
-/**
- * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
-   Timeout value 
-   */
-#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */
-
-#define HSI_VALUE    ((uint32_t)8000000) /*!< Value of the Internal oscillator in Hz*/
-
-/**
- * @brief STM32F10x Standard Peripheral Library version number
-   */
-#define __STM32F10X_STDPERIPH_VERSION_MAIN   (0x03) /*!< [31:24] main version */                                  
-#define __STM32F10X_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
-#define __STM32F10X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
-#define __STM32F10X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
-#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)\
-                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)\
-                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)\
-                                             |(__STM32F10X_STDPERIPH_VERSION_RC))
-
-/**
-  * @}
-  */
-
-/** @addtogroup Configuration_section_for_CMSIS
-  * @{
-  */
-
-/**
- * @brief Configuration of the Cortex-M3 Processor and Core Peripherals 
- */
-#ifdef STM32F10X_XL
- #define __MPU_PRESENT             1 /*!< STM32 XL-density devices provide an MPU */
-#else
- #define __MPU_PRESENT             0 /*!< Other STM32 devices does not provide an MPU */
-#endif /* STM32F10X_XL */
-#define __NVIC_PRIO_BITS          4 /*!< STM32 uses 4 Bits for the Priority Levels    */
-#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used */
-
-/**
- * @brief STM32F10x Interrupt Number Definition, according to the selected device 
- *        in @ref Library_configuration_section 
- */
-typedef enum IRQn
-{
-/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
-  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
-  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt              */
-  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                      */
-  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                    */
-  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                       */
-  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                 */
-  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                       */
-  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                   */
-
-/******  STM32 specific Interrupt Numbers *********************************************************/
-  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                            */
-  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt            */
-  TAMPER_IRQn                 = 2,      /*!< Tamper Interrupt                                     */
-  RTC_IRQn                    = 3,      /*!< RTC global Interrupt                                 */
-  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                               */
-  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                 */
-  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                 */
-  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                 */
-  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                 */
-  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                 */
-  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                 */
-  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                      */
-  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                      */
-  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                      */
-  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                      */
-  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                      */
-  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                      */
-  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                      */
-
-#ifdef STM32F10X_LD
-  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
-  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
-  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
-  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
-  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
-  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
-  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */    
-#endif /* STM32F10X_LD */  
-
-#ifdef STM32F10X_LD_VL
-  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
-  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
-  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
-  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
-  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */       
-#endif /* STM32F10X_LD_VL */
-
-#ifdef STM32F10X_MD
-  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
-  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
-  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
-  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
-  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
-  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
-  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
-  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */  
-#endif /* STM32F10X_MD */  
-
-#ifdef STM32F10X_MD_VL
-  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
-  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
-  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
-  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
-  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
-  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */       
-#endif /* STM32F10X_MD_VL */
-
-#ifdef STM32F10X_HD
-  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
-  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
-  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
-  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
-  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
-  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
-  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
-  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
-  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                 */
-  TIM8_UP_IRQn                = 44,     /*!< TIM8 Update Interrupt                                */
-  TIM8_TRG_COM_IRQn           = 45,     /*!< TIM8 Trigger and Commutation Interrupt               */
-  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
-  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
-  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
-  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
-  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
-  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
-  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
-  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
-  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
-  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
-  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
-  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
-  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
-  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
-#endif /* STM32F10X_HD */  
-
-#ifdef STM32F10X_HD_VL
-  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */
-  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */
-  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
-  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */
-  TIM12_IRQn                  = 43,     /*!< TIM12 global Interrupt                               */
-  TIM13_IRQn                  = 44,     /*!< TIM13 global Interrupt                               */
-  TIM14_IRQn                  = 45,     /*!< TIM14 global Interrupt                               */
-  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
-  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
-  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
-  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */  
-  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */
-  TIM7_IRQn                   = 55,     /*!< TIM7 Interrupt                                       */  
-  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
-  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
-  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
-  DMA2_Channel4_5_IRQn        = 59,     /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
-  DMA2_Channel5_IRQn          = 60      /*!< DMA2 Channel 5 global Interrupt (DMA2 Channel 5 is 
-                                             mapped at position 60 only if the MISC_REMAP bit in 
-                                             the AFIO_MAPR2 register is set)                      */       
-#endif /* STM32F10X_HD_VL */
-
-#ifdef STM32F10X_XL
-  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
-  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
-  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
-  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
-  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break Interrupt and TIM9 global Interrupt       */
-  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global Interrupt     */
-  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
-  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
-  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global Interrupt      */
-  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global Interrupt     */
-  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
-  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */
-  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */
-  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */
-  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */
-  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
-  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
-  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
-  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
-  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
-  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
-  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
-  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
-  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
-  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */
-#endif /* STM32F10X_XL */  
-
-#ifdef STM32F10X_CL
-  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */
-  CAN1_TX_IRQn                = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */
-  CAN1_RX0_IRQn               = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
-  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */
-  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */
-  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */
-  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */
-  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */
-  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */
-  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */
-  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */
-  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */
-  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */
-  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */
-  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */
-  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */
-  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */
-  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */
-  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */
-  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */
-  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */
-  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */
-  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */
-  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */
-  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS WakeUp from suspend through EXTI Line Interrupt */
-  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */
-  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */
-  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */
-  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */
-  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */
-  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */
-  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */
-  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */
-  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */
-  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                      */
-  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                      */
-  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                            */
-  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt          */
-  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                    */
-  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                   */
-  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                   */
-  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                   */
-  OTG_FS_IRQn                 = 67      /*!< USB OTG FS global Interrupt                          */
-#endif /* STM32F10X_CL */     
-} IRQn_Type;
-
-/**
-  * @}
-  */
-
-#include "core_cm3.h"
-//#include "system_stm32f10x.h"
-#include <stdint.h>
-
-/** @addtogroup Exported_types
-  * @{
-  */  
-
-/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
-typedef int32_t  s32;
-typedef int16_t s16;
-typedef int8_t  s8;
-
-typedef const int32_t sc32;  /*!< Read Only */
-typedef const int16_t sc16;  /*!< Read Only */
-typedef const int8_t sc8;   /*!< Read Only */
-
-typedef __IO int32_t  vs32;
-typedef __IO int16_t  vs16;
-typedef __IO int8_t   vs8;
-
-typedef __I int32_t vsc32;  /*!< Read Only */
-typedef __I int16_t vsc16;  /*!< Read Only */
-typedef __I int8_t vsc8;   /*!< Read Only */
-
-typedef uint32_t  u32;
-typedef uint16_t u16;
-typedef uint8_t  u8;
-
-typedef const uint32_t uc32;  /*!< Read Only */
-typedef const uint16_t uc16;  /*!< Read Only */
-typedef const uint8_t uc8;   /*!< Read Only */
-
-typedef __IO uint32_t  vu32;
-typedef __IO uint16_t vu16;
-typedef __IO uint8_t  vu8;
-
-typedef __I uint32_t vuc32;  /*!< Read Only */
-typedef __I uint16_t vuc16;  /*!< Read Only */
-typedef __I uint8_t vuc8;   /*!< Read Only */
-
-typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
-
-typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
-#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
-
-typedef enum {ERROR_STATUS = 0, SUCCESS_STATUS = !ERROR_STATUS} ErrorStatus;
-
-/*!< STM32F10x Standard Peripheral Library old definitions (maintained for legacy purpose) */
-#define HSEStartUp_TimeOut   HSE_STARTUP_TIMEOUT
-#define HSE_Value            HSE_VALUE
-#define HSI_Value            HSI_VALUE
-/**
-  * @}
-  */
-
-/** @addtogroup Peripheral_registers_structures
-  * @{
-  */   
-
-/** 
-  * @brief Analog to Digital Converter  
-  */
-
-typedef struct
-{
-  __IO uint32_t SR;
-  __IO uint32_t CR1;
-  __IO uint32_t CR2;
-  __IO uint32_t SMPR1;
-  __IO uint32_t SMPR2;
-  __IO uint32_t JOFR1;
-  __IO uint32_t JOFR2;
-  __IO uint32_t JOFR3;
-  __IO uint32_t JOFR4;
-  __IO uint32_t HTR;
-  __IO uint32_t LTR;
-  __IO uint32_t SQR1;
-  __IO uint32_t SQR2;
-  __IO uint32_t SQR3;
-  __IO uint32_t JSQR;
-  __IO uint32_t JDR1;
-  __IO uint32_t JDR2;
-  __IO uint32_t JDR3;
-  __IO uint32_t JDR4;
-  __IO uint32_t DR;
-} ADC_TypeDef;
-
-/** 
-  * @brief Backup Registers  
-  */
-
-typedef struct
-{
-  uint32_t  RESERVED0;
-  __IO uint16_t DR1;
-  uint16_t  RESERVED1;
-  __IO uint16_t DR2;
-  uint16_t  RESERVED2;
-  __IO uint16_t DR3;
-  uint16_t  RESERVED3;
-  __IO uint16_t DR4;
-  uint16_t  RESERVED4;
-  __IO uint16_t DR5;
-  uint16_t  RESERVED5;
-  __IO uint16_t DR6;
-  uint16_t  RESERVED6;
-  __IO uint16_t DR7;
-  uint16_t  RESERVED7;
-  __IO uint16_t DR8;
-  uint16_t  RESERVED8;
-  __IO uint16_t DR9;
-  uint16_t  RESERVED9;
-  __IO uint16_t DR10;
-  uint16_t  RESERVED10; 
-  __IO uint16_t RTCCR;
-  uint16_t  RESERVED11;
-  __IO uint16_t CR;
-  uint16_t  RESERVED12;
-  __IO uint16_t CSR;
-  uint16_t  RESERVED13[5];
-  __IO uint16_t DR11;
-  uint16_t  RESERVED14;
-  __IO uint16_t DR12;
-  uint16_t  RESERVED15;
-  __IO uint16_t DR13;
-  uint16_t  RESERVED16;
-  __IO uint16_t DR14;
-  uint16_t  RESERVED17;
-  __IO uint16_t DR15;
-  uint16_t  RESERVED18;
-  __IO uint16_t DR16;
-  uint16_t  RESERVED19;
-  __IO uint16_t DR17;
-  uint16_t  RESERVED20;
-  __IO uint16_t DR18;
-  uint16_t  RESERVED21;
-  __IO uint16_t DR19;
-  uint16_t  RESERVED22;
-  __IO uint16_t DR20;
-  uint16_t  RESERVED23;
-  __IO uint16_t DR21;
-  uint16_t  RESERVED24;
-  __IO uint16_t DR22;
-  uint16_t  RESERVED25;
-  __IO uint16_t DR23;
-  uint16_t  RESERVED26;
-  __IO uint16_t DR24;
-  uint16_t  RESERVED27;
-  __IO uint16_t DR25;
-  uint16_t  RESERVED28;
-  __IO uint16_t DR26;
-  uint16_t  RESERVED29;
-  __IO uint16_t DR27;
-  uint16_t  RESERVED30;
-  __IO uint16_t DR28;
-  uint16_t  RESERVED31;
-  __IO uint16_t DR29;
-  uint16_t  RESERVED32;
-  __IO uint16_t DR30;
-  uint16_t  RESERVED33; 
-  __IO uint16_t DR31;
-  uint16_t  RESERVED34;
-  __IO uint16_t DR32;
-  uint16_t  RESERVED35;
-  __IO uint16_t DR33;
-  uint16_t  RESERVED36;
-  __IO uint16_t DR34;
-  uint16_t  RESERVED37;
-  __IO uint16_t DR35;
-  uint16_t  RESERVED38;
-  __IO uint16_t DR36;
-  uint16_t  RESERVED39;
-  __IO uint16_t DR37;
-  uint16_t  RESERVED40;
-  __IO uint16_t DR38;
-  uint16_t  RESERVED41;
-  __IO uint16_t DR39;
-  uint16_t  RESERVED42;
-  __IO uint16_t DR40;
-  uint16_t  RESERVED43;
-  __IO uint16_t DR41;
-  uint16_t  RESERVED44;
-  __IO uint16_t DR42;
-  uint16_t  RESERVED45;    
-} BKP_TypeDef;
-  
-/** 
-  * @brief Controller Area Network TxMailBox 
-  */
-
-typedef struct
-{
-  __IO uint32_t TIR;
-  __IO uint32_t TDTR;
-  __IO uint32_t TDLR;
-  __IO uint32_t TDHR;
-} CAN_TxMailBox_TypeDef;
-
-/** 
-  * @brief Controller Area Network FIFOMailBox 
-  */
-  
-typedef struct
-{
-  __IO uint32_t RIR;
-  __IO uint32_t RDTR;
-  __IO uint32_t RDLR;
-  __IO uint32_t RDHR;
-} CAN_FIFOMailBox_TypeDef;
-
-/** 
-  * @brief Controller Area Network FilterRegister 
-  */
-  
-typedef struct
-{
-  __IO uint32_t FR1;
-  __IO uint32_t FR2;
-} CAN_FilterRegister_TypeDef;
-
-/** 
-  * @brief Controller Area Network 
-  */
-  
-typedef struct
-{
-  __IO uint32_t MCR;
-  __IO uint32_t MSR;
-  __IO uint32_t TSR;
-  __IO uint32_t RF0R;
-  __IO uint32_t RF1R;
-  __IO uint32_t IER;
-  __IO uint32_t ESR;
-  __IO uint32_t BTR;
-  uint32_t  RESERVED0[88];
-  CAN_TxMailBox_TypeDef sTxMailBox[3];
-  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
-  uint32_t  RESERVED1[12];
-  __IO uint32_t FMR;
-  __IO uint32_t FM1R;
-  uint32_t  RESERVED2;
-  __IO uint32_t FS1R;
-  uint32_t  RESERVED3;
-  __IO uint32_t FFA1R;
-  uint32_t  RESERVED4;
-  __IO uint32_t FA1R;
-  uint32_t  RESERVED5[8];
-#ifndef STM32F10X_CL
-  CAN_FilterRegister_TypeDef sFilterRegister[14];
-#else
-  CAN_FilterRegister_TypeDef sFilterRegister[28];
-#endif /* STM32F10X_CL */  
-} CAN_TypeDef;
-
-/** 
-  * @brief Consumer Electronics Control (CEC)
-  */
-typedef struct
-{
-  __IO uint32_t CFGR;
-  __IO uint32_t OAR;
-  __IO uint32_t PRES;
-  __IO uint32_t ESR;
-  __IO uint32_t CSR;
-  __IO uint32_t TXD;
-  __IO uint32_t RXD;  
-} CEC_TypeDef;
-
-/** 
-  * @brief CRC calculation unit 
-  */
-
-typedef struct
-{
-  __IO uint32_t DR;
-  __IO uint8_t  IDR;
-  uint8_t   RESERVED0;
-  uint16_t  RESERVED1;
-  __IO uint32_t CR;
-} CRC_TypeDef;
-
-/** 
-  * @brief Digital to Analog Converter
-  */
-
-typedef struct
-{
-  __IO uint32_t CR;
-  __IO uint32_t SWTRIGR;
-  __IO uint32_t DHR12R1;
-  __IO uint32_t DHR12L1;
-  __IO uint32_t DHR8R1;
-  __IO uint32_t DHR12R2;
-  __IO uint32_t DHR12L2;
-  __IO uint32_t DHR8R2;
-  __IO uint32_t DHR12RD;
-  __IO uint32_t DHR12LD;
-  __IO uint32_t DHR8RD;
-  __IO uint32_t DOR1;
-  __IO uint32_t DOR2;
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-  __IO uint32_t SR;
-#endif
-} DAC_TypeDef;
-
-/** 
-  * @brief Debug MCU
-  */
-
-typedef struct
-{
-  __IO uint32_t IDCODE;
-  __IO uint32_t CR;	
-}DBGMCU_TypeDef;
-
-/** 
-  * @brief DMA Controller
-  */
-
-typedef struct
-{
-  __IO uint32_t CCR;
-  __IO uint32_t CNDTR;
-  __IO uint32_t CPAR;
-  __IO uint32_t CMAR;
-} DMA_Channel_TypeDef;
-
-typedef struct
-{
-  __IO uint32_t ISR;
-  __IO uint32_t IFCR;
-} DMA_TypeDef;
-
-/** 
-  * @brief Ethernet MAC
-  */
-
-typedef struct
-{
-  __IO uint32_t MACCR;
-  __IO uint32_t MACFFR;
-  __IO uint32_t MACHTHR;
-  __IO uint32_t MACHTLR;
-  __IO uint32_t MACMIIAR;
-  __IO uint32_t MACMIIDR;
-  __IO uint32_t MACFCR;
-  __IO uint32_t MACVLANTR;             /*    8 */
-       uint32_t RESERVED0[2];
-  __IO uint32_t MACRWUFFR;             /*   11 */
-  __IO uint32_t MACPMTCSR;
-       uint32_t RESERVED1[2];
-  __IO uint32_t MACSR;                 /*   15 */
-  __IO uint32_t MACIMR;
-  __IO uint32_t MACA0HR;
-  __IO uint32_t MACA0LR;
-  __IO uint32_t MACA1HR;
-  __IO uint32_t MACA1LR;
-  __IO uint32_t MACA2HR;
-  __IO uint32_t MACA2LR;
-  __IO uint32_t MACA3HR;
-  __IO uint32_t MACA3LR;               /*   24 */
-       uint32_t RESERVED2[40];
-  __IO uint32_t MMCCR;                 /*   65 */
-  __IO uint32_t MMCRIR;
-  __IO uint32_t MMCTIR;
-  __IO uint32_t MMCRIMR;
-  __IO uint32_t MMCTIMR;               /*   69 */
-       uint32_t RESERVED3[14];
-  __IO uint32_t MMCTGFSCCR;            /*   84 */
-  __IO uint32_t MMCTGFMSCCR;
-       uint32_t RESERVED4[5];
-  __IO uint32_t MMCTGFCR;
-       uint32_t RESERVED5[10];
-  __IO uint32_t MMCRFCECR;
-  __IO uint32_t MMCRFAECR;
-       uint32_t RESERVED6[10];
-  __IO uint32_t MMCRGUFCR;
-       uint32_t RESERVED7[334];
-  __IO uint32_t PTPTSCR;
-  __IO uint32_t PTPSSIR;
-  __IO uint32_t PTPTSHR;
-  __IO uint32_t PTPTSLR;
-  __IO uint32_t PTPTSHUR;
-  __IO uint32_t PTPTSLUR;
-  __IO uint32_t PTPTSAR;
-  __IO uint32_t PTPTTHR;
-  __IO uint32_t PTPTTLR;
-       uint32_t RESERVED8[567];
-  __IO uint32_t DMABMR;
-  __IO uint32_t DMATPDR;
-  __IO uint32_t DMARPDR;
-  __IO uint32_t DMARDLAR;
-  __IO uint32_t DMATDLAR;
-  __IO uint32_t DMASR;
-  __IO uint32_t DMAOMR;
-  __IO uint32_t DMAIER;
-  __IO uint32_t DMAMFBOCR;
-       uint32_t RESERVED9[9];
-  __IO uint32_t DMACHTDR;
-  __IO uint32_t DMACHRDR;
-  __IO uint32_t DMACHTBAR;
-  __IO uint32_t DMACHRBAR;
-} ETH_TypeDef;
-
-/** 
-  * @brief External Interrupt/Event Controller
-  */
-
-typedef struct
-{
-  __IO uint32_t IMR;
-  __IO uint32_t EMR;
-  __IO uint32_t RTSR;
-  __IO uint32_t FTSR;
-  __IO uint32_t SWIER;
-  __IO uint32_t PR;
-} EXTI_TypeDef;
-
-/** 
-  * @brief FLASH Registers
-  */
-
-typedef struct
-{
-  __IO uint32_t ACR;
-  __IO uint32_t KEYR;
-  __IO uint32_t OPTKEYR;
-  __IO uint32_t SR;
-  __IO uint32_t CR;
-  __IO uint32_t AR;
-  __IO uint32_t RESERVED;
-  __IO uint32_t OBR;
-  __IO uint32_t WRPR;
-#ifdef STM32F10X_XL
-  uint32_t RESERVED1[8]; 
-  __IO uint32_t KEYR2;
-  uint32_t RESERVED2;   
-  __IO uint32_t SR2;
-  __IO uint32_t CR2;
-  __IO uint32_t AR2; 
-#endif /* STM32F10X_XL */  
-} FLASH_TypeDef;
-
-/** 
-  * @brief Option Bytes Registers
-  */
-  
-typedef struct
-{
-  __IO uint16_t RDP;
-  __IO uint16_t USER;
-  __IO uint16_t Data0;
-  __IO uint16_t Data1;
-  __IO uint16_t WRP0;
-  __IO uint16_t WRP1;
-  __IO uint16_t WRP2;
-  __IO uint16_t WRP3;
-} OB_TypeDef;
-
-/** 
-  * @brief Flexible Static Memory Controller
-  */
-
-typedef struct
-{
-  __IO uint32_t BTCR[8];   
-} FSMC_Bank1_TypeDef; 
-
-/** 
-  * @brief Flexible Static Memory Controller Bank1E
-  */
-  
-typedef struct
-{
-  __IO uint32_t BWTR[7];
-} FSMC_Bank1E_TypeDef;
-
-/** 
-  * @brief Flexible Static Memory Controller Bank2
-  */
-  
-typedef struct
-{
-  __IO uint32_t PCR2;
-  __IO uint32_t SR2;
-  __IO uint32_t PMEM2;
-  __IO uint32_t PATT2;
-  uint32_t  RESERVED0;   
-  __IO uint32_t ECCR2; 
-} FSMC_Bank2_TypeDef;  
-
-/** 
-  * @brief Flexible Static Memory Controller Bank3
-  */
-  
-typedef struct
-{
-  __IO uint32_t PCR3;
-  __IO uint32_t SR3;
-  __IO uint32_t PMEM3;
-  __IO uint32_t PATT3;
-  uint32_t  RESERVED0;   
-  __IO uint32_t ECCR3; 
-} FSMC_Bank3_TypeDef; 
-
-/** 
-  * @brief Flexible Static Memory Controller Bank4
-  */
-  
-typedef struct
-{
-  __IO uint32_t PCR4;
-  __IO uint32_t SR4;
-  __IO uint32_t PMEM4;
-  __IO uint32_t PATT4;
-  __IO uint32_t PIO4; 
-} FSMC_Bank4_TypeDef; 
-
-/** 
-  * @brief General Purpose I/O
-  */
-
-typedef struct
-{
-  __IO uint32_t CRL;
-  __IO uint32_t CRH;
-  __IO uint32_t IDR;
-  __IO uint32_t ODR;
-  __IO uint32_t BSRR;
-  __IO uint32_t BRR;
-  __IO uint32_t LCKR;
-} GPIO_TypeDef;
-
-/** 
-  * @brief Alternate Function I/O
-  */
-
-typedef struct
-{
-  __IO uint32_t EVCR;
-  __IO uint32_t MAPR;
-  __IO uint32_t EXTICR[4];
-  uint32_t RESERVED0;
-  __IO uint32_t MAPR2;  
-} AFIO_TypeDef;
-/** 
-  * @brief Inter Integrated Circuit Interface
-  */
-
-typedef struct
-{
-  __IO uint16_t CR1;
-  uint16_t  RESERVED0;
-  __IO uint16_t CR2;
-  uint16_t  RESERVED1;
-  __IO uint16_t OAR1;
-  uint16_t  RESERVED2;
-  __IO uint16_t OAR2;
-  uint16_t  RESERVED3;
-  __IO uint16_t DR;
-  uint16_t  RESERVED4;
-  __IO uint16_t SR1;
-  uint16_t  RESERVED5;
-  __IO uint16_t SR2;
-  uint16_t  RESERVED6;
-  __IO uint16_t CCR;
-  uint16_t  RESERVED7;
-  __IO uint16_t TRISE;
-  uint16_t  RESERVED8;
-} I2C_TypeDef;
-
-/** 
-  * @brief Independent WATCHDOG
-  */
-
-typedef struct
-{
-  __IO uint32_t KR;
-  __IO uint32_t PR;
-  __IO uint32_t RLR;
-  __IO uint32_t SR;
-} IWDG_TypeDef;
-
-/** 
-  * @brief Power Control
-  */
-
-typedef struct
-{
-  __IO uint32_t CR;
-  __IO uint32_t CSR;
-} PWR_TypeDef;
-
-/** 
-  * @brief Reset and Clock Control
-  */
-
-typedef struct
-{
-  __IO uint32_t CR;
-  __IO uint32_t CFGR;
-  __IO uint32_t CIR;
-  __IO uint32_t APB2RSTR;
-  __IO uint32_t APB1RSTR;
-  __IO uint32_t AHBENR;
-  __IO uint32_t APB2ENR;
-  __IO uint32_t APB1ENR;
-  __IO uint32_t BDCR;
-  __IO uint32_t CSR;
-
-#ifdef STM32F10X_CL  
-  __IO uint32_t AHBRSTR;
-  __IO uint32_t CFGR2;
-#endif /* STM32F10X_CL */ 
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)   
-  uint32_t RESERVED0;
-  __IO uint32_t CFGR2;
-#endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */ 
-} RCC_TypeDef;
-
-/** 
-  * @brief Real-Time Clock
-  */
-
-typedef struct
-{
-  __IO uint16_t CRH;
-  uint16_t  RESERVED0;
-  __IO uint16_t CRL;
-  uint16_t  RESERVED1;
-  __IO uint16_t PRLH;
-  uint16_t  RESERVED2;
-  __IO uint16_t PRLL;
-  uint16_t  RESERVED3;
-  __IO uint16_t DIVH;
-  uint16_t  RESERVED4;
-  __IO uint16_t DIVL;
-  uint16_t  RESERVED5;
-  __IO uint16_t CNTH;
-  uint16_t  RESERVED6;
-  __IO uint16_t CNTL;
-  uint16_t  RESERVED7;
-  __IO uint16_t ALRH;
-  uint16_t  RESERVED8;
-  __IO uint16_t ALRL;
-  uint16_t  RESERVED9;
-} RTC_TypeDef;
-
-/** 
-  * @brief SD host Interface
-  */
-
-typedef struct
-{
-  __IO uint32_t POWER;
-  __IO uint32_t CLKCR;
-  __IO uint32_t ARG;
-  __IO uint32_t CMD;
-  __I uint32_t RESPCMD;
-  __I uint32_t RESP1;
-  __I uint32_t RESP2;
-  __I uint32_t RESP3;
-  __I uint32_t RESP4;
-  __IO uint32_t DTIMER;
-  __IO uint32_t DLEN;
-  __IO uint32_t DCTRL;
-  __I uint32_t DCOUNT;
-  __I uint32_t STA;
-  __IO uint32_t ICR;
-  __IO uint32_t MASK;
-  uint32_t  RESERVED0[2];
-  __I uint32_t FIFOCNT;
-  uint32_t  RESERVED1[13];
-  __IO uint32_t FIFO;
-} SDIO_TypeDef;
-
-/** 
-  * @brief Serial Peripheral Interface
-  */
-
-typedef struct
-{
-  __IO uint16_t CR1;
-  uint16_t  RESERVED0;
-  __IO uint16_t CR2;
-  uint16_t  RESERVED1;
-  __IO uint16_t SR;
-  uint16_t  RESERVED2;
-  __IO uint16_t DR;
-  uint16_t  RESERVED3;
-  __IO uint16_t CRCPR;
-  uint16_t  RESERVED4;
-  __IO uint16_t RXCRCR;
-  uint16_t  RESERVED5;
-  __IO uint16_t TXCRCR;
-  uint16_t  RESERVED6;
-  __IO uint16_t I2SCFGR;
-  uint16_t  RESERVED7;
-  __IO uint16_t I2SPR;
-  uint16_t  RESERVED8;  
-} SPI_TypeDef;
-
-/** 
-  * @brief TIM
-  */
-
-typedef struct
-{
-  __IO uint16_t CR1;
-  uint16_t  RESERVED0;
-  __IO uint16_t CR2;
-  uint16_t  RESERVED1;
-  __IO uint16_t SMCR;
-  uint16_t  RESERVED2;
-  __IO uint16_t DIER;
-  uint16_t  RESERVED3;
-  __IO uint16_t SR;
-  uint16_t  RESERVED4;
-  __IO uint16_t EGR;
-  uint16_t  RESERVED5;
-  __IO uint16_t CCMR1;
-  uint16_t  RESERVED6;
-  __IO uint16_t CCMR2;
-  uint16_t  RESERVED7;
-  __IO uint16_t CCER;
-  uint16_t  RESERVED8;
-  __IO uint16_t CNT;
-  uint16_t  RESERVED9;
-  __IO uint16_t PSC;
-  uint16_t  RESERVED10;
-  __IO uint16_t ARR;
-  uint16_t  RESERVED11;
-  __IO uint16_t RCR;
-  uint16_t  RESERVED12;
-  __IO uint16_t CCR1;
-  uint16_t  RESERVED13;
-  __IO uint16_t CCR2;
-  uint16_t  RESERVED14;
-  __IO uint16_t CCR3;
-  uint16_t  RESERVED15;
-  __IO uint16_t CCR4;
-  uint16_t  RESERVED16;
-  __IO uint16_t BDTR;
-  uint16_t  RESERVED17;
-  __IO uint16_t DCR;
-  uint16_t  RESERVED18;
-  __IO uint16_t DMAR;
-  uint16_t  RESERVED19;
-} TIM_TypeDef;
-
-/** 
-  * @brief Universal Synchronous Asynchronous Receiver Transmitter
-  */
- 
-typedef struct
-{
-  __IO uint16_t SR;
-  uint16_t  RESERVED0;
-  __IO uint16_t DR;
-  uint16_t  RESERVED1;
-  __IO uint16_t BRR;
-  uint16_t  RESERVED2;
-  __IO uint16_t CR1;
-  uint16_t  RESERVED3;
-  __IO uint16_t CR2;
-  uint16_t  RESERVED4;
-  __IO uint16_t CR3;
-  uint16_t  RESERVED5;
-  __IO uint16_t GTPR;
-  uint16_t  RESERVED6;
-} USART_TypeDef;
-
-/** 
-  * @brief Window WATCHDOG
-  */
-
-typedef struct
-{
-  __IO uint32_t CR;
-  __IO uint32_t CFR;
-  __IO uint32_t SR;
-} WWDG_TypeDef;
-
-/**
-  * @}
-  */
-  
-/** @addtogroup Peripheral_memory_map
-  * @{
-  */
-
-
-#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
-#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
-#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
-
-#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
-#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
-
-#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
-
-/*!< Peripheral memory map */
-#define APB1PERIPH_BASE       PERIPH_BASE
-#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
-#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
-
-#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
-#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
-#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
-#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
-#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
-#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
-#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
-#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
-#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
-#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
-#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
-#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
-#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
-#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
-#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
-#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
-#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
-#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
-#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
-#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
-#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
-#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
-#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
-#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
-#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
-#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)
-
-#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
-#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
-#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
-#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
-#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
-#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
-#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
-#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
-#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
-#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
-#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
-#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
-#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
-#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
-#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
-#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
-#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)
-#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)
-#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)
-#define TIM9_BASE             (APB2PERIPH_BASE + 0x4C00)
-#define TIM10_BASE            (APB2PERIPH_BASE + 0x5000)
-#define TIM11_BASE            (APB2PERIPH_BASE + 0x5400)
-
-#define SDIO_BASE             (PERIPH_BASE + 0x18000)
-
-#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
-#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
-#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
-#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
-#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
-#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
-#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
-#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
-#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
-#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
-#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
-#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
-#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
-#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
-#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
-#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
-
-#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000) /*!< Flash registers base address */
-#define OB_BASE               ((uint32_t)0x1FFFF800)    /*!< Flash Option Bytes base address */
-
-#define ETH_BASE              (AHBPERIPH_BASE + 0x8000)
-#define ETH_MAC_BASE          (ETH_BASE)
-#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
-#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
-#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
-
-#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */
-#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */
-#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060) /*!< FSMC Bank2 registers base address */
-#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080) /*!< FSMC Bank3 registers base address */
-#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0) /*!< FSMC Bank4 registers base address */
-
-#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
-
-/**
-  * @}
-  */
-  
-/** @addtogroup Peripheral_declaration
-  * @{
-  */  
-
-#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
-#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
-#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
-#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
-#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
-#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
-#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
-#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
-#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
-#define RTC                 ((RTC_TypeDef *) RTC_BASE)
-#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
-#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
-#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
-#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
-#define USART2              ((USART_TypeDef *) USART2_BASE)
-#define USART3              ((USART_TypeDef *) USART3_BASE)
-#define UART4               ((USART_TypeDef *) UART4_BASE)
-#define UART5               ((USART_TypeDef *) UART5_BASE)
-#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
-#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
-#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
-#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
-#define BKP                 ((BKP_TypeDef *) BKP_BASE)
-#define PWR                 ((PWR_TypeDef *) PWR_BASE)
-#define DAC                 ((DAC_TypeDef *) DAC_BASE)
-#define CEC                 ((CEC_TypeDef *) CEC_BASE)
-#define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
-#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
-#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
-#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
-#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
-#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
-#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
-#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
-#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
-#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
-#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
-#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
-#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
-#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
-#define USART1              ((USART_TypeDef *) USART1_BASE)
-#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
-#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
-#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
-#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
-#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
-#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
-#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
-#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
-#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
-#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
-#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
-#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
-#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
-#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
-#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
-#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
-#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
-#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
-#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
-#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
-#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
-#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
-#define RCC                 ((RCC_TypeDef *) RCC_BASE)
-#define CRC                 ((CRC_TypeDef *) CRC_BASE)
-#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
-#define OB                  ((OB_TypeDef *) OB_BASE) 
-#define ETH                 ((ETH_TypeDef *) ETH_BASE)
-#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
-#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
-#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
-#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
-#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
-#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
-
-/**
-  * @}
-  */
-
-/** @addtogroup Exported_constants
-  * @{
-  */
-  
-  /** @addtogroup Peripheral_Registers_Bits_Definition
-  * @{
-  */
-    
-/******************************************************************************/
-/*                         Peripheral Registers_Bits_Definition               */
-/******************************************************************************/
-
-/******************************************************************************/
-/*                                                                            */
-/*                          CRC calculation unit                              */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for CRC_DR register  *********************/
-#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
-
-
-/*******************  Bit definition for CRC_IDR register  ********************/
-#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
-
-
-/********************  Bit definition for CRC_CR register  ********************/
-#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
-
-/******************************************************************************/
-/*                                                                            */
-/*                             Power Control                                  */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for PWR_CR register  ********************/
-#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-Power Deepsleep */
-#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
-#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
-#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
-#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
-
-#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
-#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
-#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
-#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
-
-/*!< PVD level configuration */
-#define  PWR_CR_PLS_2V2                      ((uint16_t)0x0000)     /*!< PVD level 2.2V */
-#define  PWR_CR_PLS_2V3                      ((uint16_t)0x0020)     /*!< PVD level 2.3V */
-#define  PWR_CR_PLS_2V4                      ((uint16_t)0x0040)     /*!< PVD level 2.4V */
-#define  PWR_CR_PLS_2V5                      ((uint16_t)0x0060)     /*!< PVD level 2.5V */
-#define  PWR_CR_PLS_2V6                      ((uint16_t)0x0080)     /*!< PVD level 2.6V */
-#define  PWR_CR_PLS_2V7                      ((uint16_t)0x00A0)     /*!< PVD level 2.7V */
-#define  PWR_CR_PLS_2V8                      ((uint16_t)0x00C0)     /*!< PVD level 2.8V */
-#define  PWR_CR_PLS_2V9                      ((uint16_t)0x00E0)     /*!< PVD level 2.9V */
-
-#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
-
-
-/*******************  Bit definition for PWR_CSR register  ********************/
-#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
-#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
-#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
-#define  PWR_CSR_EWUP                        ((uint16_t)0x0100)     /*!< Enable WKUP pin */
-
-/******************************************************************************/
-/*                                                                            */
-/*                            Backup registers                                */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for BKP_DR1 register  ********************/
-#define  BKP_DR1_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR2 register  ********************/
-#define  BKP_DR2_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR3 register  ********************/
-#define  BKP_DR3_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR4 register  ********************/
-#define  BKP_DR4_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR5 register  ********************/
-#define  BKP_DR5_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR6 register  ********************/
-#define  BKP_DR6_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR7 register  ********************/
-#define  BKP_DR7_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR8 register  ********************/
-#define  BKP_DR8_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR9 register  ********************/
-#define  BKP_DR9_D                           ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR10 register  *******************/
-#define  BKP_DR10_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR11 register  *******************/
-#define  BKP_DR11_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR12 register  *******************/
-#define  BKP_DR12_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR13 register  *******************/
-#define  BKP_DR13_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR14 register  *******************/
-#define  BKP_DR14_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR15 register  *******************/
-#define  BKP_DR15_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR16 register  *******************/
-#define  BKP_DR16_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR17 register  *******************/
-#define  BKP_DR17_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/******************  Bit definition for BKP_DR18 register  ********************/
-#define  BKP_DR18_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR19 register  *******************/
-#define  BKP_DR19_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR20 register  *******************/
-#define  BKP_DR20_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR21 register  *******************/
-#define  BKP_DR21_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR22 register  *******************/
-#define  BKP_DR22_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR23 register  *******************/
-#define  BKP_DR23_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR24 register  *******************/
-#define  BKP_DR24_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR25 register  *******************/
-#define  BKP_DR25_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR26 register  *******************/
-#define  BKP_DR26_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR27 register  *******************/
-#define  BKP_DR27_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR28 register  *******************/
-#define  BKP_DR28_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR29 register  *******************/
-#define  BKP_DR29_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR30 register  *******************/
-#define  BKP_DR30_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR31 register  *******************/
-#define  BKP_DR31_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR32 register  *******************/
-#define  BKP_DR32_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR33 register  *******************/
-#define  BKP_DR33_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR34 register  *******************/
-#define  BKP_DR34_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR35 register  *******************/
-#define  BKP_DR35_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR36 register  *******************/
-#define  BKP_DR36_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR37 register  *******************/
-#define  BKP_DR37_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR38 register  *******************/
-#define  BKP_DR38_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR39 register  *******************/
-#define  BKP_DR39_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR40 register  *******************/
-#define  BKP_DR40_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR41 register  *******************/
-#define  BKP_DR41_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/*******************  Bit definition for BKP_DR42 register  *******************/
-#define  BKP_DR42_D                          ((uint16_t)0xFFFF)     /*!< Backup data */
-
-/******************  Bit definition for BKP_RTCCR register  *******************/
-#define  BKP_RTCCR_CAL                       ((uint16_t)0x007F)     /*!< Calibration value */
-#define  BKP_RTCCR_CCO                       ((uint16_t)0x0080)     /*!< Calibration Clock Output */
-#define  BKP_RTCCR_ASOE                      ((uint16_t)0x0100)     /*!< Alarm or Second Output Enable */
-#define  BKP_RTCCR_ASOS                      ((uint16_t)0x0200)     /*!< Alarm or Second Output Selection */
-
-/********************  Bit definition for BKP_CR register  ********************/
-#define  BKP_CR_TPE                          ((uint8_t)0x01)        /*!< TAMPER pin enable */
-#define  BKP_CR_TPAL                         ((uint8_t)0x02)        /*!< TAMPER pin active level */
-
-/*******************  Bit definition for BKP_CSR register  ********************/
-#define  BKP_CSR_CTE                         ((uint16_t)0x0001)     /*!< Clear Tamper event */
-#define  BKP_CSR_CTI                         ((uint16_t)0x0002)     /*!< Clear Tamper Interrupt */
-#define  BKP_CSR_TPIE                        ((uint16_t)0x0004)     /*!< TAMPER Pin interrupt enable */
-#define  BKP_CSR_TEF                         ((uint16_t)0x0100)     /*!< Tamper Event Flag */
-#define  BKP_CSR_TIF                         ((uint16_t)0x0200)     /*!< Tamper Interrupt Flag */
-
-/******************************************************************************/
-/*                                                                            */
-/*                         Reset and Clock Control                            */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for RCC_CR register  ********************/
-#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
-#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
-#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */
-#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */
-#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
-#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
-#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
-#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */
-#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
-#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
-
-#ifdef STM32F10X_CL
- #define  RCC_CR_PLL2ON                       ((uint32_t)0x04000000)        /*!< PLL2 enable */
- #define  RCC_CR_PLL2RDY                      ((uint32_t)0x08000000)        /*!< PLL2 clock ready flag */
- #define  RCC_CR_PLL3ON                       ((uint32_t)0x10000000)        /*!< PLL3 enable */
- #define  RCC_CR_PLL3RDY                      ((uint32_t)0x20000000)        /*!< PLL3 clock ready flag */
-#endif /* STM32F10X_CL */
-
-/*******************  Bit definition for RCC_CFGR register  *******************/
-/*!< SW configuration */
-#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
-#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
-
-#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
-#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
-#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
-
-/*!< SWS configuration */
-#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
-#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
-#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
-#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
-
-/*!< HPRE configuration */
-#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
-#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
-#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
-#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
-#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
-#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
-#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
-#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
-#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
-#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
-
-/*!< PPRE1 configuration */
-#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
-#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
-
-#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
-#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
-#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
-#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
-#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
-
-/*!< PPRE2 configuration */
-#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
-#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
-#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
-#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
-
-#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
-#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
-#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
-#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
-#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
-
-/*!< ADCPPRE configuration */
-#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)        /*!< ADCPRE[1:0] bits (ADC prescaler) */
-#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)        /*!< Bit 0 */
-#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)        /*!< Bit 1 */
-
-#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< PCLK2 divided by 2 */
-#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< PCLK2 divided by 4 */
-#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< PCLK2 divided by 6 */
-#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< PCLK2 divided by 8 */
-
-#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
-
-#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
-
-/*!< PLLMUL configuration */
-#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
-#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
-#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
-#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
-#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
-
-#ifdef STM32F10X_CL
- #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
- #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
-
- #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
- #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
-
- #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock * 4 */
- #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock * 5 */
- #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock * 6 */
- #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock * 7 */
- #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock * 8 */
- #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock * 9 */
- #define  RCC_CFGR_PLLMULL6_5                ((uint32_t)0x00340000)        /*!< PLL input clock * 6.5 */
- 
- #define  RCC_CFGR_OTGFSPRE                  ((uint32_t)0x00400000)        /*!< USB OTG FS prescaler */
- 
-/*!< MCO configuration */
- #define  RCC_CFGR_MCO                       ((uint32_t)0x0F000000)        /*!< MCO[3:0] bits (Microcontroller Clock Output) */
- #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
- #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
- #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
- #define  RCC_CFGR_MCO_3                     ((uint32_t)0x08000000)        /*!< Bit 3 */
-
- #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
- #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
- #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
- #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source */
- #define  RCC_CFGR_MCO_PLLCLK_Div2           ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
- #define  RCC_CFGR_MCO_PLL2CLK               ((uint32_t)0x08000000)        /*!< PLL2 clock selected as MCO source*/
- #define  RCC_CFGR_MCO_PLL3CLK_Div2          ((uint32_t)0x09000000)        /*!< PLL3 clock divided by 2 selected as MCO source*/
- #define  RCC_CFGR_MCO_Ext_HSE               ((uint32_t)0x0A000000)        /*!< XT1 external 3-25 MHz oscillator clock selected as MCO source */
- #define  RCC_CFGR_MCO_PLL3CLK               ((uint32_t)0x0B000000)        /*!< PLL3 clock selected as MCO source */
-#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
- #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
- #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
-
- #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
- #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
-
- #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
- #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
- #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
- #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
- #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
- #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
- #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
- #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
- #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
- #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
- #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
- #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
- #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
- #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
- #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
-
-/*!< MCO configuration */
- #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
- #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
- #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
- #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
-
- #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
- #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
- #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
- #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
- #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
-#else
- #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
- #define  RCC_CFGR_PLLSRC_HSE                ((uint32_t)0x00010000)        /*!< HSE clock selected as PLL entry clock source */
-
- #define  RCC_CFGR_PLLXTPRE_HSE              ((uint32_t)0x00000000)        /*!< HSE clock not divided for PLL entry */
- #define  RCC_CFGR_PLLXTPRE_HSE_Div2         ((uint32_t)0x00020000)        /*!< HSE clock divided by 2 for PLL entry */
-
- #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
- #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
- #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
- #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
- #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
- #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
- #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
- #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
- #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */
- #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
- #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
- #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
- #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
- #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
- #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
- #define  RCC_CFGR_USBPRE                    ((uint32_t)0x00400000)        /*!< USB Device prescaler */
-
-/*!< MCO configuration */
- #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
- #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */
- #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */
- #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */
-
- #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */
- #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
- #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
- #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
- #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
-#endif /* STM32F10X_CL */
-
-/*!<******************  Bit definition for RCC_CIR register  ********************/
-#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
-#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
-#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
-#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
-#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
-#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
-#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
-#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
-#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
-#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
-#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
-#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
-#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
-#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
-#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
-#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
-#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
-
-#ifdef STM32F10X_CL
- #define  RCC_CIR_PLL2RDYF                    ((uint32_t)0x00000020)        /*!< PLL2 Ready Interrupt flag */
- #define  RCC_CIR_PLL3RDYF                    ((uint32_t)0x00000040)        /*!< PLL3 Ready Interrupt flag */
- #define  RCC_CIR_PLL2RDYIE                   ((uint32_t)0x00002000)        /*!< PLL2 Ready Interrupt Enable */
- #define  RCC_CIR_PLL3RDYIE                   ((uint32_t)0x00004000)        /*!< PLL3 Ready Interrupt Enable */
- #define  RCC_CIR_PLL2RDYC                    ((uint32_t)0x00200000)        /*!< PLL2 Ready Interrupt Clear */
- #define  RCC_CIR_PLL3RDYC                    ((uint32_t)0x00400000)        /*!< PLL3 Ready Interrupt Clear */
-#endif /* STM32F10X_CL */
-
-/*****************  Bit definition for RCC_APB2RSTR register  *****************/
-#define  RCC_APB2RSTR_AFIORST                ((uint32_t)0x00000001)        /*!< Alternate Function I/O reset */
-#define  RCC_APB2RSTR_IOPARST                ((uint32_t)0x00000004)        /*!< I/O port A reset */
-#define  RCC_APB2RSTR_IOPBRST                ((uint32_t)0x00000008)        /*!< I/O port B reset */
-#define  RCC_APB2RSTR_IOPCRST                ((uint32_t)0x00000010)        /*!< I/O port C reset */
-#define  RCC_APB2RSTR_IOPDRST                ((uint32_t)0x00000020)        /*!< I/O port D reset */
-#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC 1 interface reset */
-
-#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
-#define  RCC_APB2RSTR_ADC2RST                ((uint32_t)0x00000400)        /*!< ADC 2 interface reset */
-#endif
-
-#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 Timer reset */
-#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI 1 reset */
-#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 Timer reset */
-#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 Timer reset */
-#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 Timer reset */
-#endif
-
-#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
- #define  RCC_APB2RSTR_IOPERST               ((uint32_t)0x00000040)        /*!< I/O port E reset */
-#endif /* STM32F10X_LD && STM32F10X_LD_VL */
-
-#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
- #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
- #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
- #define  RCC_APB2RSTR_TIM8RST               ((uint32_t)0x00002000)        /*!< TIM8 Timer reset */
- #define  RCC_APB2RSTR_ADC3RST               ((uint32_t)0x00008000)        /*!< ADC3 interface reset */
-#endif
-
-#if defined (STM32F10X_HD_VL)
- #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */
- #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */
-#endif
-
-#ifdef STM32F10X_XL
- #define  RCC_APB2RSTR_TIM9RST               ((uint32_t)0x00080000)         /*!< TIM9 Timer reset */
- #define  RCC_APB2RSTR_TIM10RST              ((uint32_t)0x00100000)         /*!< TIM10 Timer reset */
- #define  RCC_APB2RSTR_TIM11RST              ((uint32_t)0x00200000)         /*!< TIM11 Timer reset */
-#endif /* STM32F10X_XL */
-
-/*****************  Bit definition for RCC_APB1RSTR register  *****************/
-#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
-#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
-#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
-#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
-#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
-
-#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
-#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN1 reset */
-#endif
-
-#define  RCC_APB1RSTR_BKPRST                 ((uint32_t)0x08000000)        /*!< Backup interface reset */
-#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */
-
-#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
- #define  RCC_APB1RSTR_TIM4RST               ((uint32_t)0x00000004)        /*!< Timer 4 reset */
- #define  RCC_APB1RSTR_SPI2RST               ((uint32_t)0x00004000)        /*!< SPI 2 reset */
- #define  RCC_APB1RSTR_USART3RST             ((uint32_t)0x00040000)        /*!< USART 3 reset */
- #define  RCC_APB1RSTR_I2C2RST               ((uint32_t)0x00400000)        /*!< I2C 2 reset */
-#endif /* STM32F10X_LD && STM32F10X_LD_VL */
-
-#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined (STM32F10X_LD) || defined  (STM32F10X_XL)
- #define  RCC_APB1RSTR_USBRST                ((uint32_t)0x00800000)        /*!< USB Device reset */
-#endif
-
-#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_XL)
- #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
- #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
- #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
- #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
- #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
- #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
- #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
-#endif
-
-#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
- #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
- #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
- #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
- #define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC interface reset */ 
-#endif
-
-#if defined  (STM32F10X_HD_VL)
- #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
- #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< TIM12 Timer reset */
- #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< TIM13 Timer reset */
- #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< TIM14 Timer reset */
- #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */ 
- #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
- #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */ 
-#endif
-
-#ifdef STM32F10X_CL
- #define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)        /*!< CAN2 reset */
-#endif /* STM32F10X_CL */
-
-#ifdef STM32F10X_XL
- #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)         /*!< TIM12 Timer reset */
- #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)         /*!< TIM13 Timer reset */
- #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)         /*!< TIM14 Timer reset */
-#endif /* STM32F10X_XL */
-
-/******************  Bit definition for RCC_AHBENR register  ******************/
-#define  RCC_AHBENR_DMA1EN                   ((uint16_t)0x0001)            /*!< DMA1 clock enable */
-#define  RCC_AHBENR_SRAMEN                   ((uint16_t)0x0004)            /*!< SRAM interface clock enable */
-#define  RCC_AHBENR_FLITFEN                  ((uint16_t)0x0010)            /*!< FLITF clock enable */
-#define  RCC_AHBENR_CRCEN                    ((uint16_t)0x0040)            /*!< CRC clock enable */
-
-#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_HD_VL)
- #define  RCC_AHBENR_DMA2EN                  ((uint16_t)0x0002)            /*!< DMA2 clock enable */
-#endif
-
-#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
- #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
- #define  RCC_AHBENR_SDIOEN                  ((uint16_t)0x0400)            /*!< SDIO clock enable */
-#endif
-
-#if defined (STM32F10X_HD_VL)
- #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */
-#endif
-
-#ifdef STM32F10X_CL
- #define  RCC_AHBENR_OTGFSEN                 ((uint32_t)0x00001000)         /*!< USB OTG FS clock enable */
- #define  RCC_AHBENR_ETHMACEN                ((uint32_t)0x00004000)         /*!< ETHERNET MAC clock enable */
- #define  RCC_AHBENR_ETHMACTXEN              ((uint32_t)0x00008000)         /*!< ETHERNET MAC Tx clock enable */
- #define  RCC_AHBENR_ETHMACRXEN              ((uint32_t)0x00010000)         /*!< ETHERNET MAC Rx clock enable */
-#endif /* STM32F10X_CL */
-
-/******************  Bit definition for RCC_APB2ENR register  *****************/
-#define  RCC_APB2ENR_AFIOEN                  ((uint32_t)0x00000001)         /*!< Alternate Function I/O clock enable */
-#define  RCC_APB2ENR_IOPAEN                  ((uint32_t)0x00000004)         /*!< I/O port A clock enable */
-#define  RCC_APB2ENR_IOPBEN                  ((uint32_t)0x00000008)         /*!< I/O port B clock enable */
-#define  RCC_APB2ENR_IOPCEN                  ((uint32_t)0x00000010)         /*!< I/O port C clock enable */
-#define  RCC_APB2ENR_IOPDEN                  ((uint32_t)0x00000020)         /*!< I/O port D clock enable */
-#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC 1 interface clock enable */
-
-#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
-#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000400)         /*!< ADC 2 interface clock enable */
-#endif
-
-#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)         /*!< TIM1 Timer clock enable */
-#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI 1 clock enable */
-#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)         /*!< TIM15 Timer clock enable */
-#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)         /*!< TIM16 Timer clock enable */
-#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)         /*!< TIM17 Timer clock enable */
-#endif
-
-#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
- #define  RCC_APB2ENR_IOPEEN                 ((uint32_t)0x00000040)         /*!< I/O port E clock enable */
-#endif /* STM32F10X_LD && STM32F10X_LD_VL */
-
-#if defined (STM32F10X_HD) || defined (STM32F10X_XL)
- #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
- #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
- #define  RCC_APB2ENR_TIM8EN                 ((uint32_t)0x00002000)         /*!< TIM8 Timer clock enable */
- #define  RCC_APB2ENR_ADC3EN                 ((uint32_t)0x00008000)         /*!< DMA1 clock enable */
-#endif
-
-#if defined (STM32F10X_HD_VL)
- #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */
- #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */
-#endif
-
-#ifdef STM32F10X_XL
- #define  RCC_APB2ENR_TIM9EN                 ((uint32_t)0x00080000)         /*!< TIM9 Timer clock enable  */
- #define  RCC_APB2ENR_TIM10EN                ((uint32_t)0x00100000)         /*!< TIM10 Timer clock enable  */
- #define  RCC_APB2ENR_TIM11EN                ((uint32_t)0x00200000)         /*!< TIM11 Timer clock enable */
-#endif
-
-/*****************  Bit definition for RCC_APB1ENR register  ******************/
-#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/
-#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
-#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
-#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
-#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
-
-#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)
-#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN1 clock enable */
-#endif
-
-#define  RCC_APB1ENR_BKPEN                   ((uint32_t)0x08000000)        /*!< Backup interface clock enable */
-#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */
-
-#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
- #define  RCC_APB1ENR_TIM4EN                 ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
- #define  RCC_APB1ENR_SPI2EN                 ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */
- #define  RCC_APB1ENR_USART3EN               ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
- #define  RCC_APB1ENR_I2C2EN                 ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
-#endif /* STM32F10X_LD && STM32F10X_LD_VL */
-
-#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined  (STM32F10X_LD)
- #define  RCC_APB1ENR_USBEN                  ((uint32_t)0x00800000)        /*!< USB Device clock enable */
-#endif
-
-#if defined (STM32F10X_HD) || defined  (STM32F10X_CL)
- #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
- #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
- #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
- #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
- #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
- #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
- #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
-#endif
-
-#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)
- #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
- #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
- #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
- #define  RCC_APB1ENR_CECEN                  ((uint32_t)0x40000000)        /*!< CEC interface clock enable */ 
-#endif
-
-#ifdef STM32F10X_HD_VL
- #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
- #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
- #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
- #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
- #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
- #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
- #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */ 
-#endif /* STM32F10X_HD_VL */
-
-#ifdef STM32F10X_CL
- #define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)        /*!< CAN2 clock enable */
-#endif /* STM32F10X_CL */
-
-#ifdef STM32F10X_XL
- #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */
- #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */
- #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */
-#endif /* STM32F10X_XL */
-
-/*******************  Bit definition for RCC_BDCR register  *******************/
-#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
-#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
-#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
-
-#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
-#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
-
-/*!< RTC congiguration */
-#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
-#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
-#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
-#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 128 used as RTC clock */
-
-#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
-#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
-
-/*******************  Bit definition for RCC_CSR register  ********************/  
-#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
-#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
-#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
-#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
-#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
-#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
-#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
-#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
-#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
-
-#ifdef STM32F10X_CL
-/*******************  Bit definition for RCC_AHBRSTR register  ****************/
- #define  RCC_AHBRSTR_OTGFSRST               ((uint32_t)0x00001000)         /*!< USB OTG FS reset */
- #define  RCC_AHBRSTR_ETHMACRST              ((uint32_t)0x00004000)         /*!< ETHERNET MAC reset */
-
-/*******************  Bit definition for RCC_CFGR2 register  ******************/
-/*!< PREDIV1 configuration */
- #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
- #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
- #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
- #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
- #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-
- #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
- #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
- #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
- #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
- #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
- #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
- #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
- #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
- #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
- #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
- #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
- #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
- #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
- #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
- #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
- #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
-
-/*!< PREDIV2 configuration */
- #define  RCC_CFGR2_PREDIV2                  ((uint32_t)0x000000F0)        /*!< PREDIV2[3:0] bits */
- #define  RCC_CFGR2_PREDIV2_0                ((uint32_t)0x00000010)        /*!< Bit 0 */
- #define  RCC_CFGR2_PREDIV2_1                ((uint32_t)0x00000020)        /*!< Bit 1 */
- #define  RCC_CFGR2_PREDIV2_2                ((uint32_t)0x00000040)        /*!< Bit 2 */
- #define  RCC_CFGR2_PREDIV2_3                ((uint32_t)0x00000080)        /*!< Bit 3 */
-
- #define  RCC_CFGR2_PREDIV2_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV2 input clock not divided */
- #define  RCC_CFGR2_PREDIV2_DIV2             ((uint32_t)0x00000010)        /*!< PREDIV2 input clock divided by 2 */
- #define  RCC_CFGR2_PREDIV2_DIV3             ((uint32_t)0x00000020)        /*!< PREDIV2 input clock divided by 3 */
- #define  RCC_CFGR2_PREDIV2_DIV4             ((uint32_t)0x00000030)        /*!< PREDIV2 input clock divided by 4 */
- #define  RCC_CFGR2_PREDIV2_DIV5             ((uint32_t)0x00000040)        /*!< PREDIV2 input clock divided by 5 */
- #define  RCC_CFGR2_PREDIV2_DIV6             ((uint32_t)0x00000050)        /*!< PREDIV2 input clock divided by 6 */
- #define  RCC_CFGR2_PREDIV2_DIV7             ((uint32_t)0x00000060)        /*!< PREDIV2 input clock divided by 7 */
- #define  RCC_CFGR2_PREDIV2_DIV8             ((uint32_t)0x00000070)        /*!< PREDIV2 input clock divided by 8 */
- #define  RCC_CFGR2_PREDIV2_DIV9             ((uint32_t)0x00000080)        /*!< PREDIV2 input clock divided by 9 */
- #define  RCC_CFGR2_PREDIV2_DIV10            ((uint32_t)0x00000090)        /*!< PREDIV2 input clock divided by 10 */
- #define  RCC_CFGR2_PREDIV2_DIV11            ((uint32_t)0x000000A0)        /*!< PREDIV2 input clock divided by 11 */
- #define  RCC_CFGR2_PREDIV2_DIV12            ((uint32_t)0x000000B0)        /*!< PREDIV2 input clock divided by 12 */
- #define  RCC_CFGR2_PREDIV2_DIV13            ((uint32_t)0x000000C0)        /*!< PREDIV2 input clock divided by 13 */
- #define  RCC_CFGR2_PREDIV2_DIV14            ((uint32_t)0x000000D0)        /*!< PREDIV2 input clock divided by 14 */
- #define  RCC_CFGR2_PREDIV2_DIV15            ((uint32_t)0x000000E0)        /*!< PREDIV2 input clock divided by 15 */
- #define  RCC_CFGR2_PREDIV2_DIV16            ((uint32_t)0x000000F0)        /*!< PREDIV2 input clock divided by 16 */
-
-/*!< PLL2MUL configuration */
- #define  RCC_CFGR2_PLL2MUL                  ((uint32_t)0x00000F00)        /*!< PLL2MUL[3:0] bits */
- #define  RCC_CFGR2_PLL2MUL_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
- #define  RCC_CFGR2_PLL2MUL_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
- #define  RCC_CFGR2_PLL2MUL_2                ((uint32_t)0x00000400)        /*!< Bit 2 */
- #define  RCC_CFGR2_PLL2MUL_3                ((uint32_t)0x00000800)        /*!< Bit 3 */
-
- #define  RCC_CFGR2_PLL2MUL8                 ((uint32_t)0x00000600)        /*!< PLL2 input clock * 8 */
- #define  RCC_CFGR2_PLL2MUL9                 ((uint32_t)0x00000700)        /*!< PLL2 input clock * 9 */
- #define  RCC_CFGR2_PLL2MUL10                ((uint32_t)0x00000800)        /*!< PLL2 input clock * 10 */
- #define  RCC_CFGR2_PLL2MUL11                ((uint32_t)0x00000900)        /*!< PLL2 input clock * 11 */
- #define  RCC_CFGR2_PLL2MUL12                ((uint32_t)0x00000A00)        /*!< PLL2 input clock * 12 */
- #define  RCC_CFGR2_PLL2MUL13                ((uint32_t)0x00000B00)        /*!< PLL2 input clock * 13 */
- #define  RCC_CFGR2_PLL2MUL14                ((uint32_t)0x00000C00)        /*!< PLL2 input clock * 14 */
- #define  RCC_CFGR2_PLL2MUL16                ((uint32_t)0x00000E00)        /*!< PLL2 input clock * 16 */
- #define  RCC_CFGR2_PLL2MUL20                ((uint32_t)0x00000F00)        /*!< PLL2 input clock * 20 */
-
-/*!< PLL3MUL configuration */
- #define  RCC_CFGR2_PLL3MUL                  ((uint32_t)0x0000F000)        /*!< PLL3MUL[3:0] bits */
- #define  RCC_CFGR2_PLL3MUL_0                ((uint32_t)0x00001000)        /*!< Bit 0 */
- #define  RCC_CFGR2_PLL3MUL_1                ((uint32_t)0x00002000)        /*!< Bit 1 */
- #define  RCC_CFGR2_PLL3MUL_2                ((uint32_t)0x00004000)        /*!< Bit 2 */
- #define  RCC_CFGR2_PLL3MUL_3                ((uint32_t)0x00008000)        /*!< Bit 3 */
-
- #define  RCC_CFGR2_PLL3MUL8                 ((uint32_t)0x00006000)        /*!< PLL3 input clock * 8 */
- #define  RCC_CFGR2_PLL3MUL9                 ((uint32_t)0x00007000)        /*!< PLL3 input clock * 9 */
- #define  RCC_CFGR2_PLL3MUL10                ((uint32_t)0x00008000)        /*!< PLL3 input clock * 10 */
- #define  RCC_CFGR2_PLL3MUL11                ((uint32_t)0x00009000)        /*!< PLL3 input clock * 11 */
- #define  RCC_CFGR2_PLL3MUL12                ((uint32_t)0x0000A000)        /*!< PLL3 input clock * 12 */
- #define  RCC_CFGR2_PLL3MUL13                ((uint32_t)0x0000B000)        /*!< PLL3 input clock * 13 */
- #define  RCC_CFGR2_PLL3MUL14                ((uint32_t)0x0000C000)        /*!< PLL3 input clock * 14 */
- #define  RCC_CFGR2_PLL3MUL16                ((uint32_t)0x0000E000)        /*!< PLL3 input clock * 16 */
- #define  RCC_CFGR2_PLL3MUL20                ((uint32_t)0x0000F000)        /*!< PLL3 input clock * 20 */
-
- #define  RCC_CFGR2_PREDIV1SRC               ((uint32_t)0x00010000)        /*!< PREDIV1 entry clock source */
- #define  RCC_CFGR2_PREDIV1SRC_PLL2          ((uint32_t)0x00010000)        /*!< PLL2 selected as PREDIV1 entry clock source */
- #define  RCC_CFGR2_PREDIV1SRC_HSE           ((uint32_t)0x00000000)        /*!< HSE selected as PREDIV1 entry clock source */
- #define  RCC_CFGR2_I2S2SRC                  ((uint32_t)0x00020000)        /*!< I2S2 entry clock source */
- #define  RCC_CFGR2_I2S3SRC                  ((uint32_t)0x00040000)        /*!< I2S3 clock source */
-#endif /* STM32F10X_CL */
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-/*******************  Bit definition for RCC_CFGR2 register  ******************/
-/*!< PREDIV1 configuration */
- #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
- #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
- #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
- #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
- #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-
- #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
- #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
- #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
- #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
- #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
- #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
- #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
- #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
- #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
- #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
- #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
- #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
- #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
- #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
- #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
- #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
-#endif
- 
-/******************************************************************************/
-/*                                                                            */
-/*                General Purpose and Alternate Function I/O                  */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for GPIO_CRL register  *******************/
-#define  GPIO_CRL_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
-
-#define  GPIO_CRL_MODE0                      ((uint32_t)0x00000003)        /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */
-#define  GPIO_CRL_MODE0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE1                      ((uint32_t)0x00000030)        /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */
-#define  GPIO_CRL_MODE1_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE1_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE2                      ((uint32_t)0x00000300)        /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */
-#define  GPIO_CRL_MODE2_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE2_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE3                      ((uint32_t)0x00003000)        /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */
-#define  GPIO_CRL_MODE3_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE3_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE4                      ((uint32_t)0x00030000)        /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */
-#define  GPIO_CRL_MODE4_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE4_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE5                      ((uint32_t)0x00300000)        /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */
-#define  GPIO_CRL_MODE5_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE5_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE6                      ((uint32_t)0x03000000)        /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */
-#define  GPIO_CRL_MODE6_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE6_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_MODE7                      ((uint32_t)0x30000000)        /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */
-#define  GPIO_CRL_MODE7_0                    ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  GPIO_CRL_MODE7_1                    ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
-
-#define  GPIO_CRL_CNF0                       ((uint32_t)0x0000000C)        /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */
-#define  GPIO_CRL_CNF0_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF0_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF1                       ((uint32_t)0x000000C0)        /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */
-#define  GPIO_CRL_CNF1_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF1_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF2                       ((uint32_t)0x00000C00)        /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */
-#define  GPIO_CRL_CNF2_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF2_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF3                       ((uint32_t)0x0000C000)        /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */
-#define  GPIO_CRL_CNF3_0                     ((uint32_t)0x00004000)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF3_1                     ((uint32_t)0x00008000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF4                       ((uint32_t)0x000C0000)        /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */
-#define  GPIO_CRL_CNF4_0                     ((uint32_t)0x00040000)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF4_1                     ((uint32_t)0x00080000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF5                       ((uint32_t)0x00C00000)        /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */
-#define  GPIO_CRL_CNF5_0                     ((uint32_t)0x00400000)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF5_1                     ((uint32_t)0x00800000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF6                       ((uint32_t)0x0C000000)        /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */
-#define  GPIO_CRL_CNF6_0                     ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF6_1                     ((uint32_t)0x08000000)        /*!< Bit 1 */
-
-#define  GPIO_CRL_CNF7                       ((uint32_t)0xC0000000)        /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */
-#define  GPIO_CRL_CNF7_0                     ((uint32_t)0x40000000)        /*!< Bit 0 */
-#define  GPIO_CRL_CNF7_1                     ((uint32_t)0x80000000)        /*!< Bit 1 */
-
-/*******************  Bit definition for GPIO_CRH register  *******************/
-#define  GPIO_CRH_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */
-
-#define  GPIO_CRH_MODE8                      ((uint32_t)0x00000003)        /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */
-#define  GPIO_CRH_MODE8_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE8_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE9                      ((uint32_t)0x00000030)        /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */
-#define  GPIO_CRH_MODE9_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE9_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE10                     ((uint32_t)0x00000300)        /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */
-#define  GPIO_CRH_MODE10_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE10_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE11                     ((uint32_t)0x00003000)        /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */
-#define  GPIO_CRH_MODE11_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE11_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE12                     ((uint32_t)0x00030000)        /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */
-#define  GPIO_CRH_MODE12_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE12_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE13                     ((uint32_t)0x00300000)        /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */
-#define  GPIO_CRH_MODE13_0                   ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE13_1                   ((uint32_t)0x00200000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE14                     ((uint32_t)0x03000000)        /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */
-#define  GPIO_CRH_MODE14_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE14_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_MODE15                     ((uint32_t)0x30000000)        /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */
-#define  GPIO_CRH_MODE15_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  GPIO_CRH_MODE15_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */
-
-#define  GPIO_CRH_CNF8                       ((uint32_t)0x0000000C)        /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */
-#define  GPIO_CRH_CNF8_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF8_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF9                       ((uint32_t)0x000000C0)        /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */
-#define  GPIO_CRH_CNF9_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF9_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF10                      ((uint32_t)0x00000C00)        /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */
-#define  GPIO_CRH_CNF10_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF10_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF11                      ((uint32_t)0x0000C000)        /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */
-#define  GPIO_CRH_CNF11_0                    ((uint32_t)0x00004000)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF11_1                    ((uint32_t)0x00008000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF12                      ((uint32_t)0x000C0000)        /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */
-#define  GPIO_CRH_CNF12_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF12_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF13                      ((uint32_t)0x00C00000)        /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */
-#define  GPIO_CRH_CNF13_0                    ((uint32_t)0x00400000)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF13_1                    ((uint32_t)0x00800000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF14                      ((uint32_t)0x0C000000)        /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */
-#define  GPIO_CRH_CNF14_0                    ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF14_1                    ((uint32_t)0x08000000)        /*!< Bit 1 */
-
-#define  GPIO_CRH_CNF15                      ((uint32_t)0xC0000000)        /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */
-#define  GPIO_CRH_CNF15_0                    ((uint32_t)0x40000000)        /*!< Bit 0 */
-#define  GPIO_CRH_CNF15_1                    ((uint32_t)0x80000000)        /*!< Bit 1 */
-
-/*!<******************  Bit definition for GPIO_IDR register  *******************/
-#define GPIO_IDR_IDR0                        ((uint16_t)0x0001)            /*!< Port input data, bit 0 */
-#define GPIO_IDR_IDR1                        ((uint16_t)0x0002)            /*!< Port input data, bit 1 */
-#define GPIO_IDR_IDR2                        ((uint16_t)0x0004)            /*!< Port input data, bit 2 */
-#define GPIO_IDR_IDR3                        ((uint16_t)0x0008)            /*!< Port input data, bit 3 */
-#define GPIO_IDR_IDR4                        ((uint16_t)0x0010)            /*!< Port input data, bit 4 */
-#define GPIO_IDR_IDR5                        ((uint16_t)0x0020)            /*!< Port input data, bit 5 */
-#define GPIO_IDR_IDR6                        ((uint16_t)0x0040)            /*!< Port input data, bit 6 */
-#define GPIO_IDR_IDR7                        ((uint16_t)0x0080)            /*!< Port input data, bit 7 */
-#define GPIO_IDR_IDR8                        ((uint16_t)0x0100)            /*!< Port input data, bit 8 */
-#define GPIO_IDR_IDR9                        ((uint16_t)0x0200)            /*!< Port input data, bit 9 */
-#define GPIO_IDR_IDR10                       ((uint16_t)0x0400)            /*!< Port input data, bit 10 */
-#define GPIO_IDR_IDR11                       ((uint16_t)0x0800)            /*!< Port input data, bit 11 */
-#define GPIO_IDR_IDR12                       ((uint16_t)0x1000)            /*!< Port input data, bit 12 */
-#define GPIO_IDR_IDR13                       ((uint16_t)0x2000)            /*!< Port input data, bit 13 */
-#define GPIO_IDR_IDR14                       ((uint16_t)0x4000)            /*!< Port input data, bit 14 */
-#define GPIO_IDR_IDR15                       ((uint16_t)0x8000)            /*!< Port input data, bit 15 */
-
-/*******************  Bit definition for GPIO_ODR register  *******************/
-#define GPIO_ODR_ODR0                        ((uint16_t)0x0001)            /*!< Port output data, bit 0 */
-#define GPIO_ODR_ODR1                        ((uint16_t)0x0002)            /*!< Port output data, bit 1 */
-#define GPIO_ODR_ODR2                        ((uint16_t)0x0004)            /*!< Port output data, bit 2 */
-#define GPIO_ODR_ODR3                        ((uint16_t)0x0008)            /*!< Port output data, bit 3 */
-#define GPIO_ODR_ODR4                        ((uint16_t)0x0010)            /*!< Port output data, bit 4 */
-#define GPIO_ODR_ODR5                        ((uint16_t)0x0020)            /*!< Port output data, bit 5 */
-#define GPIO_ODR_ODR6                        ((uint16_t)0x0040)            /*!< Port output data, bit 6 */
-#define GPIO_ODR_ODR7                        ((uint16_t)0x0080)            /*!< Port output data, bit 7 */
-#define GPIO_ODR_ODR8                        ((uint16_t)0x0100)            /*!< Port output data, bit 8 */
-#define GPIO_ODR_ODR9                        ((uint16_t)0x0200)            /*!< Port output data, bit 9 */
-#define GPIO_ODR_ODR10                       ((uint16_t)0x0400)            /*!< Port output data, bit 10 */
-#define GPIO_ODR_ODR11                       ((uint16_t)0x0800)            /*!< Port output data, bit 11 */
-#define GPIO_ODR_ODR12                       ((uint16_t)0x1000)            /*!< Port output data, bit 12 */
-#define GPIO_ODR_ODR13                       ((uint16_t)0x2000)            /*!< Port output data, bit 13 */
-#define GPIO_ODR_ODR14                       ((uint16_t)0x4000)            /*!< Port output data, bit 14 */
-#define GPIO_ODR_ODR15                       ((uint16_t)0x8000)            /*!< Port output data, bit 15 */
-
-/******************  Bit definition for GPIO_BSRR register  *******************/
-#define GPIO_BSRR_BS0                        ((uint32_t)0x00000001)        /*!< Port x Set bit 0 */
-#define GPIO_BSRR_BS1                        ((uint32_t)0x00000002)        /*!< Port x Set bit 1 */
-#define GPIO_BSRR_BS2                        ((uint32_t)0x00000004)        /*!< Port x Set bit 2 */
-#define GPIO_BSRR_BS3                        ((uint32_t)0x00000008)        /*!< Port x Set bit 3 */
-#define GPIO_BSRR_BS4                        ((uint32_t)0x00000010)        /*!< Port x Set bit 4 */
-#define GPIO_BSRR_BS5                        ((uint32_t)0x00000020)        /*!< Port x Set bit 5 */
-#define GPIO_BSRR_BS6                        ((uint32_t)0x00000040)        /*!< Port x Set bit 6 */
-#define GPIO_BSRR_BS7                        ((uint32_t)0x00000080)        /*!< Port x Set bit 7 */
-#define GPIO_BSRR_BS8                        ((uint32_t)0x00000100)        /*!< Port x Set bit 8 */
-#define GPIO_BSRR_BS9                        ((uint32_t)0x00000200)        /*!< Port x Set bit 9 */
-#define GPIO_BSRR_BS10                       ((uint32_t)0x00000400)        /*!< Port x Set bit 10 */
-#define GPIO_BSRR_BS11                       ((uint32_t)0x00000800)        /*!< Port x Set bit 11 */
-#define GPIO_BSRR_BS12                       ((uint32_t)0x00001000)        /*!< Port x Set bit 12 */
-#define GPIO_BSRR_BS13                       ((uint32_t)0x00002000)        /*!< Port x Set bit 13 */
-#define GPIO_BSRR_BS14                       ((uint32_t)0x00004000)        /*!< Port x Set bit 14 */
-#define GPIO_BSRR_BS15                       ((uint32_t)0x00008000)        /*!< Port x Set bit 15 */
-
-#define GPIO_BSRR_BR0                        ((uint32_t)0x00010000)        /*!< Port x Reset bit 0 */
-#define GPIO_BSRR_BR1                        ((uint32_t)0x00020000)        /*!< Port x Reset bit 1 */
-#define GPIO_BSRR_BR2                        ((uint32_t)0x00040000)        /*!< Port x Reset bit 2 */
-#define GPIO_BSRR_BR3                        ((uint32_t)0x00080000)        /*!< Port x Reset bit 3 */
-#define GPIO_BSRR_BR4                        ((uint32_t)0x00100000)        /*!< Port x Reset bit 4 */
-#define GPIO_BSRR_BR5                        ((uint32_t)0x00200000)        /*!< Port x Reset bit 5 */
-#define GPIO_BSRR_BR6                        ((uint32_t)0x00400000)        /*!< Port x Reset bit 6 */
-#define GPIO_BSRR_BR7                        ((uint32_t)0x00800000)        /*!< Port x Reset bit 7 */
-#define GPIO_BSRR_BR8                        ((uint32_t)0x01000000)        /*!< Port x Reset bit 8 */
-#define GPIO_BSRR_BR9                        ((uint32_t)0x02000000)        /*!< Port x Reset bit 9 */
-#define GPIO_BSRR_BR10                       ((uint32_t)0x04000000)        /*!< Port x Reset bit 10 */
-#define GPIO_BSRR_BR11                       ((uint32_t)0x08000000)        /*!< Port x Reset bit 11 */
-#define GPIO_BSRR_BR12                       ((uint32_t)0x10000000)        /*!< Port x Reset bit 12 */
-#define GPIO_BSRR_BR13                       ((uint32_t)0x20000000)        /*!< Port x Reset bit 13 */
-#define GPIO_BSRR_BR14                       ((uint32_t)0x40000000)        /*!< Port x Reset bit 14 */
-#define GPIO_BSRR_BR15                       ((uint32_t)0x80000000)        /*!< Port x Reset bit 15 */
-
-/*******************  Bit definition for GPIO_BRR register  *******************/
-#define GPIO_BRR_BR0                         ((uint16_t)0x0001)            /*!< Port x Reset bit 0 */
-#define GPIO_BRR_BR1                         ((uint16_t)0x0002)            /*!< Port x Reset bit 1 */
-#define GPIO_BRR_BR2                         ((uint16_t)0x0004)            /*!< Port x Reset bit 2 */
-#define GPIO_BRR_BR3                         ((uint16_t)0x0008)            /*!< Port x Reset bit 3 */
-#define GPIO_BRR_BR4                         ((uint16_t)0x0010)            /*!< Port x Reset bit 4 */
-#define GPIO_BRR_BR5                         ((uint16_t)0x0020)            /*!< Port x Reset bit 5 */
-#define GPIO_BRR_BR6                         ((uint16_t)0x0040)            /*!< Port x Reset bit 6 */
-#define GPIO_BRR_BR7                         ((uint16_t)0x0080)            /*!< Port x Reset bit 7 */
-#define GPIO_BRR_BR8                         ((uint16_t)0x0100)            /*!< Port x Reset bit 8 */
-#define GPIO_BRR_BR9                         ((uint16_t)0x0200)            /*!< Port x Reset bit 9 */
-#define GPIO_BRR_BR10                        ((uint16_t)0x0400)            /*!< Port x Reset bit 10 */
-#define GPIO_BRR_BR11                        ((uint16_t)0x0800)            /*!< Port x Reset bit 11 */
-#define GPIO_BRR_BR12                        ((uint16_t)0x1000)            /*!< Port x Reset bit 12 */
-#define GPIO_BRR_BR13                        ((uint16_t)0x2000)            /*!< Port x Reset bit 13 */
-#define GPIO_BRR_BR14                        ((uint16_t)0x4000)            /*!< Port x Reset bit 14 */
-#define GPIO_BRR_BR15                        ((uint16_t)0x8000)            /*!< Port x Reset bit 15 */
-
-/******************  Bit definition for GPIO_LCKR register  *******************/
-#define GPIO_LCKR_LCK0                       ((uint32_t)0x00000001)        /*!< Port x Lock bit 0 */
-#define GPIO_LCKR_LCK1                       ((uint32_t)0x00000002)        /*!< Port x Lock bit 1 */
-#define GPIO_LCKR_LCK2                       ((uint32_t)0x00000004)        /*!< Port x Lock bit 2 */
-#define GPIO_LCKR_LCK3                       ((uint32_t)0x00000008)        /*!< Port x Lock bit 3 */
-#define GPIO_LCKR_LCK4                       ((uint32_t)0x00000010)        /*!< Port x Lock bit 4 */
-#define GPIO_LCKR_LCK5                       ((uint32_t)0x00000020)        /*!< Port x Lock bit 5 */
-#define GPIO_LCKR_LCK6                       ((uint32_t)0x00000040)        /*!< Port x Lock bit 6 */
-#define GPIO_LCKR_LCK7                       ((uint32_t)0x00000080)        /*!< Port x Lock bit 7 */
-#define GPIO_LCKR_LCK8                       ((uint32_t)0x00000100)        /*!< Port x Lock bit 8 */
-#define GPIO_LCKR_LCK9                       ((uint32_t)0x00000200)        /*!< Port x Lock bit 9 */
-#define GPIO_LCKR_LCK10                      ((uint32_t)0x00000400)        /*!< Port x Lock bit 10 */
-#define GPIO_LCKR_LCK11                      ((uint32_t)0x00000800)        /*!< Port x Lock bit 11 */
-#define GPIO_LCKR_LCK12                      ((uint32_t)0x00001000)        /*!< Port x Lock bit 12 */
-#define GPIO_LCKR_LCK13                      ((uint32_t)0x00002000)        /*!< Port x Lock bit 13 */
-#define GPIO_LCKR_LCK14                      ((uint32_t)0x00004000)        /*!< Port x Lock bit 14 */
-#define GPIO_LCKR_LCK15                      ((uint32_t)0x00008000)        /*!< Port x Lock bit 15 */
-#define GPIO_LCKR_LCKK                       ((uint32_t)0x00010000)        /*!< Lock key */
-
-/*----------------------------------------------------------------------------*/
-
-/******************  Bit definition for AFIO_EVCR register  *******************/
-#define AFIO_EVCR_PIN                        ((uint8_t)0x0F)               /*!< PIN[3:0] bits (Pin selection) */
-#define AFIO_EVCR_PIN_0                      ((uint8_t)0x01)               /*!< Bit 0 */
-#define AFIO_EVCR_PIN_1                      ((uint8_t)0x02)               /*!< Bit 1 */
-#define AFIO_EVCR_PIN_2                      ((uint8_t)0x04)               /*!< Bit 2 */
-#define AFIO_EVCR_PIN_3                      ((uint8_t)0x08)               /*!< Bit 3 */
-
-/*!< PIN configuration */
-#define AFIO_EVCR_PIN_PX0                    ((uint8_t)0x00)               /*!< Pin 0 selected */
-#define AFIO_EVCR_PIN_PX1                    ((uint8_t)0x01)               /*!< Pin 1 selected */
-#define AFIO_EVCR_PIN_PX2                    ((uint8_t)0x02)               /*!< Pin 2 selected */
-#define AFIO_EVCR_PIN_PX3                    ((uint8_t)0x03)               /*!< Pin 3 selected */
-#define AFIO_EVCR_PIN_PX4                    ((uint8_t)0x04)               /*!< Pin 4 selected */
-#define AFIO_EVCR_PIN_PX5                    ((uint8_t)0x05)               /*!< Pin 5 selected */
-#define AFIO_EVCR_PIN_PX6                    ((uint8_t)0x06)               /*!< Pin 6 selected */
-#define AFIO_EVCR_PIN_PX7                    ((uint8_t)0x07)               /*!< Pin 7 selected */
-#define AFIO_EVCR_PIN_PX8                    ((uint8_t)0x08)               /*!< Pin 8 selected */
-#define AFIO_EVCR_PIN_PX9                    ((uint8_t)0x09)               /*!< Pin 9 selected */
-#define AFIO_EVCR_PIN_PX10                   ((uint8_t)0x0A)               /*!< Pin 10 selected */
-#define AFIO_EVCR_PIN_PX11                   ((uint8_t)0x0B)               /*!< Pin 11 selected */
-#define AFIO_EVCR_PIN_PX12                   ((uint8_t)0x0C)               /*!< Pin 12 selected */
-#define AFIO_EVCR_PIN_PX13                   ((uint8_t)0x0D)               /*!< Pin 13 selected */
-#define AFIO_EVCR_PIN_PX14                   ((uint8_t)0x0E)               /*!< Pin 14 selected */
-#define AFIO_EVCR_PIN_PX15                   ((uint8_t)0x0F)               /*!< Pin 15 selected */
-
-#define AFIO_EVCR_PORT                       ((uint8_t)0x70)               /*!< PORT[2:0] bits (Port selection) */
-#define AFIO_EVCR_PORT_0                     ((uint8_t)0x10)               /*!< Bit 0 */
-#define AFIO_EVCR_PORT_1                     ((uint8_t)0x20)               /*!< Bit 1 */
-#define AFIO_EVCR_PORT_2                     ((uint8_t)0x40)               /*!< Bit 2 */
-
-/*!< PORT configuration */
-#define AFIO_EVCR_PORT_PA                    ((uint8_t)0x00)               /*!< Port A selected */
-#define AFIO_EVCR_PORT_PB                    ((uint8_t)0x10)               /*!< Port B selected */
-#define AFIO_EVCR_PORT_PC                    ((uint8_t)0x20)               /*!< Port C selected */
-#define AFIO_EVCR_PORT_PD                    ((uint8_t)0x30)               /*!< Port D selected */
-#define AFIO_EVCR_PORT_PE                    ((uint8_t)0x40)               /*!< Port E selected */
-
-#define AFIO_EVCR_EVOE                       ((uint8_t)0x80)               /*!< Event Output Enable */
-
-/******************  Bit definition for AFIO_MAPR register  *******************/
-#define AFIO_MAPR_SPI1_REMAP                 ((uint32_t)0x00000001)        /*!< SPI1 remapping */
-#define AFIO_MAPR_I2C1_REMAP                 ((uint32_t)0x00000002)        /*!< I2C1 remapping */
-#define AFIO_MAPR_USART1_REMAP               ((uint32_t)0x00000004)        /*!< USART1 remapping */
-#define AFIO_MAPR_USART2_REMAP               ((uint32_t)0x00000008)        /*!< USART2 remapping */
-
-#define AFIO_MAPR_USART3_REMAP               ((uint32_t)0x00000030)        /*!< USART3_REMAP[1:0] bits (USART3 remapping) */
-#define AFIO_MAPR_USART3_REMAP_0             ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define AFIO_MAPR_USART3_REMAP_1             ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-/* USART3_REMAP configuration */
-#define AFIO_MAPR_USART3_REMAP_NOREMAP       ((uint32_t)0x00000000)        /*!< No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */
-#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP  ((uint32_t)0x00000010)        /*!< Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */
-#define AFIO_MAPR_USART3_REMAP_FULLREMAP     ((uint32_t)0x00000030)        /*!< Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */
-
-#define AFIO_MAPR_TIM1_REMAP                 ((uint32_t)0x000000C0)        /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */
-#define AFIO_MAPR_TIM1_REMAP_0               ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define AFIO_MAPR_TIM1_REMAP_1               ((uint32_t)0x00000080)        /*!< Bit 1 */
-
-/*!< TIM1_REMAP configuration */
-#define AFIO_MAPR_TIM1_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */
-#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP    ((uint32_t)0x00000040)        /*!< Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */
-#define AFIO_MAPR_TIM1_REMAP_FULLREMAP       ((uint32_t)0x000000C0)        /*!< Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */
-
-#define AFIO_MAPR_TIM2_REMAP                 ((uint32_t)0x00000300)        /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */
-#define AFIO_MAPR_TIM2_REMAP_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define AFIO_MAPR_TIM2_REMAP_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-
-/*!< TIM2_REMAP configuration */
-#define AFIO_MAPR_TIM2_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */
-#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1   ((uint32_t)0x00000100)        /*!< Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
-#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2   ((uint32_t)0x00000200)        /*!< Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */
-#define AFIO_MAPR_TIM2_REMAP_FULLREMAP       ((uint32_t)0x00000300)        /*!< Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */
-
-#define AFIO_MAPR_TIM3_REMAP                 ((uint32_t)0x00000C00)        /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */
-#define AFIO_MAPR_TIM3_REMAP_0               ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define AFIO_MAPR_TIM3_REMAP_1               ((uint32_t)0x00000800)        /*!< Bit 1 */
-
-/*!< TIM3_REMAP configuration */
-#define AFIO_MAPR_TIM3_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */
-#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP    ((uint32_t)0x00000800)        /*!< Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */
-#define AFIO_MAPR_TIM3_REMAP_FULLREMAP       ((uint32_t)0x00000C00)        /*!< Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */
-
-#define AFIO_MAPR_TIM4_REMAP                 ((uint32_t)0x00001000)        /*!< TIM4_REMAP bit (TIM4 remapping) */
-
-#define AFIO_MAPR_CAN_REMAP                  ((uint32_t)0x00006000)        /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
-#define AFIO_MAPR_CAN_REMAP_0                ((uint32_t)0x00002000)        /*!< Bit 0 */
-#define AFIO_MAPR_CAN_REMAP_1                ((uint32_t)0x00004000)        /*!< Bit 1 */
-
-/*!< CAN_REMAP configuration */
-#define AFIO_MAPR_CAN_REMAP_REMAP1           ((uint32_t)0x00000000)        /*!< CANRX mapped to PA11, CANTX mapped to PA12 */
-#define AFIO_MAPR_CAN_REMAP_REMAP2           ((uint32_t)0x00004000)        /*!< CANRX mapped to PB8, CANTX mapped to PB9 */
-#define AFIO_MAPR_CAN_REMAP_REMAP3           ((uint32_t)0x00006000)        /*!< CANRX mapped to PD0, CANTX mapped to PD1 */
-
-#define AFIO_MAPR_PD01_REMAP                 ((uint32_t)0x00008000)        /*!< Port D0/Port D1 mapping on OSC_IN/OSC_OUT */
-#define AFIO_MAPR_TIM5CH4_IREMAP             ((uint32_t)0x00010000)        /*!< TIM5 Channel4 Internal Remap */
-#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((uint32_t)0x00020000)        /*!< ADC 1 External Trigger Injected Conversion remapping */
-#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((uint32_t)0x00040000)        /*!< ADC 1 External Trigger Regular Conversion remapping */
-#define AFIO_MAPR_ADC2_ETRGINJ_REMAP         ((uint32_t)0x00080000)        /*!< ADC 2 External Trigger Injected Conversion remapping */
-#define AFIO_MAPR_ADC2_ETRGREG_REMAP         ((uint32_t)0x00100000)        /*!< ADC 2 External Trigger Regular Conversion remapping */
-
-/*!< SWJ_CFG configuration */
-#define AFIO_MAPR_SWJ_CFG                    ((uint32_t)0x07000000)        /*!< SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */
-#define AFIO_MAPR_SWJ_CFG_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define AFIO_MAPR_SWJ_CFG_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define AFIO_MAPR_SWJ_CFG_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
-
-#define AFIO_MAPR_SWJ_CFG_RESET              ((uint32_t)0x00000000)        /*!< Full SWJ (JTAG-DP + SW-DP) : Reset State */
-#define AFIO_MAPR_SWJ_CFG_NOJNTRST           ((uint32_t)0x01000000)        /*!< Full SWJ (JTAG-DP + SW-DP) but without JNTRST */
-#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE        ((uint32_t)0x02000000)        /*!< JTAG-DP Disabled and SW-DP Enabled */
-#define AFIO_MAPR_SWJ_CFG_DISABLE            ((uint32_t)0x04000000)        /*!< JTAG-DP Disabled and SW-DP Disabled */
-
-#ifdef STM32F10X_CL
-/*!< ETH_REMAP configuration */
- #define AFIO_MAPR_ETH_REMAP                  ((uint32_t)0x00200000)        /*!< SPI3_REMAP bit (Ethernet MAC I/O remapping) */
-
-/*!< CAN2_REMAP configuration */
- #define AFIO_MAPR_CAN2_REMAP                 ((uint32_t)0x00400000)        /*!< CAN2_REMAP bit (CAN2 I/O remapping) */
-
-/*!< MII_RMII_SEL configuration */
- #define AFIO_MAPR_MII_RMII_SEL               ((uint32_t)0x00800000)        /*!< MII_RMII_SEL bit (Ethernet MII or RMII selection) */
-
-/*!< SPI3_REMAP configuration */
- #define AFIO_MAPR_SPI3_REMAP                 ((uint32_t)0x10000000)        /*!< SPI3_REMAP bit (SPI3 remapping) */
-
-/*!< TIM2ITR1_IREMAP configuration */
- #define AFIO_MAPR_TIM2ITR1_IREMAP            ((uint32_t)0x20000000)        /*!< TIM2ITR1_IREMAP bit (TIM2 internal trigger 1 remapping) */
-
-/*!< PTP_PPS_REMAP configuration */
- #define AFIO_MAPR_PTP_PPS_REMAP              ((uint32_t)0x40000000)        /*!< PTP_PPS_REMAP bit (Ethernet PTP PPS remapping) */
-#endif
-
-/*****************  Bit definition for AFIO_EXTICR1 register  *****************/
-#define AFIO_EXTICR1_EXTI0                   ((uint16_t)0x000F)            /*!< EXTI 0 configuration */
-#define AFIO_EXTICR1_EXTI1                   ((uint16_t)0x00F0)            /*!< EXTI 1 configuration */
-#define AFIO_EXTICR1_EXTI2                   ((uint16_t)0x0F00)            /*!< EXTI 2 configuration */
-#define AFIO_EXTICR1_EXTI3                   ((uint16_t)0xF000)            /*!< EXTI 3 configuration */
-
-/*!< EXTI0 configuration */
-#define AFIO_EXTICR1_EXTI0_PA                ((uint16_t)0x0000)            /*!< PA[0] pin */
-#define AFIO_EXTICR1_EXTI0_PB                ((uint16_t)0x0001)            /*!< PB[0] pin */
-#define AFIO_EXTICR1_EXTI0_PC                ((uint16_t)0x0002)            /*!< PC[0] pin */
-#define AFIO_EXTICR1_EXTI0_PD                ((uint16_t)0x0003)            /*!< PD[0] pin */
-#define AFIO_EXTICR1_EXTI0_PE                ((uint16_t)0x0004)            /*!< PE[0] pin */
-#define AFIO_EXTICR1_EXTI0_PF                ((uint16_t)0x0005)            /*!< PF[0] pin */
-#define AFIO_EXTICR1_EXTI0_PG                ((uint16_t)0x0006)            /*!< PG[0] pin */
-
-/*!< EXTI1 configuration */
-#define AFIO_EXTICR1_EXTI1_PA                ((uint16_t)0x0000)            /*!< PA[1] pin */
-#define AFIO_EXTICR1_EXTI1_PB                ((uint16_t)0x0010)            /*!< PB[1] pin */
-#define AFIO_EXTICR1_EXTI1_PC                ((uint16_t)0x0020)            /*!< PC[1] pin */
-#define AFIO_EXTICR1_EXTI1_PD                ((uint16_t)0x0030)            /*!< PD[1] pin */
-#define AFIO_EXTICR1_EXTI1_PE                ((uint16_t)0x0040)            /*!< PE[1] pin */
-#define AFIO_EXTICR1_EXTI1_PF                ((uint16_t)0x0050)            /*!< PF[1] pin */
-#define AFIO_EXTICR1_EXTI1_PG                ((uint16_t)0x0060)            /*!< PG[1] pin */
-
-/*!< EXTI2 configuration */  
-#define AFIO_EXTICR1_EXTI2_PA                ((uint16_t)0x0000)            /*!< PA[2] pin */
-#define AFIO_EXTICR1_EXTI2_PB                ((uint16_t)0x0100)            /*!< PB[2] pin */
-#define AFIO_EXTICR1_EXTI2_PC                ((uint16_t)0x0200)            /*!< PC[2] pin */
-#define AFIO_EXTICR1_EXTI2_PD                ((uint16_t)0x0300)            /*!< PD[2] pin */
-#define AFIO_EXTICR1_EXTI2_PE                ((uint16_t)0x0400)            /*!< PE[2] pin */
-#define AFIO_EXTICR1_EXTI2_PF                ((uint16_t)0x0500)            /*!< PF[2] pin */
-#define AFIO_EXTICR1_EXTI2_PG                ((uint16_t)0x0600)            /*!< PG[2] pin */
-
-/*!< EXTI3 configuration */
-#define AFIO_EXTICR1_EXTI3_PA                ((uint16_t)0x0000)            /*!< PA[3] pin */
-#define AFIO_EXTICR1_EXTI3_PB                ((uint16_t)0x1000)            /*!< PB[3] pin */
-#define AFIO_EXTICR1_EXTI3_PC                ((uint16_t)0x2000)            /*!< PC[3] pin */
-#define AFIO_EXTICR1_EXTI3_PD                ((uint16_t)0x3000)            /*!< PD[3] pin */
-#define AFIO_EXTICR1_EXTI3_PE                ((uint16_t)0x4000)            /*!< PE[3] pin */
-#define AFIO_EXTICR1_EXTI3_PF                ((uint16_t)0x5000)            /*!< PF[3] pin */
-#define AFIO_EXTICR1_EXTI3_PG                ((uint16_t)0x6000)            /*!< PG[3] pin */
-
-/*****************  Bit definition for AFIO_EXTICR2 register  *****************/
-#define AFIO_EXTICR2_EXTI4                   ((uint16_t)0x000F)            /*!< EXTI 4 configuration */
-#define AFIO_EXTICR2_EXTI5                   ((uint16_t)0x00F0)            /*!< EXTI 5 configuration */
-#define AFIO_EXTICR2_EXTI6                   ((uint16_t)0x0F00)            /*!< EXTI 6 configuration */
-#define AFIO_EXTICR2_EXTI7                   ((uint16_t)0xF000)            /*!< EXTI 7 configuration */
-
-/*!< EXTI4 configuration */
-#define AFIO_EXTICR2_EXTI4_PA                ((uint16_t)0x0000)            /*!< PA[4] pin */
-#define AFIO_EXTICR2_EXTI4_PB                ((uint16_t)0x0001)            /*!< PB[4] pin */
-#define AFIO_EXTICR2_EXTI4_PC                ((uint16_t)0x0002)            /*!< PC[4] pin */
-#define AFIO_EXTICR2_EXTI4_PD                ((uint16_t)0x0003)            /*!< PD[4] pin */
-#define AFIO_EXTICR2_EXTI4_PE                ((uint16_t)0x0004)            /*!< PE[4] pin */
-#define AFIO_EXTICR2_EXTI4_PF                ((uint16_t)0x0005)            /*!< PF[4] pin */
-#define AFIO_EXTICR2_EXTI4_PG                ((uint16_t)0x0006)            /*!< PG[4] pin */
-
-/* EXTI5 configuration */
-#define AFIO_EXTICR2_EXTI5_PA                ((uint16_t)0x0000)            /*!< PA[5] pin */
-#define AFIO_EXTICR2_EXTI5_PB                ((uint16_t)0x0010)            /*!< PB[5] pin */
-#define AFIO_EXTICR2_EXTI5_PC                ((uint16_t)0x0020)            /*!< PC[5] pin */
-#define AFIO_EXTICR2_EXTI5_PD                ((uint16_t)0x0030)            /*!< PD[5] pin */
-#define AFIO_EXTICR2_EXTI5_PE                ((uint16_t)0x0040)            /*!< PE[5] pin */
-#define AFIO_EXTICR2_EXTI5_PF                ((uint16_t)0x0050)            /*!< PF[5] pin */
-#define AFIO_EXTICR2_EXTI5_PG                ((uint16_t)0x0060)            /*!< PG[5] pin */
-
-/*!< EXTI6 configuration */  
-#define AFIO_EXTICR2_EXTI6_PA                ((uint16_t)0x0000)            /*!< PA[6] pin */
-#define AFIO_EXTICR2_EXTI6_PB                ((uint16_t)0x0100)            /*!< PB[6] pin */
-#define AFIO_EXTICR2_EXTI6_PC                ((uint16_t)0x0200)            /*!< PC[6] pin */
-#define AFIO_EXTICR2_EXTI6_PD                ((uint16_t)0x0300)            /*!< PD[6] pin */
-#define AFIO_EXTICR2_EXTI6_PE                ((uint16_t)0x0400)            /*!< PE[6] pin */
-#define AFIO_EXTICR2_EXTI6_PF                ((uint16_t)0x0500)            /*!< PF[6] pin */
-#define AFIO_EXTICR2_EXTI6_PG                ((uint16_t)0x0600)            /*!< PG[6] pin */
-
-/*!< EXTI7 configuration */
-#define AFIO_EXTICR2_EXTI7_PA                ((uint16_t)0x0000)            /*!< PA[7] pin */
-#define AFIO_EXTICR2_EXTI7_PB                ((uint16_t)0x1000)            /*!< PB[7] pin */
-#define AFIO_EXTICR2_EXTI7_PC                ((uint16_t)0x2000)            /*!< PC[7] pin */
-#define AFIO_EXTICR2_EXTI7_PD                ((uint16_t)0x3000)            /*!< PD[7] pin */
-#define AFIO_EXTICR2_EXTI7_PE                ((uint16_t)0x4000)            /*!< PE[7] pin */
-#define AFIO_EXTICR2_EXTI7_PF                ((uint16_t)0x5000)            /*!< PF[7] pin */
-#define AFIO_EXTICR2_EXTI7_PG                ((uint16_t)0x6000)            /*!< PG[7] pin */
-
-/*****************  Bit definition for AFIO_EXTICR3 register  *****************/
-#define AFIO_EXTICR3_EXTI8                   ((uint16_t)0x000F)            /*!< EXTI 8 configuration */
-#define AFIO_EXTICR3_EXTI9                   ((uint16_t)0x00F0)            /*!< EXTI 9 configuration */
-#define AFIO_EXTICR3_EXTI10                  ((uint16_t)0x0F00)            /*!< EXTI 10 configuration */
-#define AFIO_EXTICR3_EXTI11                  ((uint16_t)0xF000)            /*!< EXTI 11 configuration */
-
-/*!< EXTI8 configuration */
-#define AFIO_EXTICR3_EXTI8_PA                ((uint16_t)0x0000)            /*!< PA[8] pin */
-#define AFIO_EXTICR3_EXTI8_PB                ((uint16_t)0x0001)            /*!< PB[8] pin */
-#define AFIO_EXTICR3_EXTI8_PC                ((uint16_t)0x0002)            /*!< PC[8] pin */
-#define AFIO_EXTICR3_EXTI8_PD                ((uint16_t)0x0003)            /*!< PD[8] pin */
-#define AFIO_EXTICR3_EXTI8_PE                ((uint16_t)0x0004)            /*!< PE[8] pin */
-#define AFIO_EXTICR3_EXTI8_PF                ((uint16_t)0x0005)            /*!< PF[8] pin */
-#define AFIO_EXTICR3_EXTI8_PG                ((uint16_t)0x0006)            /*!< PG[8] pin */
-
-/*!< EXTI9 configuration */
-#define AFIO_EXTICR3_EXTI9_PA                ((uint16_t)0x0000)            /*!< PA[9] pin */
-#define AFIO_EXTICR3_EXTI9_PB                ((uint16_t)0x0010)            /*!< PB[9] pin */
-#define AFIO_EXTICR3_EXTI9_PC                ((uint16_t)0x0020)            /*!< PC[9] pin */
-#define AFIO_EXTICR3_EXTI9_PD                ((uint16_t)0x0030)            /*!< PD[9] pin */
-#define AFIO_EXTICR3_EXTI9_PE                ((uint16_t)0x0040)            /*!< PE[9] pin */
-#define AFIO_EXTICR3_EXTI9_PF                ((uint16_t)0x0050)            /*!< PF[9] pin */
-#define AFIO_EXTICR3_EXTI9_PG                ((uint16_t)0x0060)            /*!< PG[9] pin */
-
-/*!< EXTI10 configuration */  
-#define AFIO_EXTICR3_EXTI10_PA               ((uint16_t)0x0000)            /*!< PA[10] pin */
-#define AFIO_EXTICR3_EXTI10_PB               ((uint16_t)0x0100)            /*!< PB[10] pin */
-#define AFIO_EXTICR3_EXTI10_PC               ((uint16_t)0x0200)            /*!< PC[10] pin */
-#define AFIO_EXTICR3_EXTI10_PD               ((uint16_t)0x0300)            /*!< PD[10] pin */
-#define AFIO_EXTICR3_EXTI10_PE               ((uint16_t)0x0400)            /*!< PE[10] pin */
-#define AFIO_EXTICR3_EXTI10_PF               ((uint16_t)0x0500)            /*!< PF[10] pin */
-#define AFIO_EXTICR3_EXTI10_PG               ((uint16_t)0x0600)            /*!< PG[10] pin */
-
-/*!< EXTI11 configuration */
-#define AFIO_EXTICR3_EXTI11_PA               ((uint16_t)0x0000)            /*!< PA[11] pin */
-#define AFIO_EXTICR3_EXTI11_PB               ((uint16_t)0x1000)            /*!< PB[11] pin */
-#define AFIO_EXTICR3_EXTI11_PC               ((uint16_t)0x2000)            /*!< PC[11] pin */
-#define AFIO_EXTICR3_EXTI11_PD               ((uint16_t)0x3000)            /*!< PD[11] pin */
-#define AFIO_EXTICR3_EXTI11_PE               ((uint16_t)0x4000)            /*!< PE[11] pin */
-#define AFIO_EXTICR3_EXTI11_PF               ((uint16_t)0x5000)            /*!< PF[11] pin */
-#define AFIO_EXTICR3_EXTI11_PG               ((uint16_t)0x6000)            /*!< PG[11] pin */
-
-/*****************  Bit definition for AFIO_EXTICR4 register  *****************/
-#define AFIO_EXTICR4_EXTI12                  ((uint16_t)0x000F)            /*!< EXTI 12 configuration */
-#define AFIO_EXTICR4_EXTI13                  ((uint16_t)0x00F0)            /*!< EXTI 13 configuration */
-#define AFIO_EXTICR4_EXTI14                  ((uint16_t)0x0F00)            /*!< EXTI 14 configuration */
-#define AFIO_EXTICR4_EXTI15                  ((uint16_t)0xF000)            /*!< EXTI 15 configuration */
-
-/* EXTI12 configuration */
-#define AFIO_EXTICR4_EXTI12_PA               ((uint16_t)0x0000)            /*!< PA[12] pin */
-#define AFIO_EXTICR4_EXTI12_PB               ((uint16_t)0x0001)            /*!< PB[12] pin */
-#define AFIO_EXTICR4_EXTI12_PC               ((uint16_t)0x0002)            /*!< PC[12] pin */
-#define AFIO_EXTICR4_EXTI12_PD               ((uint16_t)0x0003)            /*!< PD[12] pin */
-#define AFIO_EXTICR4_EXTI12_PE               ((uint16_t)0x0004)            /*!< PE[12] pin */
-#define AFIO_EXTICR4_EXTI12_PF               ((uint16_t)0x0005)            /*!< PF[12] pin */
-#define AFIO_EXTICR4_EXTI12_PG               ((uint16_t)0x0006)            /*!< PG[12] pin */
-
-/* EXTI13 configuration */
-#define AFIO_EXTICR4_EXTI13_PA               ((uint16_t)0x0000)            /*!< PA[13] pin */
-#define AFIO_EXTICR4_EXTI13_PB               ((uint16_t)0x0010)            /*!< PB[13] pin */
-#define AFIO_EXTICR4_EXTI13_PC               ((uint16_t)0x0020)            /*!< PC[13] pin */
-#define AFIO_EXTICR4_EXTI13_PD               ((uint16_t)0x0030)            /*!< PD[13] pin */
-#define AFIO_EXTICR4_EXTI13_PE               ((uint16_t)0x0040)            /*!< PE[13] pin */
-#define AFIO_EXTICR4_EXTI13_PF               ((uint16_t)0x0050)            /*!< PF[13] pin */
-#define AFIO_EXTICR4_EXTI13_PG               ((uint16_t)0x0060)            /*!< PG[13] pin */
-
-/*!< EXTI14 configuration */  
-#define AFIO_EXTICR4_EXTI14_PA               ((uint16_t)0x0000)            /*!< PA[14] pin */
-#define AFIO_EXTICR4_EXTI14_PB               ((uint16_t)0x0100)            /*!< PB[14] pin */
-#define AFIO_EXTICR4_EXTI14_PC               ((uint16_t)0x0200)            /*!< PC[14] pin */
-#define AFIO_EXTICR4_EXTI14_PD               ((uint16_t)0x0300)            /*!< PD[14] pin */
-#define AFIO_EXTICR4_EXTI14_PE               ((uint16_t)0x0400)            /*!< PE[14] pin */
-#define AFIO_EXTICR4_EXTI14_PF               ((uint16_t)0x0500)            /*!< PF[14] pin */
-#define AFIO_EXTICR4_EXTI14_PG               ((uint16_t)0x0600)            /*!< PG[14] pin */
-
-/*!< EXTI15 configuration */
-#define AFIO_EXTICR4_EXTI15_PA               ((uint16_t)0x0000)            /*!< PA[15] pin */
-#define AFIO_EXTICR4_EXTI15_PB               ((uint16_t)0x1000)            /*!< PB[15] pin */
-#define AFIO_EXTICR4_EXTI15_PC               ((uint16_t)0x2000)            /*!< PC[15] pin */
-#define AFIO_EXTICR4_EXTI15_PD               ((uint16_t)0x3000)            /*!< PD[15] pin */
-#define AFIO_EXTICR4_EXTI15_PE               ((uint16_t)0x4000)            /*!< PE[15] pin */
-#define AFIO_EXTICR4_EXTI15_PF               ((uint16_t)0x5000)            /*!< PF[15] pin */
-#define AFIO_EXTICR4_EXTI15_PG               ((uint16_t)0x6000)            /*!< PG[15] pin */
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-/******************  Bit definition for AFIO_MAPR2 register  ******************/
-#define AFIO_MAPR2_TIM15_REMAP               ((uint32_t)0x00000001)        /*!< TIM15 remapping */
-#define AFIO_MAPR2_TIM16_REMAP               ((uint32_t)0x00000002)        /*!< TIM16 remapping */
-#define AFIO_MAPR2_TIM17_REMAP               ((uint32_t)0x00000004)        /*!< TIM17 remapping */
-#define AFIO_MAPR2_CEC_REMAP                 ((uint32_t)0x00000008)        /*!< CEC remapping */
-#define AFIO_MAPR2_TIM1_DMA_REMAP            ((uint32_t)0x00000010)        /*!< TIM1_DMA remapping */
-#endif
-
-#ifdef STM32F10X_HD_VL
-#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
-#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
-#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
-#define AFIO_MAPR2_TIM67_DAC_DMA_REMAP       ((uint32_t)0x00000800)        /*!< TIM6/TIM7 and DAC DMA remapping */
-#define AFIO_MAPR2_TIM12_REMAP               ((uint32_t)0x00001000)        /*!< TIM12 remapping */
-#define AFIO_MAPR2_MISC_REMAP                ((uint32_t)0x00002000)        /*!< Miscellaneous remapping */
-#endif
-
-#ifdef STM32F10X_XL 
-/******************  Bit definition for AFIO_MAPR2 register  ******************/
-#define AFIO_MAPR2_TIM9_REMAP                ((uint32_t)0x00000020)        /*!< TIM9 remapping */
-#define AFIO_MAPR2_TIM10_REMAP               ((uint32_t)0x00000040)        /*!< TIM10 remapping */
-#define AFIO_MAPR2_TIM11_REMAP               ((uint32_t)0x00000080)        /*!< TIM11 remapping */
-#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */
-#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */
-#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */
-#endif
-
-/******************************************************************************/
-/*                                                                            */
-/*                               SystemTick                                   */
-/*                                                                            */
-/******************************************************************************/
-
-/*****************  Bit definition for SysTick_CTRL register  *****************/
-#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */
-#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */
-#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */
-#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */
-
-/*****************  Bit definition for SysTick_LOAD register  *****************/
-#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */
-
-/*****************  Bit definition for SysTick_VAL register  ******************/
-#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */
-
-/*****************  Bit definition for SysTick_CALIB register  ****************/
-#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */
-#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */
-#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */
-
-/******************************************************************************/
-/*                                                                            */
-/*                  Nested Vectored Interrupt Controller                      */
-/*                                                                            */
-/******************************************************************************/
-
-/******************  Bit definition for NVIC_ISER register  *******************/
-#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */
-#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
-#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
-#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
-#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
-#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
-#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
-#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
-#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
-#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
-#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
-#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
-#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
-#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
-#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
-#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
-#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
-#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
-#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
-#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
-#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
-#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
-#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
-#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
-#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
-#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
-#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
-#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
-#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
-#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
-#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
-#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
-#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
-
-/******************  Bit definition for NVIC_ICER register  *******************/
-#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */
-#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
-#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
-#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
-#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
-#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
-#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
-#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
-#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
-#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
-#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
-#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
-#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
-#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
-#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
-#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
-#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
-#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
-#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
-#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
-#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
-#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
-#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
-#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
-#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
-#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
-#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
-#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
-#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
-#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
-#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
-#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
-#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
-
-/******************  Bit definition for NVIC_ISPR register  *******************/
-#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */
-#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
-#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
-#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
-#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
-#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
-#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
-#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
-#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
-#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
-#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
-#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
-#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
-#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
-#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
-#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
-#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
-#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
-#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
-#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
-#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
-#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
-#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
-#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
-#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
-#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
-#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
-#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
-#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
-#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
-#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
-#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
-#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
-
-/******************  Bit definition for NVIC_ICPR register  *******************/
-#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */
-#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
-#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
-#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
-#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
-#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
-#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
-#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
-#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
-#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
-#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
-#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
-#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
-#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
-#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
-#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
-#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
-#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
-#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
-#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
-#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
-#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
-#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
-#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
-#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
-#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
-#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
-#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
-#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
-#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
-#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
-#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
-#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
-
-/******************  Bit definition for NVIC_IABR register  *******************/
-#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */
-#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
-#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
-#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
-#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
-#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
-#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
-#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
-#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
-#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
-#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
-#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
-#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
-#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
-#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
-#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
-#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
-#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
-#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
-#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
-#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
-#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
-#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
-#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
-#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
-#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
-#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
-#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
-#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
-#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
-#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
-#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
-#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
-
-/******************  Bit definition for NVIC_PRI0 register  *******************/
-#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */
-#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
-#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */
-#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */
-
-/******************  Bit definition for NVIC_PRI1 register  *******************/
-#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */
-#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */
-#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */
-#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */
-
-/******************  Bit definition for NVIC_PRI2 register  *******************/
-#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */
-#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */
-#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */
-#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */
-
-/******************  Bit definition for NVIC_PRI3 register  *******************/
-#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */
-#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */
-#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */
-#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */
-
-/******************  Bit definition for NVIC_PRI4 register  *******************/
-#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */
-#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */
-#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */
-#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */
-
-/******************  Bit definition for NVIC_PRI5 register  *******************/
-#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */
-#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */
-#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */
-#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */
-
-/******************  Bit definition for NVIC_PRI6 register  *******************/
-#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */
-#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */
-#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */
-#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */
-
-/******************  Bit definition for NVIC_PRI7 register  *******************/
-#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */
-#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */
-#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */
-#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */
-
-/******************  Bit definition for SCB_CPUID register  *******************/
-#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */
-#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */
-#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */
-#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */
-#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */
-
-/*******************  Bit definition for SCB_ICSR register  *******************/
-#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */
-#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */
-#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */
-#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */
-#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */
-#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */
-#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */
-#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */
-#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */
-#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */
-
-/*******************  Bit definition for SCB_VTOR register  *******************/
-#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */
-#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
-
-/*!<*****************  Bit definition for SCB_AIRCR register  *******************/
-#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */
-#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */
-#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */
-
-#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */
-#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */
-
-/* prority group configuration */
-#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
-#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
-#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
-
-#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */
-#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
-
-/*******************  Bit definition for SCB_SCR register  ********************/
-#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */
-#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */
-#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */
-
-/********************  Bit definition for SCB_CCR register  *******************/
-#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */
-#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
-#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */
-#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */
-#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
-#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
-
-/*******************  Bit definition for SCB_SHPR register ********************/
-#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
-#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
-#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
-#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
-
-/******************  Bit definition for SCB_SHCSR register  *******************/
-#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */
-#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */
-#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */
-#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */
-#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */
-#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */
-#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */
-#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */
-#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */
-#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */
-#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */
-#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */
-#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */
-#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */
-
-/*******************  Bit definition for SCB_CFSR register  *******************/
-/*!< MFSR */
-#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */
-#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */
-#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */
-#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */
-#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */
-/*!< BFSR */
-#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */
-#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */
-#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */
-#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */
-#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */
-#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */
-/*!< UFSR */
-#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to execute an undefined instruction */
-#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */
-#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */
-#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */
-#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */
-#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
-
-/*******************  Bit definition for SCB_HFSR register  *******************/
-#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occurs because of vector table read on exception processing */
-#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */
-#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */
-
-/*******************  Bit definition for SCB_DFSR register  *******************/
-#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */
-#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */
-#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */
-#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */
-#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */
-
-/*******************  Bit definition for SCB_MMFAR register  ******************/
-#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */
-
-/*******************  Bit definition for SCB_BFAR register  *******************/
-#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */
-
-/*******************  Bit definition for SCB_afsr register  *******************/
-#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */
-
-/******************************************************************************/
-/*                                                                            */
-/*                    External Interrupt/Event Controller                     */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for EXTI_IMR register  *******************/
-#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
-#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
-#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
-#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
-#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
-#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
-#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
-#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
-#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
-#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
-#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
-#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
-#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
-#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
-#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
-#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
-#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
-#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
-#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
-#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
-
-/*******************  Bit definition for EXTI_EMR register  *******************/
-#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
-#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
-#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
-#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
-#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
-#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
-#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
-#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
-#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
-#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
-#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
-#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
-#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
-#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
-#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
-#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
-#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
-#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
-#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
-#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
-
-/******************  Bit definition for EXTI_RTSR register  *******************/
-#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
-#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
-#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
-#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
-#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
-#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
-#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
-#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
-#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
-#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
-#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
-#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
-#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
-#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
-#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
-#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
-#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
-#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
-#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
-#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
-
-/******************  Bit definition for EXTI_FTSR register  *******************/
-#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
-#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
-#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
-#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
-#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
-#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
-#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
-#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
-#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
-#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
-#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
-#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
-#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
-#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
-#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
-#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
-#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
-#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
-#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
-#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
-
-/******************  Bit definition for EXTI_SWIER register  ******************/
-#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
-#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
-#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
-#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
-#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
-#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
-#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
-#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
-#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
-#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
-#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
-#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
-#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
-#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
-#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
-#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
-#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
-#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
-#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
-#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
-
-/*******************  Bit definition for EXTI_PR register  ********************/
-#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
-#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
-#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
-#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
-#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
-#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
-#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
-#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
-#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
-#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
-#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
-#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
-#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
-#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
-#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
-#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
-#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
-#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
-#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
-#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
-
-/******************************************************************************/
-/*                                                                            */
-/*                             DMA Controller                                 */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for DMA_ISR register  ********************/
-#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
-#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
-#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
-#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
-#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
-#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
-#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
-#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
-#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
-#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
-#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
-#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
-#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
-#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
-#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
-#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
-#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
-#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
-#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
-#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
-#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
-#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
-#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
-#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
-#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
-#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
-#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
-#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
-
-/*******************  Bit definition for DMA_IFCR register  *******************/
-#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
-#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
-#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
-#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
-#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
-#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
-#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
-#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
-#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
-#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
-#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
-#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
-#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
-#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
-#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
-#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
-#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
-#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
-#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
-#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
-#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
-#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
-
-/*******************  Bit definition for DMA_CCR1 register  *******************/
-#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/
-#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
-#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
-
-/*******************  Bit definition for DMA_CCR2 register  *******************/
-#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
-#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
-
-/*******************  Bit definition for DMA_CCR3 register  *******************/
-#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
-#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
-
-/*!<******************  Bit definition for DMA_CCR4 register  *******************/
-#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
-#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
-
-/******************  Bit definition for DMA_CCR5 register  *******************/
-#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
-#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
-
-/*******************  Bit definition for DMA_CCR6 register  *******************/
-#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
-#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
-
-/*******************  Bit definition for DMA_CCR7 register  *******************/
-#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
-#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
-#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
-#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
-#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
-#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
-#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
-#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
-
-#define  DMA_CCR7_PSIZE            ,         ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
-#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
-#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
-#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
-
-/******************  Bit definition for DMA_CNDTR1 register  ******************/
-#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CNDTR2 register  ******************/
-#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CNDTR3 register  ******************/
-#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CNDTR4 register  ******************/
-#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CNDTR5 register  ******************/
-#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CNDTR6 register  ******************/
-#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CNDTR7 register  ******************/
-#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
-
-/******************  Bit definition for DMA_CPAR1 register  *******************/
-#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-/******************  Bit definition for DMA_CPAR2 register  *******************/
-#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-/******************  Bit definition for DMA_CPAR3 register  *******************/
-#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR4 register  *******************/
-#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-/******************  Bit definition for DMA_CPAR5 register  *******************/
-#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-/******************  Bit definition for DMA_CPAR6 register  *******************/
-#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-
-/******************  Bit definition for DMA_CPAR7 register  *******************/
-#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
-
-/******************  Bit definition for DMA_CMAR1 register  *******************/
-#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-/******************  Bit definition for DMA_CMAR2 register  *******************/
-#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-/******************  Bit definition for DMA_CMAR3 register  *******************/
-#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-
-/******************  Bit definition for DMA_CMAR4 register  *******************/
-#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-/******************  Bit definition for DMA_CMAR5 register  *******************/
-#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-/******************  Bit definition for DMA_CMAR6 register  *******************/
-#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-/******************  Bit definition for DMA_CMAR7 register  *******************/
-#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
-
-/******************************************************************************/
-/*                                                                            */
-/*                        Analog to Digital Converter                         */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for ADC_SR register  ********************/
-#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!< Analog watchdog flag */
-#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!< End of conversion */
-#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!< Injected channel end of conversion */
-#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!< Injected channel Start flag */
-#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!< Regular channel Start flag */
-
-/*******************  Bit definition for ADC_CR1 register  ********************/
-#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
-#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
-
-#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */
-#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */
-#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */
-#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */
-#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */
-#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */
-#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */
-#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */
-
-#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
-#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */
-#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
-#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */
-
-#define  ADC_CR1_DUALMOD                     ((uint32_t)0x000F0000)        /*!< DUALMOD[3:0] bits (Dual mode selection) */
-#define  ADC_CR1_DUALMOD_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  ADC_CR1_DUALMOD_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  ADC_CR1_DUALMOD_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  ADC_CR1_DUALMOD_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */
-
-#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */
-#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */
-
-  
-/*******************  Bit definition for ADC_CR2 register  ********************/
-#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */
-#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */
-#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)        /*!< A/D Calibration */
-#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)        /*!< Reset Calibration */
-#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */
-#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */
-
-#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)        /*!< JEXTSEL[2:0] bits (External event select for injected group) */
-#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
-#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
-#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
-
-#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)        /*!< External Trigger Conversion mode for injected channels */
-
-#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)        /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
-#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)        /*!< Bit 0 */
-#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)        /*!< Bit 1 */
-#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)        /*!< Bit 2 */
-
-#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)        /*!< External Trigger Conversion mode for regular channels */
-#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)        /*!< Start Conversion of injected channels */
-#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)        /*!< Start Conversion of regular channels */
-#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */
-
-/******************  Bit definition for ADC_SMPR1 register  *******************/
-#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
-#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
-#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
-#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
-#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
-#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */
-#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
-#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
-
-#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
-#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
-#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
-#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
-
-/******************  Bit definition for ADC_SMPR2 register  *******************/
-#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
-#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
-#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
-#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
-#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
-#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
-#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
-#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
-#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
-#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
-
-#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
-#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
-#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
-#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
-
-/******************  Bit definition for ADC_JOFR1 register  *******************/
-#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
-
-/******************  Bit definition for ADC_JOFR2 register  *******************/
-#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */
-
-/******************  Bit definition for ADC_JOFR3 register  *******************/
-#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */
-
-/******************  Bit definition for ADC_JOFR4 register  *******************/
-#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */
-
-/*******************  Bit definition for ADC_HTR register  ********************/
-#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */
-
-/*******************  Bit definition for ADC_LTR register  ********************/
-#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */
-
-/*******************  Bit definition for ADC_SQR1 register  *******************/
-#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
-#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
-
-#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
-#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
-#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
-#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
-#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
-#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
-
-#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
-#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
-#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
-#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
-#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
-#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
-#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
-
-#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
-#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-/*******************  Bit definition for ADC_SQR2 register  *******************/
-#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
-#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
-
-#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
-#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
-#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
-#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
-#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
-#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
-
-#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
-#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
-#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
-#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
-#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
-#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
-#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
-
-#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
-#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
-#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
-
-#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
-#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
-#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
-#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
-#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
-#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
-
-/*******************  Bit definition for ADC_SQR3 register  *******************/
-#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
-#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
-
-#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
-#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
-#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
-#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
-#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
-#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
-
-#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
-#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
-#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
-#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
-#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
-#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
-#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
-
-#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
-#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
-#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
-
-#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
-#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
-#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
-#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
-#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
-#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
-
-/*******************  Bit definition for ADC_JSQR register  *******************/
-#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
-#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
-
-#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
-#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
-#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
-#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
-#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
-#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
-
-#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
-#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
-#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
-#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
-#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
-#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
-#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
-
-#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
-#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
-
-/*******************  Bit definition for ADC_JDR1 register  *******************/
-#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
-
-/*******************  Bit definition for ADC_JDR2 register  *******************/
-#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
-
-/*******************  Bit definition for ADC_JDR3 register  *******************/
-#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
-
-/*******************  Bit definition for ADC_JDR4 register  *******************/
-#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
-
-/********************  Bit definition for ADC_DR register  ********************/
-#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
-#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!< ADC2 data */
-
-/******************************************************************************/
-/*                                                                            */
-/*                      Digital to Analog Converter                           */
-/*                                                                            */
-/******************************************************************************/
-
-/********************  Bit definition for DAC_CR register  ********************/
-#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */
-#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */
-#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */
-
-#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
-#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */
-#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
-#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */
-
-#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
-#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
-
-#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
-#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */
-#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */
-#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */
-#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */
-
-#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
-#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */
-#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
-#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */
-
-#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
-#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */
-#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
-
-#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
-#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */
-
-/*****************  Bit definition for DAC_SWTRIGR register  ******************/
-#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */
-#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */
-
-/*****************  Bit definition for DAC_DHR12R1 register  ******************/
-#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */
-
-/*****************  Bit definition for DAC_DHR12L1 register  ******************/
-#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */
-
-/******************  Bit definition for DAC_DHR8R1 register  ******************/
-#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */
-
-/*****************  Bit definition for DAC_DHR12R2 register  ******************/
-#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */
-
-/*****************  Bit definition for DAC_DHR12L2 register  ******************/
-#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */
-
-/******************  Bit definition for DAC_DHR8R2 register  ******************/
-#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */
-
-/*****************  Bit definition for DAC_DHR12RD register  ******************/
-#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */
-#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */
-
-/*****************  Bit definition for DAC_DHR12LD register  ******************/
-#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */
-#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */
-
-/******************  Bit definition for DAC_DHR8RD register  ******************/
-#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */
-#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */
-
-/*******************  Bit definition for DAC_DOR1 register  *******************/
-#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */
-
-/*******************  Bit definition for DAC_DOR2 register  *******************/
-#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */
-
-/********************  Bit definition for DAC_SR register  ********************/
-#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */
-#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */
-
-/******************************************************************************/
-/*                                                                            */
-/*                                    CEC                                     */
-/*                                                                            */
-/******************************************************************************/
-/********************  Bit definition for CEC_CFGR register  ******************/
-#define  CEC_CFGR_PE              ((uint16_t)0x0001)     /*!<  Peripheral Enable */
-#define  CEC_CFGR_IE              ((uint16_t)0x0002)     /*!<  Interrupt Enable */
-#define  CEC_CFGR_BTEM            ((uint16_t)0x0004)     /*!<  Bit Timing Error Mode */
-#define  CEC_CFGR_BPEM            ((uint16_t)0x0008)     /*!<  Bit Period Error Mode */
-
-/********************  Bit definition for CEC_OAR register  ******************/
-#define  CEC_OAR_OA               ((uint16_t)0x000F)     /*!<  OA[3:0]: Own Address */
-#define  CEC_OAR_OA_0             ((uint16_t)0x0001)     /*!<  Bit 0 */
-#define  CEC_OAR_OA_1             ((uint16_t)0x0002)     /*!<  Bit 1 */
-#define  CEC_OAR_OA_2             ((uint16_t)0x0004)     /*!<  Bit 2 */
-#define  CEC_OAR_OA_3             ((uint16_t)0x0008)     /*!<  Bit 3 */
-
-/********************  Bit definition for CEC_PRES register  ******************/
-#define  CEC_PRES_PRES            ((uint16_t)0x3FFF)   /*!<  Prescaler Counter Value */
-
-/********************  Bit definition for CEC_ESR register  ******************/
-#define  CEC_ESR_BTE              ((uint16_t)0x0001)     /*!<  Bit Timing Error */
-#define  CEC_ESR_BPE              ((uint16_t)0x0002)     /*!<  Bit Period Error */
-#define  CEC_ESR_RBTFE            ((uint16_t)0x0004)     /*!<  Rx Block Transfer Finished Error */
-#define  CEC_ESR_SBE              ((uint16_t)0x0008)     /*!<  Start Bit Error */
-#define  CEC_ESR_ACKE             ((uint16_t)0x0010)     /*!<  Block Acknowledge Error */
-#define  CEC_ESR_LINE             ((uint16_t)0x0020)     /*!<  Line Error */
-#define  CEC_ESR_TBTFE            ((uint16_t)0x0040)     /*!<  Tx Block Transfer Finished Error */
-
-/********************  Bit definition for CEC_CSR register  ******************/
-#define  CEC_CSR_TSOM             ((uint16_t)0x0001)     /*!<  Tx Start Of Message */
-#define  CEC_CSR_TEOM             ((uint16_t)0x0002)     /*!<  Tx End Of Message */
-#define  CEC_CSR_TERR             ((uint16_t)0x0004)     /*!<  Tx Error */
-#define  CEC_CSR_TBTRF            ((uint16_t)0x0008)     /*!<  Tx Byte Transfer Request or Block Transfer Finished */
-#define  CEC_CSR_RSOM             ((uint16_t)0x0010)     /*!<  Rx Start Of Message */
-#define  CEC_CSR_REOM             ((uint16_t)0x0020)     /*!<  Rx End Of Message */
-#define  CEC_CSR_RERR             ((uint16_t)0x0040)     /*!<  Rx Error */
-#define  CEC_CSR_RBTF             ((uint16_t)0x0080)     /*!<  Rx Block Transfer Finished */
-
-/********************  Bit definition for CEC_TXD register  ******************/
-#define  CEC_TXD_TXD              ((uint16_t)0x00FF)     /*!<  Tx Data register */
-
-/********************  Bit definition for CEC_RXD register  ******************/
-#define  CEC_RXD_RXD              ((uint16_t)0x00FF)     /*!<  Rx Data register */
-
-/******************************************************************************/
-/*                                                                            */
-/*                                    TIM                                     */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for TIM_CR1 register  ********************/
-#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!< Counter enable */
-#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!< Update disable */
-#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!< Update request source */
-#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!< One pulse mode */
-#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!< Direction */
-
-#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!< CMS[1:0] bits (Center-aligned mode selection) */
-#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!< Bit 0 */
-#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!< Bit 1 */
-
-#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!< Auto-reload preload enable */
-
-#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!< CKD[1:0] bits (clock division) */
-#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
-
-/*******************  Bit definition for TIM_CR2 register  ********************/
-#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!< Capture/Compare Preloaded Control */
-#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!< Capture/Compare Control Update Selection */
-#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!< Capture/Compare DMA Selection */
-
-#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!< MMS[2:0] bits (Master Mode Selection) */
-#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
-
-#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!< TI1 Selection */
-#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!< Output Idle state 1 (OC1 output) */
-#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!< Output Idle state 1 (OC1N output) */
-#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!< Output Idle state 2 (OC2 output) */
-#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!< Output Idle state 2 (OC2N output) */
-#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!< Output Idle state 3 (OC3 output) */
-#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!< Output Idle state 3 (OC3N output) */
-#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!< Output Idle state 4 (OC4 output) */
-
-/*******************  Bit definition for TIM_SMCR register  *******************/
-#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!< SMS[2:0] bits (Slave mode selection) */
-#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
-
-#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!< TS[2:0] bits (Trigger selection) */
-#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */
-
-#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!< Master/slave mode */
-
-#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!< ETF[3:0] bits (External trigger filter) */
-#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!< Bit 1 */
-#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!< Bit 2 */
-#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!< Bit 3 */
-
-#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!< ETPS[1:0] bits (External trigger prescaler) */
-#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!< External clock enable */
-#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!< External trigger polarity */
-
-/*******************  Bit definition for TIM_DIER register  *******************/
-#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!< Update interrupt enable */
-#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt enable */
-#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt enable */
-#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt enable */
-#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt enable */
-#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!< COM interrupt enable */
-#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!< Trigger interrupt enable */
-#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!< Break interrupt enable */
-#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!< Update DMA request enable */
-#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!< Capture/Compare 1 DMA request enable */
-#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!< Capture/Compare 2 DMA request enable */
-#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 DMA request enable */
-#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!< Capture/Compare 4 DMA request enable */
-#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!< COM DMA request enable */
-#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!< Trigger DMA request enable */
-
-/********************  Bit definition for TIM_SR register  ********************/
-#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!< Update interrupt Flag */
-#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt Flag */
-#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt Flag */
-#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt Flag */
-#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt Flag */
-#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!< COM interrupt Flag */
-#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!< Trigger interrupt Flag */
-#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!< Break interrupt Flag */
-#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!< Capture/Compare 1 Overcapture Flag */
-#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!< Capture/Compare 2 Overcapture Flag */
-#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!< Capture/Compare 3 Overcapture Flag */
-#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!< Capture/Compare 4 Overcapture Flag */
-
-/*******************  Bit definition for TIM_EGR register  ********************/
-#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!< Update Generation */
-#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!< Capture/Compare 1 Generation */
-#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!< Capture/Compare 2 Generation */
-#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!< Capture/Compare 3 Generation */
-#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!< Capture/Compare 4 Generation */
-#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!< Capture/Compare Control Update Generation */
-#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!< Trigger Generation */
-#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!< Break Generation */
-
-/******************  Bit definition for TIM_CCMR1 register  *******************/
-#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!< CC1S[1:0] bits (Capture/Compare 1 Selection) */
-#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
-
-#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!< Output Compare 1 Fast enable */
-#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!< Output Compare 1 Preload enable */
-
-#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!< OC1M[2:0] bits (Output Compare 1 Mode) */
-#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
-
-#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!< Output Compare 1Clear Enable */
-
-#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!< CC2S[1:0] bits (Capture/Compare 2 Selection) */
-#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!< Output Compare 2 Fast enable */
-#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!< Output Compare 2 Preload enable */
-
-#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!< OC2M[2:0] bits (Output Compare 2 Mode) */
-#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
-#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
-
-#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!< Output Compare 2 Clear Enable */
-
-/*----------------------------------------------------------------------------*/
-
-#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!< IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
-#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
-#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
-
-#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!< IC1F[3:0] bits (Input Capture 1 Filter) */
-#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
-#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
-
-#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!< IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
-#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!< IC2F[3:0] bits (Input Capture 2 Filter) */
-#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
-#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
-#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
-
-/******************  Bit definition for TIM_CCMR2 register  *******************/
-#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!< CC3S[1:0] bits (Capture/Compare 3 Selection) */
-#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
-
-#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!< Output Compare 3 Fast enable */
-#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!< Output Compare 3 Preload enable */
-
-#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!< OC3M[2:0] bits (Output Compare 3 Mode) */
-#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
-
-#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!< Output Compare 3 Clear Enable */
-
-#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!< CC4S[1:0] bits (Capture/Compare 4 Selection) */
-#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!< Output Compare 4 Fast enable */
-#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!< Output Compare 4 Preload enable */
-
-#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!< OC4M[2:0] bits (Output Compare 4 Mode) */
-#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
-#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
-
-#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!< Output Compare 4 Clear Enable */
-
-/*----------------------------------------------------------------------------*/
-
-#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!< IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
-#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */
-#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */
-
-#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!< IC3F[3:0] bits (Input Capture 3 Filter) */
-#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */
-#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */
-
-#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!< IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
-#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */
-
-#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!< IC4F[3:0] bits (Input Capture 4 Filter) */
-#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
-#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */
-#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */
-
-/*******************  Bit definition for TIM_CCER register  *******************/
-#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!< Capture/Compare 1 output enable */
-#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!< Capture/Compare 1 output Polarity */
-#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!< Capture/Compare 1 Complementary output enable */
-#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!< Capture/Compare 1 Complementary output Polarity */
-#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!< Capture/Compare 2 output enable */
-#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!< Capture/Compare 2 output Polarity */
-#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!< Capture/Compare 2 Complementary output enable */
-#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!< Capture/Compare 2 Complementary output Polarity */
-#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!< Capture/Compare 3 output enable */
-#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!< Capture/Compare 3 output Polarity */
-#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!< Capture/Compare 3 Complementary output enable */
-#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 Complementary output Polarity */
-#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!< Capture/Compare 4 output enable */
-#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!< Capture/Compare 4 output Polarity */
-#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!< Capture/Compare 4 Complementary output Polarity */
-
-/*******************  Bit definition for TIM_CNT register  ********************/
-#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!< Counter Value */
-
-/*******************  Bit definition for TIM_PSC register  ********************/
-#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!< Prescaler Value */
-
-/*******************  Bit definition for TIM_ARR register  ********************/
-#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!< actual auto-reload Value */
-
-/*******************  Bit definition for TIM_RCR register  ********************/
-#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!< Repetition Counter Value */
-
-/*******************  Bit definition for TIM_CCR1 register  *******************/
-#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 1 Value */
-
-/*******************  Bit definition for TIM_CCR2 register  *******************/
-#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 2 Value */
-
-/*******************  Bit definition for TIM_CCR3 register  *******************/
-#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 3 Value */
-
-/*******************  Bit definition for TIM_CCR4 register  *******************/
-#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 4 Value */
-
-/*******************  Bit definition for TIM_BDTR register  *******************/
-#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!< DTG[0:7] bits (Dead-Time Generator set-up) */
-#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
-#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
-#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
-#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
-#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!< Bit 6 */
-#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!< Bit 7 */
-
-#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!< LOCK[1:0] bits (Lock Configuration) */
-#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!< Off-State Selection for Idle mode */
-#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!< Off-State Selection for Run mode */
-#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!< Break enable */
-#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!< Break Polarity */
-#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!< Automatic Output enable */
-#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!< Main Output enable */
-
-/*******************  Bit definition for TIM_DCR register  ********************/
-#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!< DBA[4:0] bits (DMA Base Address) */
-#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!< Bit 2 */
-#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!< Bit 3 */
-#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!< Bit 4 */
-
-#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!< DBL[4:0] bits (DMA Burst Length) */
-#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!< Bit 1 */
-#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!< Bit 2 */
-#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!< Bit 3 */
-#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!< Bit 4 */
-
-/*******************  Bit definition for TIM_DMAR register  *******************/
-#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!< DMA register for burst accesses */
-
-/******************************************************************************/
-/*                                                                            */
-/*                             Real-Time Clock                                */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for RTC_CRH register  ********************/
-#define  RTC_CRH_SECIE                       ((uint8_t)0x01)               /*!< Second Interrupt Enable */
-#define  RTC_CRH_ALRIE                       ((uint8_t)0x02)               /*!< Alarm Interrupt Enable */
-#define  RTC_CRH_OWIE                        ((uint8_t)0x04)               /*!< OverfloW Interrupt Enable */
-
-/*******************  Bit definition for RTC_CRL register  ********************/
-#define  RTC_CRL_SECF                        ((uint8_t)0x01)               /*!< Second Flag */
-#define  RTC_CRL_ALRF                        ((uint8_t)0x02)               /*!< Alarm Flag */
-#define  RTC_CRL_OWF                         ((uint8_t)0x04)               /*!< OverfloW Flag */
-#define  RTC_CRL_RSF                         ((uint8_t)0x08)               /*!< Registers Synchronized Flag */
-#define  RTC_CRL_CNF                         ((uint8_t)0x10)               /*!< Configuration Flag */
-#define  RTC_CRL_RTOFF                       ((uint8_t)0x20)               /*!< RTC operation OFF */
-
-/*******************  Bit definition for RTC_PRLH register  *******************/
-#define  RTC_PRLH_PRL                        ((uint16_t)0x000F)            /*!< RTC Prescaler Reload Value High */
-
-/*******************  Bit definition for RTC_PRLL register  *******************/
-#define  RTC_PRLL_PRL                        ((uint16_t)0xFFFF)            /*!< RTC Prescaler Reload Value Low */
-
-/*******************  Bit definition for RTC_DIVH register  *******************/
-#define  RTC_DIVH_RTC_DIV                    ((uint16_t)0x000F)            /*!< RTC Clock Divider High */
-
-/*******************  Bit definition for RTC_DIVL register  *******************/
-#define  RTC_DIVL_RTC_DIV                    ((uint16_t)0xFFFF)            /*!< RTC Clock Divider Low */
-
-/*******************  Bit definition for RTC_CNTH register  *******************/
-#define  RTC_CNTH_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter High */
-
-/*******************  Bit definition for RTC_CNTL register  *******************/
-#define  RTC_CNTL_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter Low */
-
-/*******************  Bit definition for RTC_ALRH register  *******************/
-#define  RTC_ALRH_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm High */
-
-/*******************  Bit definition for RTC_ALRL register  *******************/
-#define  RTC_ALRL_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm Low */
-
-/******************************************************************************/
-/*                                                                            */
-/*                           Independent WATCHDOG                             */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for IWDG_KR register  ********************/
-#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
-
-/*******************  Bit definition for IWDG_PR register  ********************/
-#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
-#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
-#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
-#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
-
-/*******************  Bit definition for IWDG_RLR register  *******************/
-#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
-
-/*******************  Bit definition for IWDG_SR register  ********************/
-#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
-#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
-
-/******************************************************************************/
-/*                                                                            */
-/*                            Window WATCHDOG                                 */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for WWDG_CR register  ********************/
-#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
-#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
-#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
-#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
-#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
-#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
-#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
-#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
-
-#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
-
-/*******************  Bit definition for WWDG_CFR register  *******************/
-#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
-#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
-#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
-#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
-#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
-#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
-
-#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
-#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
-#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
-
-#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
-
-/*******************  Bit definition for WWDG_SR register  ********************/
-#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
-
-/******************************************************************************/
-/*                                                                            */
-/*                       Flexible Static Memory Controller                    */
-/*                                                                            */
-/******************************************************************************/
-
-/******************  Bit definition for FSMC_BCR1 register  *******************/
-#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
-#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
-
-#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
-#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
-#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
-#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
-#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
-#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
-#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
-#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
-#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
-#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
-
-/******************  Bit definition for FSMC_BCR2 register  *******************/
-#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
-#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
-
-#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
-#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
-#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
-#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
-#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
-#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
-#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
-#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
-#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
-#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
-
-/******************  Bit definition for FSMC_BCR3 register  *******************/
-#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
-#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
-
-#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
-#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
-#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */
-#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
-#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
-#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
-#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
-#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
-#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
-#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
-
-/******************  Bit definition for FSMC_BCR4 register  *******************/
-#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
-#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
-
-#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
-#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
-#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
-
-#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
-#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
-#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
-#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
-#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
-#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
-#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
-#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
-#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
-#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
-#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
-
-/******************  Bit definition for FSMC_BTR1 register  ******************/
-#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
-
-#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_BTR2 register  *******************/
-#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
-
-#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/*******************  Bit definition for FSMC_BTR3 register  *******************/
-#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
-
-#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_BTR4 register  *******************/
-#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
-#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
-
-#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_BWTR1 register  ******************/
-#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_BWTR2 register  ******************/
-#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
-#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_BWTR3 register  ******************/
-#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_BWTR4 register  ******************/
-#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
-#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
-
-#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
-#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
-#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
-
-#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
-#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
-
-#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
-#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
-#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
-#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
-#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
-#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
-
-#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
-#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
-#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
-
-/******************  Bit definition for FSMC_PCR2 register  *******************/
-#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
-#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
-#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
-
-#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
-#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
-
-#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
-#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
-#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
-#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
-#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
-
-#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
-#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
-#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
-#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
-#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
-
-#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[1:0] bits (ECC page size) */
-#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
-#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
-#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
-
-/******************  Bit definition for FSMC_PCR3 register  *******************/
-#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
-#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
-#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
-
-#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
-#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
-
-#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
-#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
-#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
-#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
-#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
-
-#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
-#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
-#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
-#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
-#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
-
-#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
-#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
-#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
-#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
-
-/******************  Bit definition for FSMC_PCR4 register  *******************/
-#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */
-#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */
-#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */
-
-#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */
-#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
-
-#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */
-
-#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */
-#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
-#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
-#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
-#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */
-
-#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */
-#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */
-#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */
-#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */
-#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */
-
-#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */
-#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */
-#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */
-#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */
-
-/*******************  Bit definition for FSMC_SR2 register  *******************/
-#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
-#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
-#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
-#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
-#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
-#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
-#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
-
-/*******************  Bit definition for FSMC_SR3 register  *******************/
-#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
-#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
-#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
-#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
-#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
-#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
-#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
-
-/*******************  Bit definition for FSMC_SR4 register  *******************/
-#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */
-#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */
-#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */
-#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */
-#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */
-#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */
-#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */
-
-/******************  Bit definition for FSMC_PMEM2 register  ******************/
-#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!< MEMSET2[7:0] bits (Common memory 2 setup time) */
-#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT2[7:0] bits (Common memory 2 wait time) */
-#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD2[7:0] bits (Common memory 2 hold time) */
-#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!< MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
-#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_PMEM3 register  ******************/
-#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!< MEMSET3[7:0] bits (Common memory 3 setup time) */
-#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT3[7:0] bits (Common memory 3 wait time) */
-#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD3[7:0] bits (Common memory 3 hold time) */
-#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!< MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
-#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_PMEM4 register  ******************/
-#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!< MEMSET4[7:0] bits (Common memory 4 setup time) */
-#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT4[7:0] bits (Common memory 4 wait time) */
-#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD4[7:0] bits (Common memory 4 hold time) */
-#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!< MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
-#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_PATT2 register  ******************/
-#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!< ATTSET2[7:0] bits (Attribute memory 2 setup time) */
-#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
-#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
-#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!< ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
-#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_PATT3 register  ******************/
-#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!< ATTSET3[7:0] bits (Attribute memory 3 setup time) */
-#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
-#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
-#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!< ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
-#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_PATT4 register  ******************/
-#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!< ATTSET4[7:0] bits (Attribute memory 4 setup time) */
-#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
-#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
-#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!< ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
-#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_PIO4 register  *******************/
-#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!< IOSET4[7:0] bits (I/O 4 setup time) */
-#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
-#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
-#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
-#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
-#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!< Bit 4 */
-#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!< Bit 5 */
-#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!< Bit 6 */
-#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!< Bit 7 */
-
-#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!< IOWAIT4[7:0] bits (I/O 4 wait time) */
-#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
-#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
-#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
-#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
-#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!< Bit 4 */
-#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!< Bit 5 */
-#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!< Bit 6 */
-#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!< Bit 7 */
-
-#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!< IOHOLD4[7:0] bits (I/O 4 hold time) */
-#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!< Bit 7 */
-
-#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!< IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
-#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
-#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
-#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
-#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
-#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!< Bit 4 */
-#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!< Bit 5 */
-#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!< Bit 6 */
-#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!< Bit 7 */
-
-/******************  Bit definition for FSMC_ECCR2 register  ******************/
-#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
-
-/******************  Bit definition for FSMC_ECCR3 register  ******************/
-#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */
-
-/******************************************************************************/
-/*                                                                            */
-/*                          SD host Interface                                 */
-/*                                                                            */
-/******************************************************************************/
-
-/******************  Bit definition for SDIO_POWER register  ******************/
-#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
-#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */
-#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
-
-/******************  Bit definition for SDIO_CLKCR register  ******************/
-#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */
-#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */
-#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */
-#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */
-
-#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
-#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */
-#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
-
-#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */
-#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */
-
-/*******************  Bit definition for SDIO_ARG register  *******************/
-#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */
-
-/*******************  Bit definition for SDIO_CMD register  *******************/
-#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */
-
-#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
-#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */
-#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
-
-#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */
-#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
-#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */
-#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */
-#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */
-#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */
-#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */
-
-/*****************  Bit definition for SDIO_RESPCMD register  *****************/
-#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */
-
-/******************  Bit definition for SDIO_RESP0 register  ******************/
-#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
-
-/******************  Bit definition for SDIO_RESP1 register  ******************/
-#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
-
-/******************  Bit definition for SDIO_RESP2 register  ******************/
-#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
-
-/******************  Bit definition for SDIO_RESP3 register  ******************/
-#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
-
-/******************  Bit definition for SDIO_RESP4 register  ******************/
-#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
-
-/******************  Bit definition for SDIO_DTIMER register  *****************/
-#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */
-
-/******************  Bit definition for SDIO_DLEN register  *******************/
-#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */
-
-/******************  Bit definition for SDIO_DCTRL register  ******************/
-#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */
-#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */
-#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */
-#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */
-
-#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */
-#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
-#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */
-#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */
-
-#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */
-#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */
-#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */
-#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */
-
-/******************  Bit definition for SDIO_DCOUNT register  *****************/
-#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */
-
-/******************  Bit definition for SDIO_STA register  ********************/
-#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */
-#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */
-#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */
-#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */
-#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */
-#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */
-#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */
-#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */
-#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */
-#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */
-#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */
-#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */
-#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */
-#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */
-#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
-#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
-#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */
-#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */
-#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */
-#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */
-#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */
-#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */
-#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */
-#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */
-
-/*******************  Bit definition for SDIO_ICR register  *******************/
-#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */
-#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */
-#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */
-#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */
-#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */
-#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */
-#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */
-#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */
-#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */
-#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */
-#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */
-#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */
-#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */
-
-/******************  Bit definition for SDIO_MASK register  *******************/
-#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */
-#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */
-#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */
-#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */
-#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */
-#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */
-#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */
-#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */
-#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */
-#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */
-#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */
-#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */
-#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */
-#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */
-#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */
-#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */
-#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */
-#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */
-#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */
-#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */
-#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */
-#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */
-#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */
-#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */
-
-/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
-#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */
-
-/******************  Bit definition for SDIO_FIFO register  *******************/
-#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */
-
-/******************************************************************************/
-/*                                                                            */
-/*                                   USB Device FS                            */
-/*                                                                            */
-/******************************************************************************/
-
-/*!< Endpoint-specific registers */
-/*******************  Bit definition for USB_EP0R register  *******************/
-#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP1R register  *******************/
-#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP2R register  *******************/
-#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP3R register  *******************/
-#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP4R register  *******************/
-#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP5R register  *******************/
-#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP6R register  *******************/
-#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*******************  Bit definition for USB_EP7R register  *******************/
-#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */
-
-#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
-#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */
-#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */
-#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */
-
-#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */
-#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */
-#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */
-
-#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */
-
-#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
-#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */
-#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */
-
-/*!< Common registers */
-/*******************  Bit definition for USB_CNTR register  *******************/
-#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!< Force USB Reset */
-#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!< Power down */
-#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!< Low-power mode */
-#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!< Force suspend */
-#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!< Resume request */
-#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!< Expected Start Of Frame Interrupt Mask */
-#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!< Start Of Frame Interrupt Mask */
-#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!< RESET Interrupt Mask */
-#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!< Suspend mode Interrupt Mask */
-#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!< Wakeup Interrupt Mask */
-#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!< Error Interrupt Mask */
-#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun Interrupt Mask */
-#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!< Correct Transfer Interrupt Mask */
-
-/*******************  Bit definition for USB_ISTR register  *******************/
-#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!< Endpoint Identifier */
-#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!< Direction of transaction */
-#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!< Expected Start Of Frame */
-#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!< Start Of Frame */
-#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!< USB RESET request */
-#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!< Suspend mode request */
-#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!< Wake up */
-#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!< Error */
-#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun */
-#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!< Correct Transfer */
-
-/*******************  Bit definition for USB_FNR register  ********************/
-#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!< Frame Number */
-#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!< Lost SOF */
-#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!< Locked */
-#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!< Receive Data - Line Status */
-#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!< Receive Data + Line Status */
-
-/******************  Bit definition for USB_DADDR register  *******************/
-#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!< ADD[6:0] bits (Device Address) */
-#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!< Bit 0 */
-#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!< Bit 1 */
-#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!< Bit 2 */
-#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!< Bit 3 */
-#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!< Bit 4 */
-#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!< Bit 5 */
-#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!< Bit 6 */
-
-#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!< Enable Function */
-
-/******************  Bit definition for USB_BTABLE register  ******************/    
-#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!< Buffer Table */
-
-/*!< Buffer descriptor table */
-/*****************  Bit definition for USB_ADDR0_TX register  *****************/
-#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */
-
-/*****************  Bit definition for USB_ADDR1_TX register  *****************/
-#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
-
-/*****************  Bit definition for USB_ADDR2_TX register  *****************/
-#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */
-
-/*****************  Bit definition for USB_ADDR3_TX register  *****************/
-#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */
-
-/*****************  Bit definition for USB_ADDR4_TX register  *****************/
-#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */
-
-/*****************  Bit definition for USB_ADDR5_TX register  *****************/
-#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */
-
-/*****************  Bit definition for USB_ADDR6_TX register  *****************/
-#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */
-
-/*****************  Bit definition for USB_ADDR7_TX register  *****************/
-#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */
-
-/*----------------------------------------------------------------------------*/
-
-/*****************  Bit definition for USB_COUNT0_TX register  ****************/
-#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */
-
-/*****************  Bit definition for USB_COUNT1_TX register  ****************/
-#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
-
-/*****************  Bit definition for USB_COUNT2_TX register  ****************/
-#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */
-
-/*****************  Bit definition for USB_COUNT3_TX register  ****************/
-#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */
-
-/*****************  Bit definition for USB_COUNT4_TX register  ****************/
-#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */
-
-/*****************  Bit definition for USB_COUNT5_TX register  ****************/
-#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */
-
-/*****************  Bit definition for USB_COUNT6_TX register  ****************/
-#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */
-
-/*****************  Bit definition for USB_COUNT7_TX register  ****************/
-#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */
-
-/*----------------------------------------------------------------------------*/
-
-/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
-#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */
-
-/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
-#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */
-
-/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
-#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
-
-/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
-#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
-
-/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
-#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */
-
-/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
-#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */
-
-/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
-#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */
-
-/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
-#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */
-
-/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
-#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */
-
-/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
-#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */
-
-/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
-#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */
-
-/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
-#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */
-
-/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
-#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */
-
-/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
-#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */
-
-/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
-#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */
-
-/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
-#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */
-
-/*----------------------------------------------------------------------------*/
-
-/*****************  Bit definition for USB_ADDR0_RX register  *****************/
-#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */
-
-/*****************  Bit definition for USB_ADDR1_RX register  *****************/
-#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
-
-/*****************  Bit definition for USB_ADDR2_RX register  *****************/
-#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */
-
-/*****************  Bit definition for USB_ADDR3_RX register  *****************/
-#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */
-
-/*****************  Bit definition for USB_ADDR4_RX register  *****************/
-#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */
-
-/*****************  Bit definition for USB_ADDR5_RX register  *****************/
-#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */
-
-/*****************  Bit definition for USB_ADDR6_RX register  *****************/
-#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */
-
-/*****************  Bit definition for USB_ADDR7_RX register  *****************/
-#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */
-
-/*----------------------------------------------------------------------------*/
-
-/*****************  Bit definition for USB_COUNT0_RX register  ****************/
-#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT1_RX register  ****************/
-#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT2_RX register  ****************/
-#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT3_RX register  ****************/
-#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT4_RX register  ****************/
-#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT5_RX register  ****************/
-#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT6_RX register  ****************/
-#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*****************  Bit definition for USB_COUNT7_RX register  ****************/
-#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
-
-#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
-#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
-#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
-#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
-#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
-#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
-
-#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
-
-/*----------------------------------------------------------------------------*/
-
-/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
-#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
-#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
-#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
-#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
-#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
-#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
-#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
-#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
-#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
-#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
-#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
-#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
-#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
-#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
-#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
-
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
-#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
-
-#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
-
-/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
-#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
-
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
-#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
-
-#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
-
-/******************************************************************************/
-/*                                                                            */
-/*                         Controller Area Network                            */
-/*                                                                            */
-/******************************************************************************/
-
-/*!< CAN control and status registers */
-/*******************  Bit definition for CAN_MCR register  ********************/
-#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!< Initialization Request */
-#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!< Sleep Mode Request */
-#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!< Transmit FIFO Priority */
-#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!< Receive FIFO Locked Mode */
-#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!< No Automatic Retransmission */
-#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!< Automatic Wakeup Mode */
-#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!< Automatic Bus-Off Management */
-#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!< Time Triggered Communication Mode */
-#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!< CAN software master reset */
-
-/*******************  Bit definition for CAN_MSR register  ********************/
-#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!< Initialization Acknowledge */
-#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!< Sleep Acknowledge */
-#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!< Error Interrupt */
-#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!< Wakeup Interrupt */
-#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!< Sleep Acknowledge Interrupt */
-#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!< Transmit Mode */
-#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!< Receive Mode */
-#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!< Last Sample Point */
-#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!< CAN Rx Signal */
-
-/*******************  Bit definition for CAN_TSR register  ********************/
-#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!< Request Completed Mailbox0 */
-#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!< Transmission OK of Mailbox0 */
-#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!< Arbitration Lost for Mailbox0 */
-#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!< Transmission Error of Mailbox0 */
-#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!< Abort Request for Mailbox0 */
-#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!< Request Completed Mailbox1 */
-#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!< Transmission OK of Mailbox1 */
-#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!< Arbitration Lost for Mailbox1 */
-#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!< Transmission Error of Mailbox1 */
-#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!< Abort Request for Mailbox 1 */
-#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!< Request Completed Mailbox2 */
-#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!< Transmission OK of Mailbox 2 */
-#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!< Arbitration Lost for mailbox 2 */
-#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!< Transmission Error of Mailbox 2 */
-#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!< Abort Request for Mailbox 2 */
-#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!< Mailbox Code */
-
-#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!< TME[2:0] bits */
-#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!< Transmit Mailbox 0 Empty */
-#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!< Transmit Mailbox 1 Empty */
-#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!< Transmit Mailbox 2 Empty */
-
-#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!< LOW[2:0] bits */
-#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!< Lowest Priority Flag for Mailbox 0 */
-#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!< Lowest Priority Flag for Mailbox 1 */
-#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!< Lowest Priority Flag for Mailbox 2 */
-
-/*******************  Bit definition for CAN_RF0R register  *******************/
-#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!< FIFO 0 Message Pending */
-#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!< FIFO 0 Full */
-#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!< FIFO 0 Overrun */
-#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!< Release FIFO 0 Output Mailbox */
-
-/*******************  Bit definition for CAN_RF1R register  *******************/
-#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!< FIFO 1 Message Pending */
-#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!< FIFO 1 Full */
-#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!< FIFO 1 Overrun */
-#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!< Release FIFO 1 Output Mailbox */
-
-/********************  Bit definition for CAN_IER register  *******************/
-#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Empty Interrupt Enable */
-#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!< FIFO Message Pending Interrupt Enable */
-#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!< FIFO Full Interrupt Enable */
-#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!< FIFO Overrun Interrupt Enable */
-#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!< FIFO Message Pending Interrupt Enable */
-#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!< FIFO Full Interrupt Enable */
-#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!< FIFO Overrun Interrupt Enable */
-#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!< Error Warning Interrupt Enable */
-#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!< Error Passive Interrupt Enable */
-#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!< Bus-Off Interrupt Enable */
-#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!< Last Error Code Interrupt Enable */
-#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!< Error Interrupt Enable */
-#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!< Wakeup Interrupt Enable */
-#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!< Sleep Interrupt Enable */
-
-/********************  Bit definition for CAN_ESR register  *******************/
-#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!< Error Warning Flag */
-#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!< Error Passive Flag */
-#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!< Bus-Off Flag */
-
-#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!< LEC[2:0] bits (Last Error Code) */
-#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!< Bit 0 */
-#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!< Bit 1 */
-#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!< Bit 2 */
-
-#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!< Least significant byte of the 9-bit Transmit Error Counter */
-#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!< Receive Error Counter */
-
-/*******************  Bit definition for CAN_BTR register  ********************/
-#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!< Baud Rate Prescaler */
-#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!< Time Segment 1 */
-#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!< Time Segment 2 */
-#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!< Resynchronization Jump Width */
-#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!< Loop Back Mode (Debug) */
-#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!< Silent Mode */
-
-/*!< Mailbox registers */
-/******************  Bit definition for CAN_TI0R register  ********************/
-#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
-#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
-#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
-#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
-#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
-
-/******************  Bit definition for CAN_TDT0R register  *******************/
-#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
-#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
-#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
-
-/******************  Bit definition for CAN_TDL0R register  *******************/
-#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
-#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
-#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
-#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
-
-/******************  Bit definition for CAN_TDH0R register  *******************/
-#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
-#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
-#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
-#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
-
-/*******************  Bit definition for CAN_TI1R register  *******************/
-#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
-#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
-#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
-#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
-#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
-
-/*******************  Bit definition for CAN_TDT1R register  ******************/
-#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
-#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
-#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
-
-/*******************  Bit definition for CAN_TDL1R register  ******************/
-#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
-#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
-#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
-#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
-
-/*******************  Bit definition for CAN_TDH1R register  ******************/
-#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
-#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
-#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
-#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
-
-/*******************  Bit definition for CAN_TI2R register  *******************/
-#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */
-#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
-#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
-#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
-#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
-
-/*******************  Bit definition for CAN_TDT2R register  ******************/  
-#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
-#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */
-#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
-
-/*******************  Bit definition for CAN_TDL2R register  ******************/
-#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
-#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
-#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
-#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
-
-/*******************  Bit definition for CAN_TDH2R register  ******************/
-#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
-#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
-#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
-#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
-
-/*******************  Bit definition for CAN_RI0R register  *******************/
-#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
-#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
-#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */
-#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
-
-/*******************  Bit definition for CAN_RDT0R register  ******************/
-#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
-#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
-#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
-
-/*******************  Bit definition for CAN_RDL0R register  ******************/
-#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
-#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
-#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
-#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
-
-/*******************  Bit definition for CAN_RDH0R register  ******************/
-#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
-#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
-#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
-#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
-
-/*******************  Bit definition for CAN_RI1R register  *******************/
-#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */
-#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */
-#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */
-#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */
-
-/*******************  Bit definition for CAN_RDT1R register  ******************/
-#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */
-#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */
-#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */
-
-/*******************  Bit definition for CAN_RDL1R register  ******************/
-#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */
-#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */
-#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */
-#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */
-
-/*******************  Bit definition for CAN_RDH1R register  ******************/
-#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */
-#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */
-#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */
-#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */
-
-/*!< CAN filter registers */
-/*******************  Bit definition for CAN_FMR register  ********************/
-#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!< Filter Init Mode */
-
-/*******************  Bit definition for CAN_FM1R register  *******************/
-#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!< Filter Mode */
-#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!< Filter Init Mode bit 0 */
-#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!< Filter Init Mode bit 1 */
-#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!< Filter Init Mode bit 2 */
-#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!< Filter Init Mode bit 3 */
-#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!< Filter Init Mode bit 4 */
-#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!< Filter Init Mode bit 5 */
-#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!< Filter Init Mode bit 6 */
-#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!< Filter Init Mode bit 7 */
-#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!< Filter Init Mode bit 8 */
-#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!< Filter Init Mode bit 9 */
-#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!< Filter Init Mode bit 10 */
-#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!< Filter Init Mode bit 11 */
-#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!< Filter Init Mode bit 12 */
-#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!< Filter Init Mode bit 13 */
-
-/*******************  Bit definition for CAN_FS1R register  *******************/
-#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!< Filter Scale Configuration */
-#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!< Filter Scale Configuration bit 0 */
-#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!< Filter Scale Configuration bit 1 */
-#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!< Filter Scale Configuration bit 2 */
-#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!< Filter Scale Configuration bit 3 */
-#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!< Filter Scale Configuration bit 4 */
-#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!< Filter Scale Configuration bit 5 */
-#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!< Filter Scale Configuration bit 6 */
-#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!< Filter Scale Configuration bit 7 */
-#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!< Filter Scale Configuration bit 8 */
-#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!< Filter Scale Configuration bit 9 */
-#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!< Filter Scale Configuration bit 10 */
-#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!< Filter Scale Configuration bit 11 */
-#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!< Filter Scale Configuration bit 12 */
-#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!< Filter Scale Configuration bit 13 */
-
-/******************  Bit definition for CAN_FFA1R register  *******************/
-#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!< Filter FIFO Assignment */
-#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!< Filter FIFO Assignment for Filter 0 */
-#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!< Filter FIFO Assignment for Filter 1 */
-#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!< Filter FIFO Assignment for Filter 2 */
-#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!< Filter FIFO Assignment for Filter 3 */
-#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!< Filter FIFO Assignment for Filter 4 */
-#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!< Filter FIFO Assignment for Filter 5 */
-#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!< Filter FIFO Assignment for Filter 6 */
-#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!< Filter FIFO Assignment for Filter 7 */
-#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!< Filter FIFO Assignment for Filter 8 */
-#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!< Filter FIFO Assignment for Filter 9 */
-#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!< Filter FIFO Assignment for Filter 10 */
-#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!< Filter FIFO Assignment for Filter 11 */
-#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!< Filter FIFO Assignment for Filter 12 */
-#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!< Filter FIFO Assignment for Filter 13 */
-
-/*******************  Bit definition for CAN_FA1R register  *******************/
-#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!< Filter Active */
-#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!< Filter 0 Active */
-#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!< Filter 1 Active */
-#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!< Filter 2 Active */
-#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!< Filter 3 Active */
-#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!< Filter 4 Active */
-#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!< Filter 5 Active */
-#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!< Filter 6 Active */
-#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!< Filter 7 Active */
-#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!< Filter 8 Active */
-#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!< Filter 9 Active */
-#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!< Filter 10 Active */
-#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!< Filter 11 Active */
-#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!< Filter 12 Active */
-#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!< Filter 13 Active */
-
-/*******************  Bit definition for CAN_F0R1 register  *******************/
-#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F1R1 register  *******************/
-#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F2R1 register  *******************/
-#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F3R1 register  *******************/
-#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F4R1 register  *******************/
-#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F5R1 register  *******************/
-#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F6R1 register  *******************/
-#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F7R1 register  *******************/
-#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F8R1 register  *******************/
-#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F9R1 register  *******************/
-#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F10R1 register  ******************/
-#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F11R1 register  ******************/
-#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F12R1 register  ******************/
-#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F13R1 register  ******************/
-#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F0R2 register  *******************/
-#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F1R2 register  *******************/
-#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F2R2 register  *******************/
-#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F3R2 register  *******************/
-#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F4R2 register  *******************/
-#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F5R2 register  *******************/
-#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F6R2 register  *******************/
-#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F7R2 register  *******************/
-#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F8R2 register  *******************/
-#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F9R2 register  *******************/
-#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F10R2 register  ******************/
-#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F11R2 register  ******************/
-#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F12R2 register  ******************/
-#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/*******************  Bit definition for CAN_F13R2 register  ******************/
-#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */
-#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */
-#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */
-#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */
-#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */
-#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */
-#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */
-#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */
-#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */
-#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */
-#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */
-#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */
-#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */
-#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */
-#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */
-#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */
-#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */
-#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */
-#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */
-#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */
-#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */
-#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */
-#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */
-#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */
-#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */
-#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */
-#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */
-#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */
-#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */
-#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */
-#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */
-#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */
-
-/******************************************************************************/
-/*                                                                            */
-/*                        Serial Peripheral Interface                         */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for SPI_CR1 register  ********************/
-#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
-#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
-#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
-
-#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
-#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
-#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
-#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
-
-#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
-#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
-#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
-#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
-#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
-#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */
-#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
-#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
-#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
-#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
-
-/*******************  Bit definition for SPI_CR2 register  ********************/
-#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */
-#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */
-#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */
-#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */
-#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */
-#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */
-
-/********************  Bit definition for SPI_SR register  ********************/
-#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */
-#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */
-#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */
-#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */
-#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */
-#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */
-#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */
-#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */
-
-/********************  Bit definition for SPI_DR register  ********************/
-#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
-
-/*******************  Bit definition for SPI_CRCPR register  ******************/
-#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
-
-/******************  Bit definition for SPI_RXCRCR register  ******************/
-#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
-
-/******************  Bit definition for SPI_TXCRCR register  ******************/
-#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
-
-/******************  Bit definition for SPI_I2SCFGR register  *****************/
-#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!< Channel length (number of bits per audio channel) */
-
-#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!< DATLEN[1:0] bits (Data length to be transferred) */
-#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!< Bit 0 */
-#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!< Bit 1 */
-
-#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!< steady state clock polarity */
-
-#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!< I2SSTD[1:0] bits (I2S standard selection) */
-#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!< Bit 0 */
-#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!< Bit 1 */
-
-#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!< PCM frame synchronization */
-
-#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!< I2SCFG[1:0] bits (I2S configuration mode) */
-#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!< Bit 0 */
-#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!< Bit 1 */
-
-#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!< I2S Enable */
-#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!< I2S mode selection */
-
-/******************  Bit definition for SPI_I2SPR register  *******************/
-#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!< I2S Linear prescaler */
-#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!< Odd factor for the prescaler */
-#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!< Master Clock Output Enable */
-
-/******************************************************************************/
-/*                                                                            */
-/*                      Inter-integrated Circuit Interface                    */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for I2C_CR1 register  ********************/
-#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */
-#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */
-#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */
-#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */
-#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */
-#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */
-#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */
-#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */
-#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */
-#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */
-#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */
-#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */
-#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */
-#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */
-
-/*******************  Bit definition for I2C_CR2 register  ********************/
-#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
-#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
-#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
-#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
-#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
-
-#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */
-#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */
-#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */
-#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */
-#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */
-
-/*******************  Bit definition for I2C_OAR1 register  *******************/
-#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */
-#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */
-
-#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */
-#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */
-#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */
-#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */
-#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */
-#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */
-#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */
-#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */
-
-#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */
-
-/*******************  Bit definition for I2C_OAR2 register  *******************/
-#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */
-#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */
-
-/********************  Bit definition for I2C_DR register  ********************/
-#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */
-
-/*******************  Bit definition for I2C_SR1 register  ********************/
-#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */
-#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */
-#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */
-#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */
-#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */
-#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */
-#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */
-#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */
-#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */
-#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */
-#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */
-#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */
-#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */
-#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */
-
-/*******************  Bit definition for I2C_SR2 register  ********************/
-#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */
-#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */
-#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */
-#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */
-#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */
-#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */
-#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */
-#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */
-
-/*******************  Bit definition for I2C_CCR register  ********************/
-#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */
-#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */
-#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */
-
-/******************  Bit definition for I2C_TRISE register  *******************/
-#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
-
-/******************************************************************************/
-/*                                                                            */
-/*         Universal Synchronous Asynchronous Receiver Transmitter            */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for USART_SR register  *******************/
-#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */
-#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */
-#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */
-#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */
-#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */
-#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */
-#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */
-#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */
-#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */
-#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */
-
-/*******************  Bit definition for USART_DR register  *******************/
-#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */
-
-/******************  Bit definition for USART_BRR register  *******************/
-#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */
-#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */
-
-/******************  Bit definition for USART_CR1 register  *******************/
-#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */
-#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */
-#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */
-#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */
-#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */
-#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */
-#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */
-#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */
-#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */
-#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */
-#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */
-#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */
-#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */
-#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */
-#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< USART Oversmapling 8-bits */
-
-/******************  Bit definition for USART_CR2 register  *******************/
-#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */
-#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */
-#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */
-#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */
-#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */
-#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */
-#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */
-
-#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
-#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
-#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
-
-#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */
-
-/******************  Bit definition for USART_CR3 register  *******************/
-#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */
-#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */
-#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */
-#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */
-#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */
-#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */
-#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */
-#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */
-#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */
-#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */
-#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */
-#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One Bit method */
-
-/******************  Bit definition for USART_GTPR register  ******************/
-#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */
-#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
-#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
-#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */
-#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */
-#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */
-#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */
-#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */
-#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */
-
-#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */
-
-/******************************************************************************/
-/*                                                                            */
-/*                                 Debug MCU                                  */
-/*                                                                            */
-/******************************************************************************/
-
-/****************  Bit definition for DBGMCU_IDCODE register  *****************/
-#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
-
-#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
-#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
-#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
-#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
-#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
-#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
-#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
-#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
-#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
-#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
-#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
-#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
-#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
-#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
-#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
-#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
-#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
-
-/******************  Bit definition for DBGMCU_CR register  *******************/
-#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */
-#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
-#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
-#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */
-
-#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
-#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */
-#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
-
-#define  DBGMCU_CR_DBG_IWDG_STOP             ((uint32_t)0x00000100)        /*!< Debug Independent Watchdog stopped when Core is halted */
-#define  DBGMCU_CR_DBG_WWDG_STOP             ((uint32_t)0x00000200)        /*!< Debug Window Watchdog stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM1_STOP             ((uint32_t)0x00000400)        /*!< TIM1 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM2_STOP             ((uint32_t)0x00000800)        /*!< TIM2 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM3_STOP             ((uint32_t)0x00001000)        /*!< TIM3 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM4_STOP             ((uint32_t)0x00002000)        /*!< TIM4 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_CAN1_STOP             ((uint32_t)0x00004000)        /*!< Debug CAN1 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)        /*!< SMBUS timeout mode stopped when Core is halted */
-#define  DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)        /*!< SMBUS timeout mode stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM8_STOP             ((uint32_t)0x00020000)        /*!< TIM8 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM5_STOP             ((uint32_t)0x00040000)        /*!< TIM5 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM6_STOP             ((uint32_t)0x00080000)        /*!< TIM6 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_TIM7_STOP             ((uint32_t)0x00100000)        /*!< TIM7 counter stopped when core is halted */
-#define  DBGMCU_CR_DBG_CAN2_STOP             ((uint32_t)0x00200000)        /*!< Debug CAN2 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM15_STOP            ((uint32_t)0x00400000)        /*!< Debug TIM15 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM16_STOP            ((uint32_t)0x00800000)        /*!< Debug TIM16 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM17_STOP            ((uint32_t)0x01000000)        /*!< Debug TIM17 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM12_STOP            ((uint32_t)0x02000000)        /*!< Debug TIM12 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM13_STOP            ((uint32_t)0x04000000)        /*!< Debug TIM13 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM14_STOP            ((uint32_t)0x08000000)        /*!< Debug TIM14 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM9_STOP             ((uint32_t)0x10000000)        /*!< Debug TIM9 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM10_STOP            ((uint32_t)0x20000000)        /*!< Debug TIM10 stopped when Core is halted */
-#define  DBGMCU_CR_DBG_TIM11_STOP            ((uint32_t)0x40000000)        /*!< Debug TIM11 stopped when Core is halted */
-
-/******************************************************************************/
-/*                                                                            */
-/*                      FLASH and Option Bytes Registers                      */
-/*                                                                            */
-/******************************************************************************/
-
-/*******************  Bit definition for FLASH_ACR register  ******************/
-#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */
-#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x00)               /*!< Bit 0 */
-#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x01)               /*!< Bit 0 */
-#define  FLASH_ACR_LATENCY_2                 ((uint8_t)0x02)               /*!< Bit 1 */
-
-#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */
-#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */
-#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)               /*!< Prefetch Buffer Status */
-
-/******************  Bit definition for FLASH_KEYR register  ******************/
-#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
-
-/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
-#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
-
-/******************  Bit definition for FLASH_SR register  *******************/
-#define  FLASH_SR_BSY                        ((uint8_t)0x01)               /*!< Busy */
-#define  FLASH_SR_PGERR                      ((uint8_t)0x04)               /*!< Programming Error */
-#define  FLASH_SR_WRPRTERR                   ((uint8_t)0x10)               /*!< Write Protection Error */
-#define  FLASH_SR_EOP                        ((uint8_t)0x20)               /*!< End of operation */
-
-/*******************  Bit definition for FLASH_CR register  *******************/
-#define  FLASH_CR_PG                         ((uint16_t)0x0001)            /*!< Programming */
-#define  FLASH_CR_PER                        ((uint16_t)0x0002)            /*!< Page Erase */
-#define  FLASH_CR_MER                        ((uint16_t)0x0004)            /*!< Mass Erase */
-#define  FLASH_CR_OPTPG                      ((uint16_t)0x0010)            /*!< Option Byte Programming */
-#define  FLASH_CR_OPTER                      ((uint16_t)0x0020)            /*!< Option Byte Erase */
-#define  FLASH_CR_STRT                       ((uint16_t)0x0040)            /*!< Start */
-#define  FLASH_CR_LOCK                       ((uint16_t)0x0080)            /*!< Lock */
-#define  FLASH_CR_OPTWRE                     ((uint16_t)0x0200)            /*!< Option Bytes Write Enable */
-#define  FLASH_CR_ERRIE                      ((uint16_t)0x0400)            /*!< Error Interrupt Enable */
-#define  FLASH_CR_EOPIE                      ((uint16_t)0x1000)            /*!< End of operation interrupt enable */
-
-/*******************  Bit definition for FLASH_AR register  *******************/
-#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
-
-/******************  Bit definition for FLASH_OBR register  *******************/
-#define  FLASH_OBR_OPTERR                    ((uint16_t)0x0001)            /*!< Option Byte Error */
-#define  FLASH_OBR_RDPRT                     ((uint16_t)0x0002)            /*!< Read protection */
-
-#define  FLASH_OBR_USER                      ((uint16_t)0x03FC)            /*!< User Option Bytes */
-#define  FLASH_OBR_WDG_SW                    ((uint16_t)0x0004)            /*!< WDG_SW */
-#define  FLASH_OBR_nRST_STOP                 ((uint16_t)0x0008)            /*!< nRST_STOP */
-#define  FLASH_OBR_nRST_STDBY                ((uint16_t)0x0010)            /*!< nRST_STDBY */
-#define  FLASH_OBR_BFB2                      ((uint16_t)0x0020)            /*!< BFB2 */
-
-/******************  Bit definition for FLASH_WRPR register  ******************/
-#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */
-
-/*----------------------------------------------------------------------------*/
-
-/******************  Bit definition for FLASH_RDP register  *******************/
-#define  FLASH_RDP_RDP                       ((uint32_t)0x000000FF)        /*!< Read protection option byte */
-#define  FLASH_RDP_nRDP                      ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
-
-/******************  Bit definition for FLASH_USER register  ******************/
-#define  FLASH_USER_USER                     ((uint32_t)0x00FF0000)        /*!< User option byte */
-#define  FLASH_USER_nUSER                    ((uint32_t)0xFF000000)        /*!< User complemented option byte */
-
-/******************  Bit definition for FLASH_Data0 register  *****************/
-#define  FLASH_Data0_Data0                   ((uint32_t)0x000000FF)        /*!< User data storage option byte */
-#define  FLASH_Data0_nData0                  ((uint32_t)0x0000FF00)        /*!< User data storage complemented option byte */
-
-/******************  Bit definition for FLASH_Data1 register  *****************/
-#define  FLASH_Data1_Data1                   ((uint32_t)0x00FF0000)        /*!< User data storage option byte */
-#define  FLASH_Data1_nData1                  ((uint32_t)0xFF000000)        /*!< User data storage complemented option byte */
-
-/******************  Bit definition for FLASH_WRP0 register  ******************/
-#define  FLASH_WRP0_WRP0                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
-#define  FLASH_WRP0_nWRP0                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
-
-/******************  Bit definition for FLASH_WRP1 register  ******************/
-#define  FLASH_WRP1_WRP1                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
-#define  FLASH_WRP1_nWRP1                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
-
-/******************  Bit definition for FLASH_WRP2 register  ******************/
-#define  FLASH_WRP2_WRP2                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
-#define  FLASH_WRP2_nWRP2                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
-
-/******************  Bit definition for FLASH_WRP3 register  ******************/
-#define  FLASH_WRP3_WRP3                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
-#define  FLASH_WRP3_nWRP3                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
-
-#ifdef STM32F10X_CL
-/******************************************************************************/
-/*                Ethernet MAC Registers bits definitions                     */
-/******************************************************************************/
-/* Bit definition for Ethernet MAC Control Register register */
-#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
-#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
-#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
-  #define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
-  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
-  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
-  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
-  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */        
-  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
-  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
-  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */              
-#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
-#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
-#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
-#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
-#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
-#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
-#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
-#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
-#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
-                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
-  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
-  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
-  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
-  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
-#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
-#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
-#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
-
-/* Bit definition for Ethernet MAC Frame Filter Register */
-#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */ 
-#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */ 
-#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */ 
-#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */ 
-#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
-  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
-  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
-  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */ 
-#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */ 
-#define ETH_MACFFR_PAM 	  ((uint32_t)0x00000010)  /* Pass all mutlicast */ 
-#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */ 
-#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */ 
-#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
-#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
-
-/* Bit definition for Ethernet MAC Hash Table High Register */
-#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
-
-/* Bit definition for Ethernet MAC Hash Table Low Register */
-#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
-
-/* Bit definition for Ethernet MAC MII Address Register */
-#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */ 
-#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */ 
-#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */ 
-  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-72 MHz; MDC clock= HCLK/42 */
-  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
-  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
-#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */ 
-#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */ 
-  
-/* Bit definition for Ethernet MAC MII Data Register */
-#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
-
-/* Bit definition for Ethernet MAC Flow Control Register */
-#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
-#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
-#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
-  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
-  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
-  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
-  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */      
-#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
-#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
-#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
-#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
-
-/* Bit definition for Ethernet MAC VLAN Tag Register */
-#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
-#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
-
-/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
-#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
-/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
-   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
-/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
-   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
-   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
-   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
-   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
-                              RSVD - Filter1 Command - RSVD - Filter0 Command
-   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
-   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
-   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
-
-/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
-#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
-#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
-#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
-#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
-#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
-#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
-#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
-
-/* Bit definition for Ethernet MAC Status Register */
-#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
-#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
-#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
-#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
-#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
-
-/* Bit definition for Ethernet MAC Interrupt Mask Register */
-#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
-#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
-
-/* Bit definition for Ethernet MAC Address0 High Register */
-#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
-
-/* Bit definition for Ethernet MAC Address0 Low Register */
-#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
-
-/* Bit definition for Ethernet MAC Address1 High Register */
-#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
-#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
-#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
-  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
-  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
-  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
-  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
-  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
-  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */ 
-#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
-
-/* Bit definition for Ethernet MAC Address1 Low Register */
-#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
-
-/* Bit definition for Ethernet MAC Address2 High Register */
-#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
-#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
-#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
-  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
-  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
-  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
-  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
-  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
-  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
-#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
-
-/* Bit definition for Ethernet MAC Address2 Low Register */
-#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
-
-/* Bit definition for Ethernet MAC Address3 High Register */
-#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
-#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
-#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
-  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
-  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
-  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
-  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
-  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
-  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
-#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
-
-/* Bit definition for Ethernet MAC Address3 Low Register */
-#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
-
-/******************************************************************************/
-/*                Ethernet MMC Registers bits definition                      */
-/******************************************************************************/
-
-/* Bit definition for Ethernet MMC Contol Register */
-#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
-#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
-#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
-#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
-
-/* Bit definition for Ethernet MMC Receive Interrupt Register */
-#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
-#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
-#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
-
-/* Bit definition for Ethernet MMC Transmit Interrupt Register */
-#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
-#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
-#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
-
-/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
-#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
-#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
-#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
-
-/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
-#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
-#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
-#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
-
-/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
-#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
-
-/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
-#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
-
-/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
-#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
-
-/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
-#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
-
-/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
-#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
-
-/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
-#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
-
-/******************************************************************************/
-/*               Ethernet PTP Registers bits definition                       */
-/******************************************************************************/
-
-/* Bit definition for Ethernet PTP Time Stamp Contol Register */
-#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
-#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
-#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
-#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
-#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
-#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
-
-/* Bit definition for Ethernet PTP Sub-Second Increment Register */
-#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
-
-/* Bit definition for Ethernet PTP Time Stamp High Register */
-#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
-
-/* Bit definition for Ethernet PTP Time Stamp Low Register */
-#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
-#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
-
-/* Bit definition for Ethernet PTP Time Stamp High Update Register */
-#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
-
-/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
-#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
-#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
-
-/* Bit definition for Ethernet PTP Time Stamp Addend Register */
-#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
-
-/* Bit definition for Ethernet PTP Target Time High Register */
-#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
-
-/* Bit definition for Ethernet PTP Target Time Low Register */
-#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
-
-/******************************************************************************/
-/*                 Ethernet DMA Registers bits definition                     */
-/******************************************************************************/
-
-/* Bit definition for Ethernet DMA Bus Mode Register */
-#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
-#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
-#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
-#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
-  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
-  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
-  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
-  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
-  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
-  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
-  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
-  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
-  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
-  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
-  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
-  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
-#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
-#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
-  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
-  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
-  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
-  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */  
-#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
-  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
-  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
-  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
-  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
-  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
-  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
-  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
-  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
-  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
-  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
-  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
-  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
-#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
-#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
-#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
-
-/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
-#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
-
-/* Bit definition for Ethernet DMA Receive Poll Demand Register */
-#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
-
-/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
-#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
-
-/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
-#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
-
-/* Bit definition for Ethernet DMA Status Register */
-#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
-#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
-#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
-#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
-  /* combination with EBS[2:0] for GetFlagStatus function */
-  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
-  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
-  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
-#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
-  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
-  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
-  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
-  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
-  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
-  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
-#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
-  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
-  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
-  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
-  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
-  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
-  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
-#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
-#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
-#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
-#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
-#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
-#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
-#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
-#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
-#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
-#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
-#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
-#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
-#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
-#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
-#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
-
-/* Bit definition for Ethernet DMA Operation Mode Register */
-#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
-#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
-#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
-#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
-#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
-#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
-  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
-  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
-  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
-  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
-  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
-  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
-  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
-  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
-#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
-#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
-#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
-#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
-  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
-  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
-  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
-  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
-#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
-#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
-
-/* Bit definition for Ethernet DMA Interrupt Enable Register */
-#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
-#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
-#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
-#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
-#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
-#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
-#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
-#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
-#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
-#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
-#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
-#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
-#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
-#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
-#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
-
-/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
-#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
-#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
-#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
-#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
-
-/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
-#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
-
-/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
-#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
-
-/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
-#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
-
-/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
-#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
-#endif /* STM32F10X_CL */
-
-/**
-  * @}
-  */
-
- /**
-  * @}
-  */ 
-
-#ifdef USE_STDPERIPH_DRIVER
-  #include "stm32f10x_conf.h"
-#endif
-
-/** @addtogroup Exported_macro
-  * @{
-  */
-
-#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
-
-#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
-
-#define READ_BIT(REG, BIT)    ((REG) & (BIT))
-
-#define CLEAR_REG(REG)        ((REG) = (0x0))
-
-#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
-
-#define READ_REG(REG)         ((REG))
-
-#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
-
-/**
-  * @}
-  */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_H */
-
-/**
-  * @}
-  */
-
-  /**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_adc.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_adc.c
deleted file mode 100644
index 8155dc9b3..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_adc.c
+++ /dev/null
@@ -1,1307 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_adc.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the ADC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_adc.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup ADC 
-  * @brief ADC driver modules
-  * @{
-  */
-
-/** @defgroup ADC_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Private_Defines
-  * @{
-  */
-
-/* ADC DISCNUM mask */
-#define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
-
-/* ADC DISCEN mask */
-#define CR1_DISCEN_Set              ((uint32_t)0x00000800)
-#define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
-
-/* ADC JAUTO mask */
-#define CR1_JAUTO_Set               ((uint32_t)0x00000400)
-#define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
-
-/* ADC JDISCEN mask */
-#define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
-#define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
-
-/* ADC AWDCH mask */
-#define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
-
-/* ADC Analog watchdog enable mode mask */
-#define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
-
-/* CR1 register Mask */
-#define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
-
-/* ADC ADON mask */
-#define CR2_ADON_Set                ((uint32_t)0x00000001)
-#define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
-
-/* ADC DMA mask */
-#define CR2_DMA_Set                 ((uint32_t)0x00000100)
-#define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
-
-/* ADC RSTCAL mask */
-#define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
-
-/* ADC CAL mask */
-#define CR2_CAL_Set                 ((uint32_t)0x00000004)
-
-/* ADC SWSTART mask */
-#define CR2_SWSTART_Set             ((uint32_t)0x00400000)
-
-/* ADC EXTTRIG mask */
-#define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
-#define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
-
-/* ADC Software start mask */
-#define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
-#define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
-
-/* ADC JEXTSEL mask */
-#define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
-
-/* ADC JEXTTRIG mask */
-#define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
-#define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
-
-/* ADC JSWSTART mask */
-#define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
-
-/* ADC injected software start mask */
-#define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
-#define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
-
-/* ADC TSPD mask */
-#define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
-#define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
-
-/* CR2 register Mask */
-#define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
-
-/* ADC SQx mask */
-#define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
-#define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
-#define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
-
-/* SQR1 register Mask */
-#define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
-
-/* ADC JSQx mask */
-#define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
-
-/* ADC JL mask */
-#define JSQR_JL_Set                 ((uint32_t)0x00300000)
-#define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
-
-/* ADC SMPx mask */
-#define SMPR1_SMP_Set               ((uint32_t)0x00000007)
-#define SMPR2_SMP_Set               ((uint32_t)0x00000007)
-
-/* ADC JDRx registers offset */
-#define JDR_Offset                  ((uint8_t)0x28)
-
-/* ADC1 DR register base address */
-#define DR_ADDRESS                  ((uint32_t)0x4001244C)
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval None
-  */
-void ADC_DeInit(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  
-  if (ADCx == ADC1)
-  {
-    /* Enable ADC1 reset state */
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
-    /* Release ADC1 from reset state */
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
-  }
-  else if (ADCx == ADC2)
-  {
-    /* Enable ADC2 reset state */
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
-    /* Release ADC2 from reset state */
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
-  }
-  else
-  {
-    if (ADCx == ADC3)
-    {
-      /* Enable ADC3 reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
-      /* Release ADC3 from reset state */
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
-    }
-  }
-}
-
-/**
-  * @brief  Initializes the ADCx peripheral according to the specified parameters
-  *         in the ADC_InitStruct.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
-  *         the configuration information for the specified ADC peripheral.
-  * @retval None
-  */
-void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
-{
-  uint32_t tmpreg1 = 0;
-  uint8_t tmpreg2 = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
-  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
-  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
-  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
-  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
-  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
-
-  /*---------------------------- ADCx CR1 Configuration -----------------*/
-  /* Get the ADCx CR1 value */
-  tmpreg1 = ADCx->CR1;
-  /* Clear DUALMOD and SCAN bits */
-  tmpreg1 &= CR1_CLEAR_Mask;
-  /* Configure ADCx: Dual mode and scan conversion mode */
-  /* Set DUALMOD bits according to ADC_Mode value */
-  /* Set SCAN bit according to ADC_ScanConvMode value */
-  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
-  /* Write to ADCx CR1 */
-  ADCx->CR1 = tmpreg1;
-
-  /*---------------------------- ADCx CR2 Configuration -----------------*/
-  /* Get the ADCx CR2 value */
-  tmpreg1 = ADCx->CR2;
-  /* Clear CONT, ALIGN and EXTSEL bits */
-  tmpreg1 &= CR2_CLEAR_Mask;
-  /* Configure ADCx: external trigger event and continuous conversion mode */
-  /* Set ALIGN bit according to ADC_DataAlign value */
-  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
-  /* Set CONT bit according to ADC_ContinuousConvMode value */
-  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
-            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
-  /* Write to ADCx CR2 */
-  ADCx->CR2 = tmpreg1;
-
-  /*---------------------------- ADCx SQR1 Configuration -----------------*/
-  /* Get the ADCx SQR1 value */
-  tmpreg1 = ADCx->SQR1;
-  /* Clear L bits */
-  tmpreg1 &= SQR1_CLEAR_Mask;
-  /* Configure ADCx: regular channel sequence length */
-  /* Set L bits according to ADC_NbrOfChannel value */
-  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
-  tmpreg1 |= (uint32_t)tmpreg2 << 20;
-  /* Write to ADCx SQR1 */
-  ADCx->SQR1 = tmpreg1;
-}
-
-/**
-  * @brief  Fills each ADC_InitStruct member with its default value.
-  * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
-  * @retval None
-  */
-void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
-{
-  /* Reset ADC init structure parameters values */
-  /* Initialize the ADC_Mode member */
-  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
-  /* initialize the ADC_ScanConvMode member */
-  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
-  /* Initialize the ADC_ContinuousConvMode member */
-  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
-  /* Initialize the ADC_ExternalTrigConv member */
-  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
-  /* Initialize the ADC_DataAlign member */
-  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
-  /* Initialize the ADC_NbrOfChannel member */
-  ADC_InitStruct->ADC_NbrOfChannel = 1;
-}
-
-/**
-  * @brief  Enables or disables the specified ADC peripheral.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the ADCx peripheral.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the ADON bit to wake up the ADC from power down mode */
-    ADCx->CR2 |= CR2_ADON_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC peripheral */
-    ADCx->CR2 &= CR2_ADON_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified ADC DMA request.
-  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
-  *   Note: ADC2 hasn't a DMA capability.
-  * @param  NewState: new state of the selected ADC DMA transfer.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_DMA_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC DMA request */
-    ADCx->CR2 |= CR2_DMA_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC DMA request */
-    ADCx->CR2 &= CR2_DMA_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified ADC interrupts.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
-  *   This parameter can be any combination of the following values:
-  *     @arg ADC_IT_EOC: End of conversion interrupt mask
-  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
-  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
-  * @param  NewState: new state of the specified ADC interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
-{
-  uint8_t itmask = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_ADC_IT(ADC_IT));
-  /* Get the ADC IT index */
-  itmask = (uint8_t)ADC_IT;
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC interrupts */
-    ADCx->CR1 |= itmask;
-  }
-  else
-  {
-    /* Disable the selected ADC interrupts */
-    ADCx->CR1 &= (~(uint32_t)itmask);
-  }
-}
-
-/**
-  * @brief  Resets the selected ADC calibration registers.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval None
-  */
-void ADC_ResetCalibration(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Resets the selected ADC calibration registers */  
-  ADCx->CR2 |= CR2_RSTCAL_Set;
-}
-
-/**
-  * @brief  Gets the selected ADC reset calibration registers status.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval The new state of ADC reset calibration registers (SET or RESET).
-  */
-FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Check the status of RSTCAL bit */
-  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
-  {
-    /* RSTCAL bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* RSTCAL bit is reset */
-    bitstatus = RESET;
-  }
-  /* Return the RSTCAL bit status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Starts the selected ADC calibration process.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval None
-  */
-void ADC_StartCalibration(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Enable the selected ADC calibration process */  
-  ADCx->CR2 |= CR2_CAL_Set;
-}
-
-/**
-  * @brief  Gets the selected ADC calibration status.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval The new state of ADC calibration (SET or RESET).
-  */
-FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Check the status of CAL bit */
-  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
-  {
-    /* CAL bit is set: calibration on going */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CAL bit is reset: end of calibration */
-    bitstatus = RESET;
-  }
-  /* Return the CAL bit status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Enables or disables the selected ADC software start conversion .
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC software start conversion.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion on external event and start the selected
-       ADC conversion */
-    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event and stop the selected
-       ADC conversion */
-    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
-  }
-}
-
-/**
-  * @brief  Gets the selected ADC Software start conversion Status.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval The new state of ADC software start conversion (SET or RESET).
-  */
-FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Check the status of SWSTART bit */
-  if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
-  {
-    /* SWSTART bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SWSTART bit is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SWSTART bit status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Configures the discontinuous mode for the selected ADC regular
-  *         group channel.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  Number: specifies the discontinuous mode regular channel
-  *         count value. This number must be between 1 and 8.
-  * @retval None
-  */
-void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
-{
-  uint32_t tmpreg1 = 0;
-  uint32_t tmpreg2 = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
-  /* Get the old register value */
-  tmpreg1 = ADCx->CR1;
-  /* Clear the old discontinuous mode channel count */
-  tmpreg1 &= CR1_DISCNUM_Reset;
-  /* Set the discontinuous mode channel count */
-  tmpreg2 = Number - 1;
-  tmpreg1 |= tmpreg2 << 13;
-  /* Store the new register value */
-  ADCx->CR1 = tmpreg1;
-}
-
-/**
-  * @brief  Enables or disables the discontinuous mode on regular group
-  *         channel for the specified ADC
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC discontinuous mode
-  *         on regular group channel.
-  *         This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC regular discontinuous mode */
-    ADCx->CR1 |= CR1_DISCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC regular discontinuous mode */
-    ADCx->CR1 &= CR1_DISCEN_Reset;
-  }
-}
-
-/**
-  * @brief  Configures for the selected ADC regular channel its corresponding
-  *         rank in the sequencer and its sample time.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_Channel: the ADC channel to configure. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_Channel_0: ADC Channel0 selected
-  *     @arg ADC_Channel_1: ADC Channel1 selected
-  *     @arg ADC_Channel_2: ADC Channel2 selected
-  *     @arg ADC_Channel_3: ADC Channel3 selected
-  *     @arg ADC_Channel_4: ADC Channel4 selected
-  *     @arg ADC_Channel_5: ADC Channel5 selected
-  *     @arg ADC_Channel_6: ADC Channel6 selected
-  *     @arg ADC_Channel_7: ADC Channel7 selected
-  *     @arg ADC_Channel_8: ADC Channel8 selected
-  *     @arg ADC_Channel_9: ADC Channel9 selected
-  *     @arg ADC_Channel_10: ADC Channel10 selected
-  *     @arg ADC_Channel_11: ADC Channel11 selected
-  *     @arg ADC_Channel_12: ADC Channel12 selected
-  *     @arg ADC_Channel_13: ADC Channel13 selected
-  *     @arg ADC_Channel_14: ADC Channel14 selected
-  *     @arg ADC_Channel_15: ADC Channel15 selected
-  *     @arg ADC_Channel_16: ADC Channel16 selected
-  *     @arg ADC_Channel_17: ADC Channel17 selected
-  * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
-  * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
-  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
-  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
-  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
-  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
-  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
-  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
-  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
-  * @retval None
-  */
-void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
-{
-  uint32_t tmpreg1 = 0, tmpreg2 = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  assert_param(IS_ADC_REGULAR_RANK(Rank));
-  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
-  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
-  if (ADC_Channel > ADC_Channel_9)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SMPR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
-    /* Clear the old channel sample time */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
-    /* Set the new channel sample time */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SMPR1 = tmpreg1;
-  }
-  else /* ADC_Channel include in ADC_Channel_[0..9] */
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SMPR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
-    /* Clear the old channel sample time */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
-    /* Set the new channel sample time */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SMPR2 = tmpreg1;
-  }
-  /* For Rank 1 to 6 */
-  if (Rank < 7)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SQR3;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SQR3 = tmpreg1;
-  }
-  /* For Rank 7 to 12 */
-  else if (Rank < 13)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SQR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SQR2 = tmpreg1;
-  }
-  /* For Rank 13 to 16 */
-  else
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SQR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
-    /* Clear the old SQx bits for the selected rank */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
-    /* Set the SQx bits for the selected rank */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SQR1 = tmpreg1;
-  }
-}
-
-/**
-  * @brief  Enables or disables the ADCx conversion through external trigger.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC external trigger start of conversion.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion on external event */
-    ADCx->CR2 |= CR2_EXTTRIG_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event */
-    ADCx->CR2 &= CR2_EXTTRIG_Reset;
-  }
-}
-
-/**
-  * @brief  Returns the last ADCx conversion result data for regular channel.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval The Data conversion value.
-  */
-uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Return the selected ADC conversion value */
-  return (uint16_t) ADCx->DR;
-}
-
-/**
-  * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
-  * @retval The Data conversion value.
-  */
-uint32_t ADC_GetDualModeConversionValue(void)
-{
-  /* Return the dual mode conversion value */
-  return (*(__IO uint32_t *) DR_ADDRESS);
-}
-
-/**
-  * @brief  Enables or disables the selected ADC automatic injected group
-  *         conversion after regular one.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC auto injected conversion
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC automatic injected group conversion */
-    ADCx->CR1 |= CR1_JAUTO_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC automatic injected group conversion */
-    ADCx->CR1 &= CR1_JAUTO_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the discontinuous mode for injected group
-  *         channel for the specified ADC
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC discontinuous mode
-  *         on injected group channel.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC injected discontinuous mode */
-    ADCx->CR1 |= CR1_JDISCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC injected discontinuous mode */
-    ADCx->CR1 &= CR1_JDISCEN_Reset;
-  }
-}
-
-/**
-  * @brief  Configures the ADCx external trigger for injected channels conversion.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
-  *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
-  *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
-  *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
-  *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
-  *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
-  *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
-  *                                                       capture compare4 event selected (for ADC1 and ADC2)                       
-  *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
-  *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)                         
-  *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
-  *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)                         
-  *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)                        
-  *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
-  *                                          by external trigger (for ADC1, ADC2 and ADC3)
-  * @retval None
-  */
-void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
-  /* Get the old register value */
-  tmpreg = ADCx->CR2;
-  /* Clear the old external event selection for injected group */
-  tmpreg &= CR2_JEXTSEL_Reset;
-  /* Set the external event selection for injected group */
-  tmpreg |= ADC_ExternalTrigInjecConv;
-  /* Store the new register value */
-  ADCx->CR2 = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the ADCx injected channels conversion through
-  *         external trigger
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC external trigger start of
-  *         injected conversion.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC external event selection for injected group */
-    ADCx->CR2 |= CR2_JEXTTRIG_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC external event selection for injected group */
-    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the selected ADC start of the injected 
-  *         channels conversion.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  NewState: new state of the selected ADC software start injected conversion.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected ADC conversion for injected group on external event and start the selected
-       ADC injected conversion */
-    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
-  }
-  else
-  {
-    /* Disable the selected ADC conversion on external event for injected group and stop the selected
-       ADC injected conversion */
-    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
-  }
-}
-
-/**
-  * @brief  Gets the selected ADC Software start injected conversion Status.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @retval The new state of ADC software start injected conversion (SET or RESET).
-  */
-FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  /* Check the status of JSWSTART bit */
-  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
-  {
-    /* JSWSTART bit is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* JSWSTART bit is reset */
-    bitstatus = RESET;
-  }
-  /* Return the JSWSTART bit status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Configures for the selected ADC injected channel its corresponding
-  *         rank in the sequencer and its sample time.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_Channel: the ADC channel to configure. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_Channel_0: ADC Channel0 selected
-  *     @arg ADC_Channel_1: ADC Channel1 selected
-  *     @arg ADC_Channel_2: ADC Channel2 selected
-  *     @arg ADC_Channel_3: ADC Channel3 selected
-  *     @arg ADC_Channel_4: ADC Channel4 selected
-  *     @arg ADC_Channel_5: ADC Channel5 selected
-  *     @arg ADC_Channel_6: ADC Channel6 selected
-  *     @arg ADC_Channel_7: ADC Channel7 selected
-  *     @arg ADC_Channel_8: ADC Channel8 selected
-  *     @arg ADC_Channel_9: ADC Channel9 selected
-  *     @arg ADC_Channel_10: ADC Channel10 selected
-  *     @arg ADC_Channel_11: ADC Channel11 selected
-  *     @arg ADC_Channel_12: ADC Channel12 selected
-  *     @arg ADC_Channel_13: ADC Channel13 selected
-  *     @arg ADC_Channel_14: ADC Channel14 selected
-  *     @arg ADC_Channel_15: ADC Channel15 selected
-  *     @arg ADC_Channel_16: ADC Channel16 selected
-  *     @arg ADC_Channel_17: ADC Channel17 selected
-  * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
-  * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
-  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
-  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
-  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
-  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
-  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
-  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
-  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
-  * @retval None
-  */
-void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
-{
-  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  assert_param(IS_ADC_INJECTED_RANK(Rank));
-  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
-  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
-  if (ADC_Channel > ADC_Channel_9)
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SMPR1;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
-    /* Clear the old channel sample time */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
-    /* Set the new channel sample time */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SMPR1 = tmpreg1;
-  }
-  else /* ADC_Channel include in ADC_Channel_[0..9] */
-  {
-    /* Get the old register value */
-    tmpreg1 = ADCx->SMPR2;
-    /* Calculate the mask to clear */
-    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
-    /* Clear the old channel sample time */
-    tmpreg1 &= ~tmpreg2;
-    /* Calculate the mask to set */
-    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
-    /* Set the new channel sample time */
-    tmpreg1 |= tmpreg2;
-    /* Store the new register value */
-    ADCx->SMPR2 = tmpreg1;
-  }
-  /* Rank configuration */
-  /* Get the old register value */
-  tmpreg1 = ADCx->JSQR;
-  /* Get JL value: Number = JL+1 */
-  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
-  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
-  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
-  /* Clear the old JSQx bits for the selected rank */
-  tmpreg1 &= ~tmpreg2;
-  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
-  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
-  /* Set the JSQx bits for the selected rank */
-  tmpreg1 |= tmpreg2;
-  /* Store the new register value */
-  ADCx->JSQR = tmpreg1;
-}
-
-/**
-  * @brief  Configures the sequencer length for injected channels
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  Length: The sequencer length. 
-  *   This parameter must be a number between 1 to 4.
-  * @retval None
-  */
-void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
-{
-  uint32_t tmpreg1 = 0;
-  uint32_t tmpreg2 = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_LENGTH(Length));
-  
-  /* Get the old register value */
-  tmpreg1 = ADCx->JSQR;
-  /* Clear the old injected sequnence lenght JL bits */
-  tmpreg1 &= JSQR_JL_Reset;
-  /* Set the injected sequnence lenght JL bits */
-  tmpreg2 = Length - 1; 
-  tmpreg1 |= tmpreg2 << 20;
-  /* Store the new register value */
-  ADCx->JSQR = tmpreg1;
-}
-
-/**
-  * @brief  Set the injected channels conversion value offset
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
-  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
-  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
-  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
-  * @param  Offset: the offset value for the selected ADC injected channel
-  *   This parameter must be a 12bit value.
-  * @retval None
-  */
-void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
-{
-  __IO uint32_t tmp = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
-  assert_param(IS_ADC_OFFSET(Offset));  
-  
-  tmp = (uint32_t)ADCx;
-  tmp += ADC_InjectedChannel;
-  
-  /* Set the selected injected channel data offset */
-  *(__IO uint32_t *) tmp = (uint32_t)Offset;
-}
-
-/**
-  * @brief  Returns the ADC injected channel conversion result
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_InjectedChannel: the converted ADC injected channel.
-  *   This parameter can be one of the following values:
-  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
-  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
-  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
-  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
-  * @retval The Data conversion value.
-  */
-uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
-{
-  __IO uint32_t tmp = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
-
-  tmp = (uint32_t)ADCx;
-  tmp += ADC_InjectedChannel + JDR_Offset;
-  
-  /* Returns the selected injected channel conversion data value */
-  return (uint16_t) (*(__IO uint32_t*)  tmp);   
-}
-
-/**
-  * @brief  Enables or disables the analog watchdog on single/all regular
-  *         or injected channels
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
-  *   This parameter can be one of the following values:
-  *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
-  *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
-  *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
-  *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
-  *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
-  *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
-  *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
-  * @retval None	  
-  */
-void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
-  /* Get the old register value */
-  tmpreg = ADCx->CR1;
-  /* Clear AWDEN, AWDENJ and AWDSGL bits */
-  tmpreg &= CR1_AWDMode_Reset;
-  /* Set the analog watchdog enable mode */
-  tmpreg |= ADC_AnalogWatchdog;
-  /* Store the new register value */
-  ADCx->CR1 = tmpreg;
-}
-
-/**
-  * @brief  Configures the high and low thresholds of the analog watchdog.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  HighThreshold: the ADC analog watchdog High threshold value.
-  *   This parameter must be a 12bit value.
-  * @param  LowThreshold: the ADC analog watchdog Low threshold value.
-  *   This parameter must be a 12bit value.
-  * @retval None
-  */
-void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
-                                        uint16_t LowThreshold)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_THRESHOLD(HighThreshold));
-  assert_param(IS_ADC_THRESHOLD(LowThreshold));
-  /* Set the ADCx high threshold */
-  ADCx->HTR = HighThreshold;
-  /* Set the ADCx low threshold */
-  ADCx->LTR = LowThreshold;
-}
-
-/**
-  * @brief  Configures the analog watchdog guarded single channel
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_Channel_0: ADC Channel0 selected
-  *     @arg ADC_Channel_1: ADC Channel1 selected
-  *     @arg ADC_Channel_2: ADC Channel2 selected
-  *     @arg ADC_Channel_3: ADC Channel3 selected
-  *     @arg ADC_Channel_4: ADC Channel4 selected
-  *     @arg ADC_Channel_5: ADC Channel5 selected
-  *     @arg ADC_Channel_6: ADC Channel6 selected
-  *     @arg ADC_Channel_7: ADC Channel7 selected
-  *     @arg ADC_Channel_8: ADC Channel8 selected
-  *     @arg ADC_Channel_9: ADC Channel9 selected
-  *     @arg ADC_Channel_10: ADC Channel10 selected
-  *     @arg ADC_Channel_11: ADC Channel11 selected
-  *     @arg ADC_Channel_12: ADC Channel12 selected
-  *     @arg ADC_Channel_13: ADC Channel13 selected
-  *     @arg ADC_Channel_14: ADC Channel14 selected
-  *     @arg ADC_Channel_15: ADC Channel15 selected
-  *     @arg ADC_Channel_16: ADC Channel16 selected
-  *     @arg ADC_Channel_17: ADC Channel17 selected
-  * @retval None
-  */
-void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CHANNEL(ADC_Channel));
-  /* Get the old register value */
-  tmpreg = ADCx->CR1;
-  /* Clear the Analog watchdog channel select bits */
-  tmpreg &= CR1_AWDCH_Reset;
-  /* Set the Analog watchdog channel */
-  tmpreg |= ADC_Channel;
-  /* Store the new register value */
-  ADCx->CR1 = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the temperature sensor and Vrefint channel.
-  * @param  NewState: new state of the temperature sensor.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void ADC_TempSensorVrefintCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the temperature sensor and Vrefint channel*/
-    ADC1->CR2 |= CR2_TSVREFE_Set;
-  }
-  else
-  {
-    /* Disable the temperature sensor and Vrefint channel*/
-    ADC1->CR2 &= CR2_TSVREFE_Reset;
-  }
-}
-
-/**
-  * @brief  Checks whether the specified ADC flag is set or not.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_FLAG: specifies the flag to check. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_FLAG_AWD: Analog watchdog flag
-  *     @arg ADC_FLAG_EOC: End of conversion flag
-  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
-  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
-  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
-  * @retval The new state of ADC_FLAG (SET or RESET).
-  */
-FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
-  /* Check the status of the specified ADC flag */
-  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
-  {
-    /* ADC_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* ADC_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the ADC_FLAG status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the ADCx's pending flags.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_FLAG: specifies the flag to clear. 
-  *   This parameter can be any combination of the following values:
-  *     @arg ADC_FLAG_AWD: Analog watchdog flag
-  *     @arg ADC_FLAG_EOC: End of conversion flag
-  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
-  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
-  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
-  * @retval None
-  */
-void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
-  /* Clear the selected ADC flags */
-  ADCx->SR = ~(uint32_t)ADC_FLAG;
-}
-
-/**
-  * @brief  Checks whether the specified ADC interrupt has occurred or not.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_IT: specifies the ADC interrupt source to check. 
-  *   This parameter can be one of the following values:
-  *     @arg ADC_IT_EOC: End of conversion interrupt mask
-  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
-  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
-  * @retval The new state of ADC_IT (SET or RESET).
-  */
-ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t itmask = 0, enablestatus = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_GET_IT(ADC_IT));
-  /* Get the ADC IT index */
-  itmask = ADC_IT >> 8;
-  /* Get the ADC_IT enable bit status */
-  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
-  /* Check the status of the specified ADC interrupt */
-  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
-  {
-    /* ADC_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* ADC_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the ADC_IT status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the ADCx's interrupt pending bits.
-  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
-  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg ADC_IT_EOC: End of conversion interrupt mask
-  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
-  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
-  * @retval None
-  */
-void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
-{
-  uint8_t itmask = 0;
-  /* Check the parameters */
-  assert_param(IS_ADC_ALL_PERIPH(ADCx));
-  assert_param(IS_ADC_IT(ADC_IT));
-  /* Get the ADC IT index */
-  itmask = (uint8_t)(ADC_IT >> 8);
-  /* Clear the selected ADC interrupt pending bits */
-  ADCx->SR = ~(uint32_t)itmask;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_adc.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_adc.h
deleted file mode 100644
index c465d3353..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_adc.h
+++ /dev/null
@@ -1,483 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_adc.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the ADC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_ADC_H
-#define __STM32F10x_ADC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup ADC
-  * @{
-  */
-
-/** @defgroup ADC_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  ADC Init structure definition  
-  */
-
-typedef struct
-{
-  uint32_t ADC_Mode;                      /*!< Configures the ADC to operate in independent or
-                                               dual mode. 
-                                               This parameter can be a value of @ref ADC_mode */
-
-  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion is performed in
-                                               Scan (multichannels) or Single (one channel) mode.
-                                               This parameter can be set to ENABLE or DISABLE */
-
-  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in
-                                               Continuous or Single mode.
-                                               This parameter can be set to ENABLE or DISABLE. */
-
-  uint32_t ADC_ExternalTrigConv;          /*!< Defines the external trigger used to start the analog
-                                               to digital conversion of regular channels. This parameter
-                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */
-
-  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data alignment is left or right.
-                                               This parameter can be a value of @ref ADC_data_align */
-
-  uint8_t ADC_NbrOfChannel;               /*!< Specifies the number of ADC channels that will be converted
-                                               using the sequencer for regular channel group.
-                                               This parameter must range from 1 to 16. */
-}ADC_InitTypeDef;
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Exported_Constants
-  * @{
-  */
-
-#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
-                                   ((PERIPH) == ADC2) || \
-                                   ((PERIPH) == ADC3))
-
-#define IS_ADC_DMA_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
-                                   ((PERIPH) == ADC3))
-
-/** @defgroup ADC_mode 
-  * @{
-  */
-
-#define ADC_Mode_Independent                       ((uint32_t)0x00000000)
-#define ADC_Mode_RegInjecSimult                    ((uint32_t)0x00010000)
-#define ADC_Mode_RegSimult_AlterTrig               ((uint32_t)0x00020000)
-#define ADC_Mode_InjecSimult_FastInterl            ((uint32_t)0x00030000)
-#define ADC_Mode_InjecSimult_SlowInterl            ((uint32_t)0x00040000)
-#define ADC_Mode_InjecSimult                       ((uint32_t)0x00050000)
-#define ADC_Mode_RegSimult                         ((uint32_t)0x00060000)
-#define ADC_Mode_FastInterl                        ((uint32_t)0x00070000)
-#define ADC_Mode_SlowInterl                        ((uint32_t)0x00080000)
-#define ADC_Mode_AlterTrig                         ((uint32_t)0x00090000)
-
-#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
-                           ((MODE) == ADC_Mode_RegInjecSimult) || \
-                           ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \
-                           ((MODE) == ADC_Mode_InjecSimult_FastInterl) || \
-                           ((MODE) == ADC_Mode_InjecSimult_SlowInterl) || \
-                           ((MODE) == ADC_Mode_InjecSimult) || \
-                           ((MODE) == ADC_Mode_RegSimult) || \
-                           ((MODE) == ADC_Mode_FastInterl) || \
-                           ((MODE) == ADC_Mode_SlowInterl) || \
-                           ((MODE) == ADC_Mode_AlterTrig))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion 
-  * @{
-  */
-
-#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x00020000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x00060000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x00080000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x000A0000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((uint32_t)0x000C0000) /*!< For ADC1 and ADC2 */
-
-#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x00040000) /*!< For ADC1, ADC2 and ADC3 */
-#define ADC_ExternalTrigConv_None                  ((uint32_t)0x000E0000) /*!< For ADC1, ADC2 and ADC3 */
-
-#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x00000000) /*!< For ADC3 only */
-#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x00020000) /*!< For ADC3 only */
-#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x00060000) /*!< For ADC3 only */
-#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x00080000) /*!< For ADC3 only */
-#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x000A0000) /*!< For ADC3 only */
-#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x000C0000) /*!< For ADC3 only */
-
-#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_None) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
-                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_data_align 
-  * @{
-  */
-
-#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
-#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
-#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
-                                  ((ALIGN) == ADC_DataAlign_Left))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_channels 
-  * @{
-  */
-
-#define ADC_Channel_0                               ((uint8_t)0x00)
-#define ADC_Channel_1                               ((uint8_t)0x01)
-#define ADC_Channel_2                               ((uint8_t)0x02)
-#define ADC_Channel_3                               ((uint8_t)0x03)
-#define ADC_Channel_4                               ((uint8_t)0x04)
-#define ADC_Channel_5                               ((uint8_t)0x05)
-#define ADC_Channel_6                               ((uint8_t)0x06)
-#define ADC_Channel_7                               ((uint8_t)0x07)
-#define ADC_Channel_8                               ((uint8_t)0x08)
-#define ADC_Channel_9                               ((uint8_t)0x09)
-#define ADC_Channel_10                              ((uint8_t)0x0A)
-#define ADC_Channel_11                              ((uint8_t)0x0B)
-#define ADC_Channel_12                              ((uint8_t)0x0C)
-#define ADC_Channel_13                              ((uint8_t)0x0D)
-#define ADC_Channel_14                              ((uint8_t)0x0E)
-#define ADC_Channel_15                              ((uint8_t)0x0F)
-#define ADC_Channel_16                              ((uint8_t)0x10)
-#define ADC_Channel_17                              ((uint8_t)0x11)
-
-#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)
-#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)
-
-#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \
-                                 ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \
-                                 ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \
-                                 ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) || \
-                                 ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) || \
-                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
-                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
-                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
-                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_sampling_time 
-  * @{
-  */
-
-#define ADC_SampleTime_1Cycles5                    ((uint8_t)0x00)
-#define ADC_SampleTime_7Cycles5                    ((uint8_t)0x01)
-#define ADC_SampleTime_13Cycles5                   ((uint8_t)0x02)
-#define ADC_SampleTime_28Cycles5                   ((uint8_t)0x03)
-#define ADC_SampleTime_41Cycles5                   ((uint8_t)0x04)
-#define ADC_SampleTime_55Cycles5                   ((uint8_t)0x05)
-#define ADC_SampleTime_71Cycles5                   ((uint8_t)0x06)
-#define ADC_SampleTime_239Cycles5                  ((uint8_t)0x07)
-#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_7Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_13Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_28Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_41Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_55Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_71Cycles5) || \
-                                  ((TIME) == ADC_SampleTime_239Cycles5))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion 
-  * @{
-  */
-
-#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00002000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00003000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00004000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00005000) /*!< For ADC1 and ADC2 */
-#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((uint32_t)0x00006000) /*!< For ADC1 and ADC2 */
-
-#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00000000) /*!< For ADC1, ADC2 and ADC3 */
-#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00001000) /*!< For ADC1, ADC2 and ADC3 */
-#define ADC_ExternalTrigInjecConv_None              ((uint32_t)0x00007000) /*!< For ADC1, ADC2 and ADC3 */
-
-#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00002000) /*!< For ADC3 only */
-#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x00003000) /*!< For ADC3 only */
-#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x00004000) /*!< For ADC3 only */
-#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x00005000) /*!< For ADC3 only */
-#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x00006000) /*!< For ADC3 only */
-
-#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
-                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_injected_channel_selection 
-  * @{
-  */
-
-#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
-#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
-#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
-#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
-#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
-                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
-                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
-                                          ((CHANNEL) == ADC_InjectedChannel_4))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_analog_watchdog_selection 
-  * @{
-  */
-
-#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
-#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
-#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
-#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
-#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
-#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
-#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
-
-#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
-                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
-                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
-                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
-                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
-                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
-                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_interrupts_definition 
-  * @{
-  */
-
-#define ADC_IT_EOC                                 ((uint16_t)0x0220)
-#define ADC_IT_AWD                                 ((uint16_t)0x0140)
-#define ADC_IT_JEOC                                ((uint16_t)0x0480)
-
-#define IS_ADC_IT(IT) ((((IT) & (uint16_t)0xF81F) == 0x00) && ((IT) != 0x00))
-
-#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
-                           ((IT) == ADC_IT_JEOC))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_flags_definition 
-  * @{
-  */
-
-#define ADC_FLAG_AWD                               ((uint8_t)0x01)
-#define ADC_FLAG_EOC                               ((uint8_t)0x02)
-#define ADC_FLAG_JEOC                              ((uint8_t)0x04)
-#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)
-#define ADC_FLAG_STRT                              ((uint8_t)0x10)
-#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xE0) == 0x00) && ((FLAG) != 0x00))
-#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
-                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
-                               ((FLAG) == ADC_FLAG_STRT))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_thresholds 
-  * @{
-  */
-
-#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_injected_offset 
-  * @{
-  */
-
-#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_injected_length 
-  * @{
-  */
-
-#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_injected_rank 
-  * @{
-  */
-
-#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
-
-/**
-  * @}
-  */ 
-
-
-/** @defgroup ADC_regular_length 
-  * @{
-  */
-
-#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
-/**
-  * @}
-  */
-
-/** @defgroup ADC_regular_rank 
-  * @{
-  */
-
-#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_regular_discontinuous_mode_number 
-  * @{
-  */
-
-#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup ADC_Exported_Functions
-  * @{
-  */
-
-void ADC_DeInit(ADC_TypeDef* ADCx);
-void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
-void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
-void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
-void ADC_ResetCalibration(ADC_TypeDef* ADCx);
-FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
-void ADC_StartCalibration(ADC_TypeDef* ADCx);
-FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
-void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
-void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
-void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
-void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
-uint32_t ADC_GetDualModeConversionValue(void);
-void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
-void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
-FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
-void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
-void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
-void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
-uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
-void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
-void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);
-void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
-void ADC_TempSensorVrefintCmd(FunctionalState NewState);
-FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
-void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
-ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
-void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_ADC_H */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_bkp.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_bkp.c
deleted file mode 100644
index 997eecc9e..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_bkp.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_bkp.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the BKP firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_bkp.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup BKP 
-  * @brief BKP driver modules
-  * @{
-  */
-
-/** @defgroup BKP_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Private_Defines
-  * @{
-  */
-
-/* ------------ BKP registers bit address in the alias region --------------- */
-#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)
-
-/* --- CR Register ----*/
-
-/* Alias word address of TPAL bit */
-#define CR_OFFSET         (BKP_OFFSET + 0x30)
-#define TPAL_BitNumber    0x01
-#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))
-
-/* Alias word address of TPE bit */
-#define TPE_BitNumber     0x00
-#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-
-/* Alias word address of TPIE bit */
-#define CSR_OFFSET        (BKP_OFFSET + 0x34)
-#define TPIE_BitNumber    0x02
-#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))
-
-/* Alias word address of TIF bit */
-#define TIF_BitNumber     0x09
-#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))
-
-/* Alias word address of TEF bit */
-#define TEF_BitNumber     0x08
-#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))
-
-/* ---------------------- BKP registers bit mask ------------------------ */
-
-/* RTCCR register bit mask */
-#define RTCCR_CAL_MASK    ((uint16_t)0xFF80)
-#define RTCCR_MASK        ((uint16_t)0xFC7F)
-
-/**
-  * @}
-  */ 
-
-
-/** @defgroup BKP_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the BKP peripheral registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void BKP_DeInit(void)
-{
-  RCC_BackupResetCmd(ENABLE);
-  RCC_BackupResetCmd(DISABLE);
-}
-
-/**
-  * @brief  Configures the Tamper Pin active level.
-  * @param  BKP_TamperPinLevel: specifies the Tamper Pin active level.
-  *   This parameter can be one of the following values:
-  *     @arg BKP_TamperPinLevel_High: Tamper pin active on high level
-  *     @arg BKP_TamperPinLevel_Low: Tamper pin active on low level
-  * @retval None
-  */
-void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel)
-{
-  /* Check the parameters */
-  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));
-  *(__IO uint32_t *) CR_TPAL_BB = BKP_TamperPinLevel;
-}
-
-/**
-  * @brief  Enables or disables the Tamper Pin activation.
-  * @param  NewState: new state of the Tamper Pin activation.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void BKP_TamperPinCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CR_TPE_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enables or disables the Tamper Pin Interrupt.
-  * @param  NewState: new state of the Tamper Pin Interrupt.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void BKP_ITConfig(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CSR_TPIE_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Select the RTC output source to output on the Tamper pin.
-  * @param  BKP_RTCOutputSource: specifies the RTC output source.
-  *   This parameter can be one of the following values:
-  *     @arg BKP_RTCOutputSource_None: no RTC output on the Tamper pin.
-  *     @arg BKP_RTCOutputSource_CalibClock: output the RTC clock with frequency
-  *                                          divided by 64 on the Tamper pin.
-  *     @arg BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse signal on
-  *                                     the Tamper pin.
-  *     @arg BKP_RTCOutputSource_Second: output the RTC Second pulse signal on
-  *                                      the Tamper pin.  
-  * @retval None
-  */
-void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource)
-{
-  uint16_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));
-  tmpreg = BKP->RTCCR;
-  /* Clear CCO, ASOE and ASOS bits */
-  tmpreg &= RTCCR_MASK;
-  
-  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */
-  tmpreg |= BKP_RTCOutputSource;
-  /* Store the new value */
-  BKP->RTCCR = tmpreg;
-}
-
-/**
-  * @brief  Sets RTC Clock Calibration value.
-  * @param  CalibrationValue: specifies the RTC Clock Calibration value.
-  *   This parameter must be a number between 0 and 0x7F.
-  * @retval None
-  */
-void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue)
-{
-  uint16_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));
-  tmpreg = BKP->RTCCR;
-  /* Clear CAL[6:0] bits */
-  tmpreg &= RTCCR_CAL_MASK;
-  /* Set CAL[6:0] bits according to CalibrationValue value */
-  tmpreg |= CalibrationValue;
-  /* Store the new value */
-  BKP->RTCCR = tmpreg;
-}
-
-/**
-  * @brief  Writes user data to the specified Data Backup Register.
-  * @param  BKP_DR: specifies the Data Backup Register.
-  *   This parameter can be BKP_DRx where x:[1, 42]
-  * @param  Data: data to write
-  * @retval None
-  */
-void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)
-{
-  __IO uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_BKP_DR(BKP_DR));
-
-  tmp = (uint32_t)BKP_BASE; 
-  tmp += BKP_DR;
-
-  *(__IO uint32_t *) tmp = Data;
-}
-
-/**
-  * @brief  Reads data from the specified Data Backup Register.
-  * @param  BKP_DR: specifies the Data Backup Register.
-  *   This parameter can be BKP_DRx where x:[1, 42]
-  * @retval The content of the specified Data Backup Register
-  */
-uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)
-{
-  __IO uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_BKP_DR(BKP_DR));
-
-  tmp = (uint32_t)BKP_BASE; 
-  tmp += BKP_DR;
-
-  return (*(__IO uint16_t *) tmp);
-}
-
-/**
-  * @brief  Checks whether the Tamper Pin Event flag is set or not.
-  * @param  None
-  * @retval The new state of the Tamper Pin Event flag (SET or RESET).
-  */
-FlagStatus BKP_GetFlagStatus(void)
-{
-  return (FlagStatus)(*(__IO uint32_t *) CSR_TEF_BB);
-}
-
-/**
-  * @brief  Clears Tamper Pin Event pending flag.
-  * @param  None
-  * @retval None
-  */
-void BKP_ClearFlag(void)
-{
-  /* Set CTE bit to clear Tamper Pin Event flag */
-  BKP->CSR |= BKP_CSR_CTE;
-}
-
-/**
-  * @brief  Checks whether the Tamper Pin Interrupt has occurred or not.
-  * @param  None
-  * @retval The new state of the Tamper Pin Interrupt (SET or RESET).
-  */
-ITStatus BKP_GetITStatus(void)
-{
-  return (ITStatus)(*(__IO uint32_t *) CSR_TIF_BB);
-}
-
-/**
-  * @brief  Clears Tamper Pin Interrupt pending bit.
-  * @param  None
-  * @retval None
-  */
-void BKP_ClearITPendingBit(void)
-{
-  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */
-  BKP->CSR |= BKP_CSR_CTI;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_bkp.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_bkp.h
deleted file mode 100644
index 275c5e1f1..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_bkp.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_bkp.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the BKP firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_BKP_H
-#define __STM32F10x_BKP_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup BKP
-  * @{
-  */
-
-/** @defgroup BKP_Exported_Types
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Exported_Constants
-  * @{
-  */
-
-/** @defgroup Tamper_Pin_active_level 
-  * @{
-  */
-
-#define BKP_TamperPinLevel_High           ((uint16_t)0x0000)
-#define BKP_TamperPinLevel_Low            ((uint16_t)0x0001)
-#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \
-                                        ((LEVEL) == BKP_TamperPinLevel_Low))
-/**
-  * @}
-  */
-
-/** @defgroup RTC_output_source_to_output_on_the_Tamper_pin 
-  * @{
-  */
-
-#define BKP_RTCOutputSource_None          ((uint16_t)0x0000)
-#define BKP_RTCOutputSource_CalibClock    ((uint16_t)0x0080)
-#define BKP_RTCOutputSource_Alarm         ((uint16_t)0x0100)
-#define BKP_RTCOutputSource_Second        ((uint16_t)0x0300)
-#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \
-                                          ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \
-                                          ((SOURCE) == BKP_RTCOutputSource_Alarm) || \
-                                          ((SOURCE) == BKP_RTCOutputSource_Second))
-/**
-  * @}
-  */
-
-/** @defgroup Data_Backup_Register 
-  * @{
-  */
-
-#define BKP_DR1                           ((uint16_t)0x0004)
-#define BKP_DR2                           ((uint16_t)0x0008)
-#define BKP_DR3                           ((uint16_t)0x000C)
-#define BKP_DR4                           ((uint16_t)0x0010)
-#define BKP_DR5                           ((uint16_t)0x0014)
-#define BKP_DR6                           ((uint16_t)0x0018)
-#define BKP_DR7                           ((uint16_t)0x001C)
-#define BKP_DR8                           ((uint16_t)0x0020)
-#define BKP_DR9                           ((uint16_t)0x0024)
-#define BKP_DR10                          ((uint16_t)0x0028)
-#define BKP_DR11                          ((uint16_t)0x0040)
-#define BKP_DR12                          ((uint16_t)0x0044)
-#define BKP_DR13                          ((uint16_t)0x0048)
-#define BKP_DR14                          ((uint16_t)0x004C)
-#define BKP_DR15                          ((uint16_t)0x0050)
-#define BKP_DR16                          ((uint16_t)0x0054)
-#define BKP_DR17                          ((uint16_t)0x0058)
-#define BKP_DR18                          ((uint16_t)0x005C)
-#define BKP_DR19                          ((uint16_t)0x0060)
-#define BKP_DR20                          ((uint16_t)0x0064)
-#define BKP_DR21                          ((uint16_t)0x0068)
-#define BKP_DR22                          ((uint16_t)0x006C)
-#define BKP_DR23                          ((uint16_t)0x0070)
-#define BKP_DR24                          ((uint16_t)0x0074)
-#define BKP_DR25                          ((uint16_t)0x0078)
-#define BKP_DR26                          ((uint16_t)0x007C)
-#define BKP_DR27                          ((uint16_t)0x0080)
-#define BKP_DR28                          ((uint16_t)0x0084)
-#define BKP_DR29                          ((uint16_t)0x0088)
-#define BKP_DR30                          ((uint16_t)0x008C)
-#define BKP_DR31                          ((uint16_t)0x0090)
-#define BKP_DR32                          ((uint16_t)0x0094)
-#define BKP_DR33                          ((uint16_t)0x0098)
-#define BKP_DR34                          ((uint16_t)0x009C)
-#define BKP_DR35                          ((uint16_t)0x00A0)
-#define BKP_DR36                          ((uint16_t)0x00A4)
-#define BKP_DR37                          ((uint16_t)0x00A8)
-#define BKP_DR38                          ((uint16_t)0x00AC)
-#define BKP_DR39                          ((uint16_t)0x00B0)
-#define BKP_DR40                          ((uint16_t)0x00B4)
-#define BKP_DR41                          ((uint16_t)0x00B8)
-#define BKP_DR42                          ((uint16_t)0x00BC)
-
-#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \
-                       ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \
-                       ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \
-                       ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) || \
-                       ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) || \
-                       ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) || \
-                       ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) || \
-                       ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) || \
-                       ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) || \
-                       ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) || \
-                       ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) || \
-                       ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) || \
-                       ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) || \
-                       ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
-
-#define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x7F)
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup BKP_Exported_Functions
-  * @{
-  */
-
-void BKP_DeInit(void);
-void BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel);
-void BKP_TamperPinCmd(FunctionalState NewState);
-void BKP_ITConfig(FunctionalState NewState);
-void BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource);
-void BKP_SetRTCCalibrationValue(uint8_t CalibrationValue);
-void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data);
-uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR);
-FlagStatus BKP_GetFlagStatus(void);
-void BKP_ClearFlag(void);
-ITStatus BKP_GetITStatus(void);
-void BKP_ClearITPendingBit(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_BKP_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_can.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_can.c
deleted file mode 100644
index ec8e0498b..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_can.c
+++ /dev/null
@@ -1,1415 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_can.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the CAN firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_can.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup CAN 
-  * @brief CAN driver modules
-  * @{
-  */ 
-
-/** @defgroup CAN_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Private_Defines
-  * @{
-  */
-
-/* CAN Master Control Register bits */
-
-#define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */
-
-/* CAN Mailbox Transmit Request */
-#define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */
-
-/* CAN Filter Master Register bits */
-#define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */
-
-/* Time out for INAK bit */
-#define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)
-/* Time out for SLAK bit */
-#define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)
-
-
-
-/* Flags in TSR register */
-#define CAN_FLAGS_TSR              ((uint32_t)0x08000000) 
-/* Flags in RF1R register */
-#define CAN_FLAGS_RF1R             ((uint32_t)0x04000000) 
-/* Flags in RF0R register */
-#define CAN_FLAGS_RF0R             ((uint32_t)0x02000000) 
-/* Flags in MSR register */
-#define CAN_FLAGS_MSR              ((uint32_t)0x01000000) 
-/* Flags in ESR register */
-#define CAN_FLAGS_ESR              ((uint32_t)0x00F00000) 
-
-/* Mailboxes definition */
-#define CAN_TXMAILBOX_0                   ((uint8_t)0x00)
-#define CAN_TXMAILBOX_1                   ((uint8_t)0x01)
-#define CAN_TXMAILBOX_2                   ((uint8_t)0x02) 
-
-
-
-#define CAN_MODE_MASK              ((uint32_t) 0x00000003)
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Private_FunctionPrototypes
-  * @{
-  */
-
-static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the CAN peripheral registers to their default reset values.
-  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
-  * @retval None.
-  */
-void CAN_DeInit(CAN_TypeDef* CANx)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
- 
-  if (CANx == CAN1)
-  {
-    /* Enable CAN1 reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
-    /* Release CAN1 from reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
-  }
-  else
-  {  
-    /* Enable CAN2 reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
-    /* Release CAN2 from reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
-  }
-}
-
-/**
-  * @brief  Initializes the CAN peripheral according to the specified
-  *         parameters in the CAN_InitStruct.
-  * @param  CANx:           where x can be 1 or 2 to to select the CAN 
-  *                         peripheral.
-  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
-  *                         contains the configuration information for the 
-  *                         CAN peripheral.
-  * @retval Constant indicates initialization succeed which will be 
-  *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
-  */
-uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
-{
-  uint8_t InitStatus = CAN_InitStatus_Failed;
-  uint32_t wait_ack = 0x00000000;
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
-  assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
-  assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
-  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
-  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
-  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
-
-  /* Exit from sleep mode */
-  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
-
-  /* Request initialisation */
-  CANx->MCR |= CAN_MCR_INRQ ;
-
-  /* Wait the acknowledge */
-  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
-  {
-    wait_ack++;
-  }
-
-  /* Check acknowledge */
-  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
-  {
-    InitStatus = CAN_InitStatus_Failed;
-  }
-  else 
-  {
-    /* Set the time triggered communication mode */
-    if (CAN_InitStruct->CAN_TTCM == ENABLE)
-    {
-      CANx->MCR |= CAN_MCR_TTCM;
-    }
-    else
-    {
-      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
-    }
-
-    /* Set the automatic bus-off management */
-    if (CAN_InitStruct->CAN_ABOM == ENABLE)
-    {
-      CANx->MCR |= CAN_MCR_ABOM;
-    }
-    else
-    {
-      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
-    }
-
-    /* Set the automatic wake-up mode */
-    if (CAN_InitStruct->CAN_AWUM == ENABLE)
-    {
-      CANx->MCR |= CAN_MCR_AWUM;
-    }
-    else
-    {
-      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
-    }
-
-    /* Set the no automatic retransmission */
-    if (CAN_InitStruct->CAN_NART == ENABLE)
-    {
-      CANx->MCR |= CAN_MCR_NART;
-    }
-    else
-    {
-      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
-    }
-
-    /* Set the receive FIFO locked mode */
-    if (CAN_InitStruct->CAN_RFLM == ENABLE)
-    {
-      CANx->MCR |= CAN_MCR_RFLM;
-    }
-    else
-    {
-      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
-    }
-
-    /* Set the transmit FIFO priority */
-    if (CAN_InitStruct->CAN_TXFP == ENABLE)
-    {
-      CANx->MCR |= CAN_MCR_TXFP;
-    }
-    else
-    {
-      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
-    }
-
-    /* Set the bit timing register */
-    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
-                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
-                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
-                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
-               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
-
-    /* Request leave initialisation */
-    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
-
-   /* Wait the acknowledge */
-   wait_ack = 0;
-
-   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
-   {
-     wait_ack++;
-   }
-
-    /* ...and check acknowledged */
-    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
-    {
-      InitStatus = CAN_InitStatus_Failed;
-    }
-    else
-    {
-      InitStatus = CAN_InitStatus_Success ;
-    }
-  }
-
-  /* At this step, return the status of initialization */
-  return InitStatus;
-}
-
-/**
-  * @brief  Initializes the CAN peripheral according to the specified
-  *         parameters in the CAN_FilterInitStruct.
-  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
-  *                               structure that contains the configuration 
-  *                               information.
-  * @retval None.
-  */
-void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
-{
-  uint32_t filter_number_bit_pos = 0;
-  /* Check the parameters */
-  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
-  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
-  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
-  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
-  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
-
-  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
-
-  /* Initialisation mode for the filter */
-  CAN1->FMR |= FMR_FINIT;
-
-  /* Filter Deactivation */
-  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
-
-  /* Filter Scale */
-  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
-  {
-    /* 16-bit scale for the filter */
-    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
-
-    /* First 16-bit identifier and First 16-bit mask */
-    /* Or First 16-bit identifier and Second 16-bit identifier */
-    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
-    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
-        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
-
-    /* Second 16-bit identifier and Second 16-bit mask */
-    /* Or Third 16-bit identifier and Fourth 16-bit identifier */
-    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
-    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
-        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
-  }
-
-  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
-  {
-    /* 32-bit scale for the filter */
-    CAN1->FS1R |= filter_number_bit_pos;
-    /* 32-bit identifier or First 32-bit identifier */
-    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
-    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
-        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
-    /* 32-bit mask or Second 32-bit identifier */
-    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
-    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
-        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
-  }
-
-  /* Filter Mode */
-  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
-  {
-    /*Id/Mask mode for the filter*/
-    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
-  }
-  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
-  {
-    /*Identifier list mode for the filter*/
-    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
-  }
-
-  /* Filter FIFO assignment */
-  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
-  {
-    /* FIFO 0 assignation for the filter */
-    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
-  }
-
-  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
-  {
-    /* FIFO 1 assignation for the filter */
-    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
-  }
-  
-  /* Filter activation */
-  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
-  {
-    CAN1->FA1R |= filter_number_bit_pos;
-  }
-
-  /* Leave the initialisation mode for the filter */
-  CAN1->FMR &= ~FMR_FINIT;
-}
-
-/**
-  * @brief  Fills each CAN_InitStruct member with its default value.
-  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
-  *                         will be initialized.
-  * @retval None.
-  */
-void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
-{
-  /* Reset CAN init structure parameters values */
-  
-  /* Initialize the time triggered communication mode */
-  CAN_InitStruct->CAN_TTCM = DISABLE;
-  
-  /* Initialize the automatic bus-off management */
-  CAN_InitStruct->CAN_ABOM = DISABLE;
-  
-  /* Initialize the automatic wake-up mode */
-  CAN_InitStruct->CAN_AWUM = DISABLE;
-  
-  /* Initialize the no automatic retransmission */
-  CAN_InitStruct->CAN_NART = DISABLE;
-  
-  /* Initialize the receive FIFO locked mode */
-  CAN_InitStruct->CAN_RFLM = DISABLE;
-  
-  /* Initialize the transmit FIFO priority */
-  CAN_InitStruct->CAN_TXFP = DISABLE;
-  
-  /* Initialize the CAN_Mode member */
-  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
-  
-  /* Initialize the CAN_SJW member */
-  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
-  
-  /* Initialize the CAN_BS1 member */
-  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
-  
-  /* Initialize the CAN_BS2 member */
-  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
-  
-  /* Initialize the CAN_Prescaler member */
-  CAN_InitStruct->CAN_Prescaler = 1;
-}
-
-/**
-  * @brief  Select the start bank filter for slave CAN.
-  * @note   This function applies only to STM32 Connectivity line devices.
-  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
-  * @retval None.
-  */
-void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
-  
-  /* Enter Initialisation mode for the filter */
-  CAN1->FMR |= FMR_FINIT;
-  
-  /* Select the start slave bank */
-  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
-  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
-  
-  /* Leave Initialisation mode for the filter */
-  CAN1->FMR &= ~FMR_FINIT;
-}
-
-/**
-  * @brief  Enables or disables the DBG Freeze for CAN.
-  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  NewState: new state of the CAN peripheral. This parameter can 
-  *                   be: ENABLE or DISABLE.
-  * @retval None.
-  */
-void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable Debug Freeze  */
-    CANx->MCR |= MCR_DBF;
-  }
-  else
-  {
-    /* Disable Debug Freeze */
-    CANx->MCR &= ~MCR_DBF;
-  }
-}
-
-
-/**
-  * @brief  Enables or disabes the CAN Time TriggerOperation communication mode.
-  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  NewState : Mode new state , can be one of @ref FunctionalState.
-  * @note   when enabled, Time stamp (TIME[15:0]) value is sent in the last 
-  *         two data bytes of the 8-byte message: TIME[7:0] in data byte 6 
-  *         and TIME[15:8] in data byte 7 
-  * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
-  *         sent over the CAN bus.  
-  * @retval None
-  */
-void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the TTCM mode */
-    CANx->MCR |= CAN_MCR_TTCM;
-
-    /* Set TGT bits */
-    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
-    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
-    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
-  }
-  else
-  {
-    /* Disable the TTCM mode */
-    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
-
-    /* Reset TGT bits */
-    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
-    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
-    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
-  }
-}
-/**
-  * @brief  Initiates the transmission of a message.
-  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN
-  *                    DLC and CAN data.
-  * @retval The number of the mailbox that is used for transmission
-  *                    or CAN_TxStatus_NoMailBox if there is no empty mailbox.
-  */
-uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
-{
-  uint8_t transmit_mailbox = 0;
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
-  assert_param(IS_CAN_RTR(TxMessage->RTR));
-  assert_param(IS_CAN_DLC(TxMessage->DLC));
-
-  /* Select one empty transmit mailbox */
-  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
-  {
-    transmit_mailbox = 0;
-  }
-  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
-  {
-    transmit_mailbox = 1;
-  }
-  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
-  {
-    transmit_mailbox = 2;
-  }
-  else
-  {
-    transmit_mailbox = CAN_TxStatus_NoMailBox;
-  }
-
-  if (transmit_mailbox != CAN_TxStatus_NoMailBox)
-  {
-    /* Set up the Id */
-    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
-    if (TxMessage->IDE == CAN_Id_Standard)
-    {
-      assert_param(IS_CAN_STDID(TxMessage->StdId));  
-      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
-                                                  TxMessage->RTR);
-    }
-    else
-    {
-      assert_param(IS_CAN_EXTID(TxMessage->ExtId));
-      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
-                                                  TxMessage->IDE | \
-                                                  TxMessage->RTR);
-    }
-    
-    /* Set up the DLC */
-    TxMessage->DLC &= (uint8_t)0x0000000F;
-    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
-    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
-
-    /* Set up the data field */
-    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
-                                             ((uint32_t)TxMessage->Data[2] << 16) |
-                                             ((uint32_t)TxMessage->Data[1] << 8) | 
-                                             ((uint32_t)TxMessage->Data[0]));
-    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
-                                             ((uint32_t)TxMessage->Data[6] << 16) |
-                                             ((uint32_t)TxMessage->Data[5] << 8) |
-                                             ((uint32_t)TxMessage->Data[4]));
-    /* Request transmission */
-    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
-  }
-  return transmit_mailbox;
-}
-
-/**
-  * @brief  Checks the transmission of a message.
-  * @param  CANx:            where x can be 1 or 2 to to select the 
-  *                          CAN peripheral.
-  * @param  TransmitMailbox: the number of the mailbox that is used for 
-  *                          transmission.
-  * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, CAN_TxStatus_Failed 
-  *         in an other case.
-  */
-uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
-{
-  uint32_t state = 0;
-
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
- 
-  switch (TransmitMailbox)
-  {
-    case (CAN_TXMAILBOX_0): 
-      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
-      break;
-    case (CAN_TXMAILBOX_1): 
-      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
-      break;
-    case (CAN_TXMAILBOX_2): 
-      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
-      break;
-    default:
-      state = CAN_TxStatus_Failed;
-      break;
-  }
-  switch (state)
-  {
-      /* transmit pending  */
-    case (0x0): state = CAN_TxStatus_Pending;
-      break;
-      /* transmit failed  */
-     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
-      break;
-     case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
-      break;
-     case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
-      break;
-      /* transmit succeeded  */
-    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
-      break;
-    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
-      break;
-    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
-      break;
-    default: state = CAN_TxStatus_Failed;
-      break;
-  }
-  return (uint8_t) state;
-}
-
-/**
-  * @brief  Cancels a transmit request.
-  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral. 
-  * @param  Mailbox:  Mailbox number.
-  * @retval None.
-  */
-void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
-  /* abort transmission */
-  switch (Mailbox)
-  {
-    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
-      break;
-    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
-      break;
-    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
-      break;
-    default:
-      break;
-  }
-}
-
-
-/**
-  * @brief  Receives a message.
-  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
-  * @param  RxMessage:  pointer to a structure receive message which contains 
-  *                     CAN Id, CAN DLC, CAN datas and FMI number.
-  * @retval None.
-  */
-void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_FIFO(FIFONumber));
-  /* Get the Id */
-  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
-  if (RxMessage->IDE == CAN_Id_Standard)
-  {
-    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
-  }
-  else
-  {
-    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
-  }
-  
-  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
-  /* Get the DLC */
-  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
-  /* Get the FMI */
-  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
-  /* Get the data field */
-  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
-  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
-  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
-  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
-  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
-  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
-  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
-  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
-  /* Release the FIFO */
-  /* Release FIFO0 */
-  if (FIFONumber == CAN_FIFO0)
-  {
-    CANx->RF0R |= CAN_RF0R_RFOM0;
-  }
-  /* Release FIFO1 */
-  else /* FIFONumber == CAN_FIFO1 */
-  {
-    CANx->RF1R |= CAN_RF1R_RFOM1;
-  }
-}
-
-/**
-  * @brief  Releases the specified FIFO.
-  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral. 
-  * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
-  * @retval None.
-  */
-void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_FIFO(FIFONumber));
-  /* Release FIFO0 */
-  if (FIFONumber == CAN_FIFO0)
-  {
-    CANx->RF0R |= CAN_RF0R_RFOM0;
-  }
-  /* Release FIFO1 */
-  else /* FIFONumber == CAN_FIFO1 */
-  {
-    CANx->RF1R |= CAN_RF1R_RFOM1;
-  }
-}
-
-/**
-  * @brief  Returns the number of pending messages.
-  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
-  * @retval NbMessage : which is the number of pending message.
-  */
-uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
-{
-  uint8_t message_pending=0;
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_FIFO(FIFONumber));
-  if (FIFONumber == CAN_FIFO0)
-  {
-    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
-  }
-  else if (FIFONumber == CAN_FIFO1)
-  {
-    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
-  }
-  else
-  {
-    message_pending = 0;
-  }
-  return message_pending;
-}
-
-
-/**
-  * @brief   Select the CAN Operation mode.
-  * @param CAN_OperatingMode : CAN Operating Mode. This parameter can be one 
-  *                            of @ref CAN_OperatingMode_TypeDef enumeration.
-  * @retval status of the requested mode which can be 
-  *         - CAN_ModeStatus_Failed    CAN failed entering the specific mode 
-  *         - CAN_ModeStatus_Success   CAN Succeed entering the specific mode 
-
-  */
-uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
-{
-  uint8_t status = CAN_ModeStatus_Failed;
-  
-  /* Timeout for INAK or also for SLAK bits*/
-  uint32_t timeout = INAK_TIMEOUT; 
-
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
-
-  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
-  {
-    /* Request initialisation */
-    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
-
-    /* Wait the acknowledge */
-    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
-    {
-      timeout--;
-    }
-    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
-    {
-      status = CAN_ModeStatus_Failed;
-    }
-    else
-    {
-      status = CAN_ModeStatus_Success;
-    }
-  }
-  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
-  {
-    /* Request leave initialisation and sleep mode  and enter Normal mode */
-    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
-
-    /* Wait the acknowledge */
-    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
-    {
-      timeout--;
-    }
-    if ((CANx->MSR & CAN_MODE_MASK) != 0)
-    {
-      status = CAN_ModeStatus_Failed;
-    }
-    else
-    {
-      status = CAN_ModeStatus_Success;
-    }
-  }
-  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
-  {
-    /* Request Sleep mode */
-    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
-
-    /* Wait the acknowledge */
-    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
-    {
-      timeout--;
-    }
-    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
-    {
-      status = CAN_ModeStatus_Failed;
-    }
-    else
-    {
-      status = CAN_ModeStatus_Success;
-    }
-  }
-  else
-  {
-    status = CAN_ModeStatus_Failed;
-  }
-
-  return  (uint8_t) status;
-}
-
-/**
-  * @brief  Enters the low power mode.
-  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
-  * @retval status: CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed in an 
-  *                 other case.
-  */
-uint8_t CAN_Sleep(CAN_TypeDef* CANx)
-{
-  uint8_t sleepstatus = CAN_Sleep_Failed;
-  
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-    
-  /* Request Sleep mode */
-   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
-   
-  /* Sleep mode status */
-  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
-  {
-    /* Sleep mode not entered */
-    sleepstatus =  CAN_Sleep_Ok;
-  }
-  /* return sleep mode status */
-   return (uint8_t)sleepstatus;
-}
-
-/**
-  * @brief  Wakes the CAN up.
-  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
-  * @retval status:  CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed in an 
-  *                  other case.
-  */
-uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
-{
-  uint32_t wait_slak = SLAK_TIMEOUT;
-  uint8_t wakeupstatus = CAN_WakeUp_Failed;
-  
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-    
-  /* Wake up request */
-  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
-    
-  /* Sleep mode status */
-  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
-  {
-   wait_slak--;
-  }
-  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
-  {
-   /* wake up done : Sleep mode exited */
-    wakeupstatus = CAN_WakeUp_Ok;
-  }
-  /* return wakeup status */
-  return (uint8_t)wakeupstatus;
-}
-
-
-/**
-  * @brief  Returns the CANx's last error code (LEC).
-  * @param  CANx:          where x can be 1 or 2 to to select the CAN peripheral.  
-  * @retval CAN_ErrorCode: specifies the Error code : 
-  *                        - CAN_ERRORCODE_NoErr            No Error  
-  *                        - CAN_ERRORCODE_StuffErr         Stuff Error
-  *                        - CAN_ERRORCODE_FormErr          Form Error
-  *                        - CAN_ERRORCODE_ACKErr           Acknowledgment Error
-  *                        - CAN_ERRORCODE_BitRecessiveErr  Bit Recessive Error
-  *                        - CAN_ERRORCODE_BitDominantErr   Bit Dominant Error
-  *                        - CAN_ERRORCODE_CRCErr           CRC Error
-  *                        - CAN_ERRORCODE_SoftwareSetErr   Software Set Error  
-  */
- 
-uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
-{
-  uint8_t errorcode=0;
-  
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  
-  /* Get the error code*/
-  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
-  
-  /* Return the error code*/
-  return errorcode;
-}
-/**
-  * @brief  Returns the CANx Receive Error Counter (REC).
-  * @note   In case of an error during reception, this counter is incremented 
-  *         by 1 or by 8 depending on the error condition as defined by the CAN 
-  *         standard. After every successful reception, the counter is 
-  *         decremented by 1 or reset to 120 if its value was higher than 128. 
-  *         When the counter value exceeds 127, the CAN controller enters the 
-  *         error passive state.  
-  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
-  * @retval CAN Receive Error Counter. 
-  */
-uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
-{
-  uint8_t counter=0;
-  
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  
-  /* Get the Receive Error Counter*/
-  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
-  
-  /* Return the Receive Error Counter*/
-  return counter;
-}
-
-
-/**
-  * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
-  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.  
-  * @retval LSB of the 9-bit CAN Transmit Error Counter. 
-  */
-uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
-{
-  uint8_t counter=0;
-  
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  
-  /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
-  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
-  
-  /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
-  return counter;
-}
-
-
-/**
-  * @brief  Enables or disables the specified CANx interrupts.
-  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
-  *                 This parameter can be: 
-  *                 - CAN_IT_TME, 
-  *                 - CAN_IT_FMP0, 
-  *                 - CAN_IT_FF0,
-  *                 - CAN_IT_FOV0, 
-  *                 - CAN_IT_FMP1, 
-  *                 - CAN_IT_FF1,
-  *                 - CAN_IT_FOV1, 
-  *                 - CAN_IT_EWG, 
-  *                 - CAN_IT_EPV,
-  *                 - CAN_IT_LEC, 
-  *                 - CAN_IT_ERR, 
-  *                 - CAN_IT_WKU or 
-  *                 - CAN_IT_SLK.
-  * @param  NewState: new state of the CAN interrupts.
-  *                   This parameter can be: ENABLE or DISABLE.
-  * @retval None.
-  */
-void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_IT(CAN_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected CANx interrupt */
-    CANx->IER |= CAN_IT;
-  }
-  else
-  {
-    /* Disable the selected CANx interrupt */
-    CANx->IER &= ~CAN_IT;
-  }
-}
-/**
-  * @brief  Checks whether the specified CAN flag is set or not.
-  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  CAN_FLAG: specifies the flag to check.
-  *                   This parameter can be one of the following flags: 
-  *                  - CAN_FLAG_EWG
-  *                  - CAN_FLAG_EPV 
-  *                  - CAN_FLAG_BOF
-  *                  - CAN_FLAG_RQCP0
-  *                  - CAN_FLAG_RQCP1
-  *                  - CAN_FLAG_RQCP2
-  *                  - CAN_FLAG_FMP1   
-  *                  - CAN_FLAG_FF1       
-  *                  - CAN_FLAG_FOV1   
-  *                  - CAN_FLAG_FMP0   
-  *                  - CAN_FLAG_FF0       
-  *                  - CAN_FLAG_FOV0   
-  *                  - CAN_FLAG_WKU 
-  *                  - CAN_FLAG_SLAK  
-  *                  - CAN_FLAG_LEC       
-  * @retval The new state of CAN_FLAG (SET or RESET).
-  */
-FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
-  
-
-  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
-  { 
-    /* Check the status of the specified CAN flag */
-    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
-    { 
-      /* CAN_FLAG is set */
-      bitstatus = SET;
-    }
-    else
-    { 
-      /* CAN_FLAG is reset */
-      bitstatus = RESET;
-    }
-  }
-  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
-  { 
-    /* Check the status of the specified CAN flag */
-    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
-    { 
-      /* CAN_FLAG is set */
-      bitstatus = SET;
-    }
-    else
-    { 
-      /* CAN_FLAG is reset */
-      bitstatus = RESET;
-    }
-  }
-  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
-  { 
-    /* Check the status of the specified CAN flag */
-    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
-    { 
-      /* CAN_FLAG is set */
-      bitstatus = SET;
-    }
-    else
-    { 
-      /* CAN_FLAG is reset */
-      bitstatus = RESET;
-    }
-  }
-  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
-  { 
-    /* Check the status of the specified CAN flag */
-    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
-    { 
-      /* CAN_FLAG is set */
-      bitstatus = SET;
-    }
-    else
-    { 
-      /* CAN_FLAG is reset */
-      bitstatus = RESET;
-    }
-  }
-  else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
-  { 
-    /* Check the status of the specified CAN flag */
-    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
-    { 
-      /* CAN_FLAG is set */
-      bitstatus = SET;
-    }
-    else
-    { 
-      /* CAN_FLAG is reset */
-      bitstatus = RESET;
-    }
-  }
-  /* Return the CAN_FLAG status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the CAN's pending flags.
-  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  CAN_FLAG: specifies the flag to clear.
-  *                   This parameter can be one of the following flags: 
-  *                    - CAN_FLAG_RQCP0
-  *                    - CAN_FLAG_RQCP1
-  *                    - CAN_FLAG_RQCP2
-  *                    - CAN_FLAG_FF1       
-  *                    - CAN_FLAG_FOV1   
-  *                    - CAN_FLAG_FF0       
-  *                    - CAN_FLAG_FOV0   
-  *                    - CAN_FLAG_WKU   
-  *                    - CAN_FLAG_SLAK    
-  *                    - CAN_FLAG_LEC       
-  * @retval None.
-  */
-void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
-{
-  uint32_t flagtmp=0;
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
-  
-  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
-  {
-    /* Clear the selected CAN flags */
-    CANx->ESR = (uint32_t)RESET;
-  }
-  else /* MSR or TSR or RF0R or RF1R */
-  {
-    flagtmp = CAN_FLAG & 0x000FFFFF;
-
-    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
-    {
-      /* Receive Flags */
-      CANx->RF0R = (uint32_t)(flagtmp);
-    }
-    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
-    {
-      /* Receive Flags */
-      CANx->RF1R = (uint32_t)(flagtmp);
-    }
-    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
-    {
-      /* Transmit Flags */
-      CANx->TSR = (uint32_t)(flagtmp);
-    }
-    else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
-    {
-      /* Operating mode Flags */
-      CANx->MSR = (uint32_t)(flagtmp);
-    }
-  }
-}
-
-/**
-  * @brief  Checks whether the specified CANx interrupt has occurred or not.
-  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  CAN_IT:  specifies the CAN interrupt source to check.
-  *                  This parameter can be one of the following flags: 
-  *                 -  CAN_IT_TME               
-  *                 -  CAN_IT_FMP0              
-  *                 -  CAN_IT_FF0               
-  *                 -  CAN_IT_FOV0              
-  *                 -  CAN_IT_FMP1              
-  *                 -  CAN_IT_FF1               
-  *                 -  CAN_IT_FOV1              
-  *                 -  CAN_IT_WKU  
-  *                 -  CAN_IT_SLK  
-  *                 -  CAN_IT_EWG    
-  *                 -  CAN_IT_EPV    
-  *                 -  CAN_IT_BOF    
-  *                 -  CAN_IT_LEC    
-  *                 -  CAN_IT_ERR 
-  * @retval The current state of CAN_IT (SET or RESET).
-  */
-ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
-{
-  ITStatus itstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_IT(CAN_IT));
-  
-  /* check the enable interrupt bit */
- if((CANx->IER & CAN_IT) != RESET)
- {
-   /* in case the Interrupt is enabled, .... */
-    switch (CAN_IT)
-    {
-      case CAN_IT_TME:
-               /* Check CAN_TSR_RQCPx bits */
-	             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
-	      break;
-      case CAN_IT_FMP0:
-               /* Check CAN_RF0R_FMP0 bit */
-	             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
-	      break;
-      case CAN_IT_FF0:
-               /* Check CAN_RF0R_FULL0 bit */
-               itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
-	      break;
-      case CAN_IT_FOV0:
-               /* Check CAN_RF0R_FOVR0 bit */
-               itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
-	      break;
-      case CAN_IT_FMP1:
-               /* Check CAN_RF1R_FMP1 bit */
-               itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
-	      break;
-      case CAN_IT_FF1:
-               /* Check CAN_RF1R_FULL1 bit */
-	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
-	      break;
-      case CAN_IT_FOV1:
-               /* Check CAN_RF1R_FOVR1 bit */
-	             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
-	      break;
-      case CAN_IT_WKU:
-               /* Check CAN_MSR_WKUI bit */
-               itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
-	      break;
-      case CAN_IT_SLK:
-               /* Check CAN_MSR_SLAKI bit */
-	             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
-	      break;
-      case CAN_IT_EWG:
-               /* Check CAN_ESR_EWGF bit */
-	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
-	      break;
-      case CAN_IT_EPV:
-               /* Check CAN_ESR_EPVF bit */
-	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
-	      break;
-      case CAN_IT_BOF:
-               /* Check CAN_ESR_BOFF bit */
-	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
-	      break;
-      case CAN_IT_LEC:
-               /* Check CAN_ESR_LEC bit */
-	             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
-	      break;
-      case CAN_IT_ERR:
-               /* Check CAN_MSR_ERRI bit */ 
-               itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
-	      break;
-      default :
-               /* in case of error, return RESET */
-              itstatus = RESET;
-              break;
-    }
-  }
-  else
-  {
-   /* in case the Interrupt is not enabled, return RESET */
-    itstatus  = RESET;
-  }
-  
-  /* Return the CAN_IT status */
-  return  itstatus;
-}
-
-/**
-  * @brief  Clears the CANx's interrupt pending bits.
-  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.
-  * @param  CAN_IT: specifies the interrupt pending bit to clear.
-  *                  -  CAN_IT_TME                     
-  *                  -  CAN_IT_FF0               
-  *                  -  CAN_IT_FOV0                     
-  *                  -  CAN_IT_FF1               
-  *                  -  CAN_IT_FOV1              
-  *                  -  CAN_IT_WKU  
-  *                  -  CAN_IT_SLK  
-  *                  -  CAN_IT_EWG    
-  *                  -  CAN_IT_EPV    
-  *                  -  CAN_IT_BOF    
-  *                  -  CAN_IT_LEC    
-  *                  -  CAN_IT_ERR 
-  * @retval None.
-  */
-void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_CAN_ALL_PERIPH(CANx));
-  assert_param(IS_CAN_CLEAR_IT(CAN_IT));
-
-  switch (CAN_IT)
-  {
-      case CAN_IT_TME:
-              /* Clear CAN_TSR_RQCPx (rc_w1)*/
-	      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
-	      break;
-      case CAN_IT_FF0:
-              /* Clear CAN_RF0R_FULL0 (rc_w1)*/
-	      CANx->RF0R = CAN_RF0R_FULL0; 
-	      break;
-      case CAN_IT_FOV0:
-              /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
-	      CANx->RF0R = CAN_RF0R_FOVR0; 
-	      break;
-      case CAN_IT_FF1:
-              /* Clear CAN_RF1R_FULL1 (rc_w1)*/
-	      CANx->RF1R = CAN_RF1R_FULL1;  
-	      break;
-      case CAN_IT_FOV1:
-              /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
-	      CANx->RF1R = CAN_RF1R_FOVR1; 
-	      break;
-      case CAN_IT_WKU:
-              /* Clear CAN_MSR_WKUI (rc_w1)*/
-	      CANx->MSR = CAN_MSR_WKUI;  
-	      break;
-      case CAN_IT_SLK:
-              /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
-	      CANx->MSR = CAN_MSR_SLAKI;   
-	      break;
-      case CAN_IT_EWG:
-              /* Clear CAN_MSR_ERRI (rc_w1) */
-	      CANx->MSR = CAN_MSR_ERRI;
-              /* Note : the corresponding Flag is cleared by hardware depending 
-                        of the CAN Bus status*/ 
-	      break;
-      case CAN_IT_EPV:
-              /* Clear CAN_MSR_ERRI (rc_w1) */
-	      CANx->MSR = CAN_MSR_ERRI; 
-              /* Note : the corresponding Flag is cleared by hardware depending 
-                        of the CAN Bus status*/
-	      break;
-      case CAN_IT_BOF:
-              /* Clear CAN_MSR_ERRI (rc_w1) */ 
-	      CANx->MSR = CAN_MSR_ERRI; 
-              /* Note : the corresponding Flag is cleared by hardware depending 
-                        of the CAN Bus status*/
-	      break;
-      case CAN_IT_LEC:
-              /*  Clear LEC bits */
-	      CANx->ESR = RESET; 
-              /* Clear CAN_MSR_ERRI (rc_w1) */
-	      CANx->MSR = CAN_MSR_ERRI; 
-	      break;
-      case CAN_IT_ERR:
-              /*Clear LEC bits */
-	      CANx->ESR = RESET; 
-              /* Clear CAN_MSR_ERRI (rc_w1) */
-	      CANx->MSR = CAN_MSR_ERRI; 
-	      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending 
-                  of the CAN Bus status*/
-	      break;
-      default :
-	      break;
-   }
-}
-
-/**
-  * @brief  Checks whether the CAN interrupt has occurred or not.
-  * @param  CAN_Reg: specifies the CAN interrupt register to check.
-  * @param  It_Bit:  specifies the interrupt source bit to check.
-  * @retval The new state of the CAN Interrupt (SET or RESET).
-  */
-static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
-{
-  ITStatus pendingbitstatus = RESET;
-  
-  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
-  {
-    /* CAN_IT is set */
-    pendingbitstatus = SET;
-  }
-  else
-  {
-    /* CAN_IT is reset */
-    pendingbitstatus = RESET;
-  }
-  return pendingbitstatus;
-}
-
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_can.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_can.h
deleted file mode 100644
index d185aa21e..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_can.h
+++ /dev/null
@@ -1,697 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_can.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the CAN firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_CAN_H
-#define __STM32F10x_CAN_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup CAN
-  * @{
-  */
-
-/** @defgroup CAN_Exported_Types
-  * @{
-  */
-
-#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
-                                   ((PERIPH) == CAN2))
-
-/** 
-  * @brief  CAN init structure definition
-  */
-
-typedef struct
-{
-  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum. 
-                                 It ranges from 1 to 1024. */
-  
-  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.
-                                 This parameter can be a value of 
-                                @ref CAN_operating_mode */
-
-  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta 
-                                 the CAN hardware is allowed to lengthen or 
-                                 shorten a bit to perform resynchronization.
-                                 This parameter can be a value of 
-                                 @ref CAN_synchronisation_jump_width */
-
-  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit 
-                                 Segment 1. This parameter can be a value of 
-                                 @ref CAN_time_quantum_in_bit_segment_1 */
-
-  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit 
-                                 Segment 2.
-                                 This parameter can be a value of 
-                                 @ref CAN_time_quantum_in_bit_segment_2 */
-  
-  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered 
-                                 communication mode. This parameter can be set 
-                                 either to ENABLE or DISABLE. */
-  
-  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off 
-                                  management. This parameter can be set either 
-                                  to ENABLE or DISABLE. */
-
-  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode. 
-                                  This parameter can be set either to ENABLE or 
-                                  DISABLE. */
-
-  FunctionalState CAN_NART;  /*!< Enable or disable the no-automatic 
-                                  retransmission mode. This parameter can be 
-                                  set either to ENABLE or DISABLE. */
-
-  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
-                                  This parameter can be set either to ENABLE 
-                                  or DISABLE. */
-
-  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.
-                                  This parameter can be set either to ENABLE 
-                                  or DISABLE. */
-} CAN_InitTypeDef;
-
-/** 
-  * @brief  CAN filter init structure definition
-  */
-
-typedef struct
-{
-  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit
-                                              configuration, first one for a 16-bit configuration).
-                                              This parameter can be a value between 0x0000 and 0xFFFF */
-
-  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit
-                                              configuration, second one for a 16-bit configuration).
-                                              This parameter can be a value between 0x0000 and 0xFFFF */
-
-  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,
-                                              according to the mode (MSBs for a 32-bit configuration,
-                                              first one for a 16-bit configuration).
-                                              This parameter can be a value between 0x0000 and 0xFFFF */
-
-  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,
-                                              according to the mode (LSBs for a 32-bit configuration,
-                                              second one for a 16-bit configuration).
-                                              This parameter can be a value between 0x0000 and 0xFFFF */
-
-  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
-                                              This parameter can be a value of @ref CAN_filter_FIFO */
-  
-  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */
-
-  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.
-                                              This parameter can be a value of @ref CAN_filter_mode */
-
-  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.
-                                              This parameter can be a value of @ref CAN_filter_scale */
-
-  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.
-                                              This parameter can be set either to ENABLE or DISABLE. */
-} CAN_FilterInitTypeDef;
-
-/** 
-  * @brief  CAN Tx message structure definition  
-  */
-
-typedef struct
-{
-  uint32_t StdId;  /*!< Specifies the standard identifier.
-                        This parameter can be a value between 0 to 0x7FF. */
-
-  uint32_t ExtId;  /*!< Specifies the extended identifier.
-                        This parameter can be a value between 0 to 0x1FFFFFFF. */
-
-  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
-                        will be transmitted. This parameter can be a value 
-                        of @ref CAN_identifier_type */
-
-  uint8_t RTR;     /*!< Specifies the type of frame for the message that will 
-                        be transmitted. This parameter can be a value of 
-                        @ref CAN_remote_transmission_request */
-
-  uint8_t DLC;     /*!< Specifies the length of the frame that will be 
-                        transmitted. This parameter can be a value between 
-                        0 to 8 */
-
-  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0 
-                        to 0xFF. */
-} CanTxMsg;
-
-/** 
-  * @brief  CAN Rx message structure definition  
-  */
-
-typedef struct
-{
-  uint32_t StdId;  /*!< Specifies the standard identifier.
-                        This parameter can be a value between 0 to 0x7FF. */
-
-  uint32_t ExtId;  /*!< Specifies the extended identifier.
-                        This parameter can be a value between 0 to 0x1FFFFFFF. */
-
-  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
-                        will be received. This parameter can be a value of 
-                        @ref CAN_identifier_type */
-
-  uint8_t RTR;     /*!< Specifies the type of frame for the received message.
-                        This parameter can be a value of 
-                        @ref CAN_remote_transmission_request */
-
-  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.
-                        This parameter can be a value between 0 to 8 */
-
-  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to 
-                        0xFF. */
-
-  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in 
-                        the mailbox passes through. This parameter can be a 
-                        value between 0 to 0xFF */
-} CanRxMsg;
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Exported_Constants
-  * @{
-  */
-
-/** @defgroup CAN_sleep_constants 
-  * @{
-  */
-
-#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */
-#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Mode 
-  * @{
-  */
-
-#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */
-#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */
-#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */
-#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */
-
-#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \
-                           ((MODE) == CAN_Mode_LoopBack)|| \
-                           ((MODE) == CAN_Mode_Silent) || \
-                           ((MODE) == CAN_Mode_Silent_LoopBack))
-/**
-  * @}
-  */
-
-
-/**
-  * @defgroup CAN_Operating_Mode 
-  * @{
-  */  
-#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */
-#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */
-#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */
-
-
-#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\
-                                    ((MODE) == CAN_OperatingMode_Normal)|| \
-																		((MODE) == CAN_OperatingMode_Sleep))
-/**
-  * @}
-  */
-  
-/**
-  * @defgroup CAN_Mode_Status
-  * @{
-  */  
-
-#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */
-#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */
-
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_synchronisation_jump_width 
-  * @{
-  */
-
-#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
-#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
-#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
-#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
-
-#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
-                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
-/**
-  * @}
-  */
-
-/** @defgroup CAN_time_quantum_in_bit_segment_1 
-  * @{
-  */
-
-#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
-#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
-#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
-#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
-#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
-#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
-#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
-#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
-#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */
-#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */
-#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */
-#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */
-#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */
-#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */
-#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */
-#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */
-
-#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
-/**
-  * @}
-  */
-
-/** @defgroup CAN_time_quantum_in_bit_segment_2 
-  * @{
-  */
-
-#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
-#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
-#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
-#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
-#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
-#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
-#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
-#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
-
-#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_clock_prescaler 
-  * @{
-  */
-
-#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_filter_number 
-  * @{
-  */
-#ifndef STM32F10X_CL
-  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 13)
-#else
-  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
-#endif /* STM32F10X_CL */ 
-/**
-  * @}
-  */
-
-/** @defgroup CAN_filter_mode 
-  * @{
-  */
-
-#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */
-#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */
-
-#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
-                                  ((MODE) == CAN_FilterMode_IdList))
-/**
-  * @}
-  */
-
-/** @defgroup CAN_filter_scale 
-  * @{
-  */
-
-#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */
-#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */
-
-#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
-                                    ((SCALE) == CAN_FilterScale_32bit))
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_filter_FIFO
-  * @{
-  */
-
-#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */
-#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
-#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
-                                  ((FIFO) == CAN_FilterFIFO1))
-/**
-  * @}
-  */
-
-/** @defgroup Start_bank_filter_for_slave_CAN 
-  * @{
-  */
-#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Tx 
-  * @{
-  */
-
-#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
-#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
-#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
-#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_identifier_type 
-  * @{
-  */
-
-#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */
-#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */
-#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \
-                               ((IDTYPE) == CAN_Id_Extended))
-/**
-  * @}
-  */
-
-/** @defgroup CAN_remote_transmission_request 
-  * @{
-  */
-
-#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */
-#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */
-#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_transmit_constants 
-  * @{
-  */
-
-#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */
-#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */
-#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */
-#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide an empty mailbox */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_receive_FIFO_number_constants 
-  * @{
-  */
-
-#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */
-#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */
-
-#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_sleep_constants 
-  * @{
-  */
-
-#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */
-#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_wake_up_constants 
-  * @{
-  */
-
-#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */
-#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */
-
-/**
-  * @}
-  */
-
-/**
-  * @defgroup   CAN_Error_Code_constants
-  * @{
-  */  
-                                                                
-#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */ 
-#define	CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */ 
-#define	CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */ 
-#define	CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */ 
-#define	CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */ 
-#define	CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */ 
-#define	CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */ 
-#define	CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */ 
-
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_flags 
-  * @{
-  */
-/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
-   and CAN_ClearFlag() functions. */
-/* If the flag is 0x1XXXXXXX, it means that it can only be used with CAN_GetFlagStatus() function.  */
-
-/* Transmit Flags */
-#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */
-#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */
-#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */
-
-/* Receive Flags */
-#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */
-#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */
-#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */
-#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
-#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
-#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */
-
-/* Operating Mode Flags */
-#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */
-#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */
-/* Note: When SLAK intterupt is disabled (SLKIE=0), no polling on SLAKI is possible. 
-         In this case the SLAK bit can be polled.*/
-
-/* Error Flags */
-#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */
-#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */
-#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */
-#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */
-
-#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \
-                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \
-                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \
-                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \
-                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \
-                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \
-                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \
-                               ((FLAG) == CAN_FLAG_SLAK ))
-
-#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \
-                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \
-                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\
-                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \
-                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
-/**
-  * @}
-  */
-
-  
-/** @defgroup CAN_interrupts 
-  * @{
-  */
-
-
-  
-#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/
-
-/* Receive Interrupts */
-#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
-#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
-#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
-#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
-#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
-#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
-
-/* Operating Mode Interrupts */
-#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/
-#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/
-
-/* Error Interrupts */
-#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/
-#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/
-#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/
-#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/
-#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/
-
-/* Flags named as Interrupts : kept only for FW compatibility */
-#define CAN_IT_RQCP0   CAN_IT_TME
-#define CAN_IT_RQCP1   CAN_IT_TME
-#define CAN_IT_RQCP2   CAN_IT_TME
-
-
-#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\
-                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\
-                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\
-                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\
-                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\
-                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\
-                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
-
-#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\
-                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\
-                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\
-                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\
-                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\
-                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Legacy 
-  * @{
-  */
-#define CANINITFAILED               CAN_InitStatus_Failed
-#define CANINITOK                   CAN_InitStatus_Success
-#define CAN_FilterFIFO0             CAN_Filter_FIFO0
-#define CAN_FilterFIFO1             CAN_Filter_FIFO1
-#define CAN_ID_STD                  CAN_Id_Standard           
-#define CAN_ID_EXT                  CAN_Id_Extended
-#define CAN_RTR_DATA                CAN_RTR_Data         
-#define CAN_RTR_REMOTE              CAN_RTR_Remote
-#define CANTXFAILE                  CAN_TxStatus_Failed
-#define CANTXOK                     CAN_TxStatus_Ok
-#define CANTXPENDING                CAN_TxStatus_Pending
-#define CAN_NO_MB                   CAN_TxStatus_NoMailBox
-#define CANSLEEPFAILED              CAN_Sleep_Failed
-#define CANSLEEPOK                  CAN_Sleep_Ok
-#define CANWAKEUPFAILED             CAN_WakeUp_Failed        
-#define CANWAKEUPOK                 CAN_WakeUp_Ok        
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CAN_Exported_Functions
-  * @{
-  */
-/*  Function used to set the CAN configuration to the default reset state *****/ 
-void CAN_DeInit(CAN_TypeDef* CANx);
-
-/* Initialization and Configuration functions *********************************/ 
-uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
-void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
-void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
-void CAN_SlaveStartBank(uint8_t CAN_BankNumber); 
-void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
-void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);
-
-/* Transmit functions *********************************************************/
-uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
-uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
-void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);
-
-/* Receive functions **********************************************************/
-void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
-void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
-uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);
-
-
-/* Operation modes functions **************************************************/
-uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);
-uint8_t CAN_Sleep(CAN_TypeDef* CANx);
-uint8_t CAN_WakeUp(CAN_TypeDef* CANx);
-
-/* Error management functions *************************************************/
-uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);
-uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);
-uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);
-
-/* Interrupts and flags management functions **********************************/
-void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
-FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
-void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
-ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
-void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_CAN_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_cec.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_cec.c
deleted file mode 100644
index 4dc615f03..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_cec.c
+++ /dev/null
@@ -1,433 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_cec.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the CEC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_cec.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup CEC 
-  * @brief CEC driver modules
-  * @{
-  */
-
-/** @defgroup CEC_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-
-/** @defgroup CEC_Private_Defines
-  * @{
-  */ 
-
-/* ------------ CEC registers bit address in the alias region ----------- */
-#define CEC_OFFSET                (CEC_BASE - PERIPH_BASE)
-
-/* --- CFGR Register ---*/
-
-/* Alias word address of PE bit */
-#define CFGR_OFFSET                 (CEC_OFFSET + 0x00)
-#define PE_BitNumber                0x00
-#define CFGR_PE_BB                  (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (PE_BitNumber * 4))
-
-/* Alias word address of IE bit */
-#define IE_BitNumber                0x01
-#define CFGR_IE_BB                  (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (IE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-
-/* Alias word address of TSOM bit */
-#define CSR_OFFSET                  (CEC_OFFSET + 0x10)
-#define TSOM_BitNumber              0x00
-#define CSR_TSOM_BB                 (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TSOM_BitNumber * 4))
-
-/* Alias word address of TEOM bit */
-#define TEOM_BitNumber              0x01
-#define CSR_TEOM_BB                 (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEOM_BitNumber * 4))
-  
-#define CFGR_CLEAR_Mask            (uint8_t)(0xF3)        /* CFGR register Mask */
-#define FLAG_Mask                  ((uint32_t)0x00FFFFFF) /* CEC FLAG mask */
- 
-/**
-  * @}
-  */ 
-
-
-/** @defgroup CEC_Private_Macros
-  * @{
-  */ 
-
-/**
-  * @}
-  */ 
-
-
-/** @defgroup CEC_Private_Variables
-  * @{
-  */ 
-
-/**
-  * @}
-  */ 
-
-
-/** @defgroup CEC_Private_FunctionPrototypes
-  * @{
-  */
- 
-/**
-  * @}
-  */ 
-
-
-/** @defgroup CEC_Private_Functions
-  * @{
-  */ 
-
-/**
-  * @brief  Deinitializes the CEC peripheral registers to their default reset 
-  *         values.
-  * @param  None
-  * @retval None
-  */
-void CEC_DeInit(void)
-{
-  /* Enable CEC reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);  
-  /* Release CEC from reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE); 
-}
-
-
-/**
-  * @brief  Initializes the CEC peripheral according to the specified 
-  *         parameters in the CEC_InitStruct.
-  * @param  CEC_InitStruct: pointer to an CEC_InitTypeDef structure that
-  *         contains the configuration information for the specified
-  *         CEC peripheral.
-  * @retval None
-  */
-void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
-{
-  uint16_t tmpreg = 0;
- 
-  /* Check the parameters */
-  assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode)); 
-  assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));
-     
-  /*---------------------------- CEC CFGR Configuration -----------------*/
-  /* Get the CEC CFGR value */
-  tmpreg = CEC->CFGR;
-  
-  /* Clear BTEM and BPEM bits */
-  tmpreg &= CFGR_CLEAR_Mask;
-  
-  /* Configure CEC: Bit Timing Error and Bit Period Error */
-  tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);
-
-  /* Write to CEC CFGR  register*/
-  CEC->CFGR = tmpreg;
-  
-}
-
-/**
-  * @brief  Enables or disables the specified CEC peripheral.
-  * @param  NewState: new state of the CEC peripheral. 
-  *     This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void CEC_Cmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;
-
-  if(NewState == DISABLE)
-  {
-    /* Wait until the PE bit is cleared by hardware (Idle Line detected) */
-    while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)
-    {
-    }  
-  }  
-}
-
-/**
-  * @brief  Enables or disables the CEC interrupt.
-  * @param  NewState: new state of the CEC interrupt.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void CEC_ITConfig(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Defines the Own Address of the CEC device.
-  * @param  CEC_OwnAddress: The CEC own address
-  * @retval None
-  */
-void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
-{
-  /* Check the parameters */
-  assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
-
-  /* Set the CEC own address */
-  CEC->OAR = CEC_OwnAddress;
-}
-
-/**
-  * @brief  Sets the CEC prescaler value.
-  * @param  CEC_Prescaler: CEC prescaler new value
-  * @retval None
-  */
-void CEC_SetPrescaler(uint16_t CEC_Prescaler)
-{
-  /* Check the parameters */
-  assert_param(IS_CEC_PRESCALER(CEC_Prescaler));
-
-  /* Set the  Prescaler value*/
-  CEC->PRES = CEC_Prescaler;
-}
-
-/**
-  * @brief  Transmits single data through the CEC peripheral.
-  * @param  Data: the data to transmit.
-  * @retval None
-  */
-void CEC_SendDataByte(uint8_t Data)
-{  
-  /* Transmit Data */
-  CEC->TXD = Data ;
-}
-
-
-/**
-  * @brief  Returns the most recent received data by the CEC peripheral.
-  * @param  None
-  * @retval The received data.
-  */
-uint8_t CEC_ReceiveDataByte(void)
-{
-  /* Receive Data */
-  return (uint8_t)(CEC->RXD);
-}
-
-/**
-  * @brief  Starts a new message.
-  * @param  None
-  * @retval None
-  */
-void CEC_StartOfMessage(void)
-{  
-  /* Starts of new message */
-  *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;
-}
-
-/**
-  * @brief  Transmits message with or without an EOM bit.
-  * @param  NewState: new state of the CEC Tx End Of Message. 
-  *     This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void CEC_EndOfMessageCmd(FunctionalState NewState)
-{   
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  /* The data byte will be transmitted with or without an EOM bit*/
-  *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Gets the CEC flag status
-  * @param  CEC_FLAG: specifies the CEC flag to check. 
-  *   This parameter can be one of the following values:
-  *     @arg CEC_FLAG_BTE: Bit Timing Error
-  *     @arg CEC_FLAG_BPE: Bit Period Error
-  *     @arg CEC_FLAG_RBTFE: Rx Block Transfer Finished Error
-  *     @arg CEC_FLAG_SBE: Start Bit Error
-  *     @arg CEC_FLAG_ACKE: Block Acknowledge Error
-  *     @arg CEC_FLAG_LINE: Line Error
-  *     @arg CEC_FLAG_TBTFE: Tx Block Transfer Finished Error
-  *     @arg CEC_FLAG_TEOM: Tx End Of Message 
-  *     @arg CEC_FLAG_TERR: Tx Error
-  *     @arg CEC_FLAG_TBTRF: Tx Byte Transfer Request or Block Transfer Finished
-  *     @arg CEC_FLAG_RSOM: Rx Start Of Message
-  *     @arg CEC_FLAG_REOM: Rx End Of Message
-  *     @arg CEC_FLAG_RERR: Rx Error
-  *     @arg CEC_FLAG_RBTF: Rx Byte/Block Transfer Finished
-  * @retval The new state of CEC_FLAG (SET or RESET)
-  */
-FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG) 
-{
-  FlagStatus bitstatus = RESET;
-  uint32_t cecreg = 0, cecbase = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
- 
-  /* Get the CEC peripheral base address */
-  cecbase = (uint32_t)(CEC_BASE);
-  
-  /* Read flag register index */
-  cecreg = CEC_FLAG >> 28;
-  
-  /* Get bit[23:0] of the flag */
-  CEC_FLAG &= FLAG_Mask;
-  
-  if(cecreg != 0)
-  {
-    /* Flag in CEC ESR Register */
-    CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);
-    
-    /* Get the CEC ESR register address */
-    cecbase += 0xC;
-  }
-  else
-  {
-    /* Get the CEC CSR register address */
-    cecbase += 0x10;
-  }
-  
-  if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)
-  {
-    /* CEC_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CEC_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the CEC_FLAG status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the CEC's pending flags.
-  * @param  CEC_FLAG: specifies the flag to clear. 
-  *   This parameter can be any combination of the following values:
-  *     @arg CEC_FLAG_TERR: Tx Error
-  *     @arg CEC_FLAG_TBTRF: Tx Byte Transfer Request or Block Transfer Finished
-  *     @arg CEC_FLAG_RSOM: Rx Start Of Message
-  *     @arg CEC_FLAG_REOM: Rx End Of Message
-  *     @arg CEC_FLAG_RERR: Rx Error
-  *     @arg CEC_FLAG_RBTF: Rx Byte/Block Transfer Finished
-  * @retval None
-  */
-void CEC_ClearFlag(uint32_t CEC_FLAG)
-{ 
-  uint32_t tmp = 0x0;
-  
-  /* Check the parameters */
-  assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
-
-  tmp = CEC->CSR & 0x2;
-       
-  /* Clear the selected CEC flags */
-  CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);
-}
-
-/**
-  * @brief  Checks whether the specified CEC interrupt has occurred or not.
-  * @param  CEC_IT: specifies the CEC interrupt source to check. 
-  *   This parameter can be one of the following values:
-  *     @arg CEC_IT_TERR: Tx Error
-  *     @arg CEC_IT_TBTF: Tx Block Transfer Finished
-  *     @arg CEC_IT_RERR: Rx Error
-  *     @arg CEC_IT_RBTF: Rx Block Transfer Finished
-  * @retval The new state of CEC_IT (SET or RESET).
-  */
-ITStatus CEC_GetITStatus(uint8_t CEC_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t enablestatus = 0;
-  
-  /* Check the parameters */
-   assert_param(IS_CEC_GET_IT(CEC_IT));
-   
-  /* Get the CEC IT enable bit status */
-  enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;
-  
-  /* Check the status of the specified CEC interrupt */
-  if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)
-  {
-    /* CEC_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* CEC_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the CEC_IT status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the CEC's interrupt pending bits.
-  * @param  CEC_IT: specifies the CEC interrupt pending bit to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg CEC_IT_TERR: Tx Error
-  *     @arg CEC_IT_TBTF: Tx Block Transfer Finished
-  *     @arg CEC_IT_RERR: Rx Error
-  *     @arg CEC_IT_RBTF: Rx Block Transfer Finished
-  * @retval None
-  */
-void CEC_ClearITPendingBit(uint16_t CEC_IT)
-{
-  uint32_t tmp = 0x0;
-  
-  /* Check the parameters */
-  assert_param(IS_CEC_GET_IT(CEC_IT));
-  
-  tmp = CEC->CSR & 0x2;
-  
-  /* Clear the selected CEC interrupt pending bits */
-  CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);
-}
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_cec.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_cec.h
deleted file mode 100644
index 7ce689611..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_cec.h
+++ /dev/null
@@ -1,210 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_cec.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the CEC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_CEC_H
-#define __STM32F10x_CEC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup CEC
-  * @{
-  */
-  
-
-/** @defgroup CEC_Exported_Types
-  * @{
-  */
-   
-/** 
-  * @brief  CEC Init structure definition  
-  */ 
-typedef struct
-{
-  uint16_t CEC_BitTimingMode; /*!< Configures the CEC Bit Timing Error Mode. 
-                               This parameter can be a value of @ref CEC_BitTiming_Mode */
-  uint16_t CEC_BitPeriodMode; /*!< Configures the CEC Bit Period Error Mode. 
-                               This parameter can be a value of @ref CEC_BitPeriod_Mode */
-}CEC_InitTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup CEC_Exported_Constants
-  * @{
-  */ 
-  
-/** @defgroup CEC_BitTiming_Mode 
-  * @{
-  */ 
-#define CEC_BitTimingStdMode                    ((uint16_t)0x00) /*!< Bit timing error Standard Mode */
-#define CEC_BitTimingErrFreeMode                CEC_CFGR_BTEM   /*!< Bit timing error Free Mode */
-
-#define IS_CEC_BIT_TIMING_ERROR_MODE(MODE) (((MODE) == CEC_BitTimingStdMode) || \
-                                            ((MODE) == CEC_BitTimingErrFreeMode))
-/**
-  * @}
-  */
-
-/** @defgroup CEC_BitPeriod_Mode 
-  * @{
-  */ 
-#define CEC_BitPeriodStdMode                    ((uint16_t)0x00) /*!< Bit period error Standard Mode */
-#define CEC_BitPeriodFlexibleMode                CEC_CFGR_BPEM   /*!< Bit period error Flexible Mode */
-
-#define IS_CEC_BIT_PERIOD_ERROR_MODE(MODE) (((MODE) == CEC_BitPeriodStdMode) || \
-                                            ((MODE) == CEC_BitPeriodFlexibleMode))
-/**
-  * @}
-  */ 
-
-
-/** @defgroup CEC_interrupts_definition 
-  * @{
-  */ 
-#define CEC_IT_TERR                              CEC_CSR_TERR
-#define CEC_IT_TBTRF                             CEC_CSR_TBTRF
-#define CEC_IT_RERR                              CEC_CSR_RERR
-#define CEC_IT_RBTF                              CEC_CSR_RBTF
-#define IS_CEC_GET_IT(IT) (((IT) == CEC_IT_TERR) || ((IT) == CEC_IT_TBTRF) || \
-                           ((IT) == CEC_IT_RERR) || ((IT) == CEC_IT_RBTF))
-/**
-  * @}
-  */ 
-
-
-/** @defgroup CEC_Own_Address 
-  * @{
-  */ 
-#define IS_CEC_ADDRESS(ADDRESS) ((ADDRESS) < 0x10)
-/**
-  * @}
-  */ 
-
-/** @defgroup CEC_Prescaler 
-  * @{
-  */ 
-#define IS_CEC_PRESCALER(PRESCALER) ((PRESCALER) <= 0x3FFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup CEC_flags_definition 
-  * @{
-  */
-   
-/** 
-  * @brief  ESR register flags  
-  */ 
-#define CEC_FLAG_BTE                            ((uint32_t)0x10010000)
-#define CEC_FLAG_BPE                            ((uint32_t)0x10020000)
-#define CEC_FLAG_RBTFE                          ((uint32_t)0x10040000)
-#define CEC_FLAG_SBE                            ((uint32_t)0x10080000)
-#define CEC_FLAG_ACKE                           ((uint32_t)0x10100000)
-#define CEC_FLAG_LINE                           ((uint32_t)0x10200000)
-#define CEC_FLAG_TBTFE                          ((uint32_t)0x10400000)
-
-/** 
-  * @brief  CSR register flags  
-  */ 
-#define CEC_FLAG_TEOM                           ((uint32_t)0x00000002)  
-#define CEC_FLAG_TERR                           ((uint32_t)0x00000004)
-#define CEC_FLAG_TBTRF                          ((uint32_t)0x00000008)
-#define CEC_FLAG_RSOM                           ((uint32_t)0x00000010)
-#define CEC_FLAG_REOM                           ((uint32_t)0x00000020)
-#define CEC_FLAG_RERR                           ((uint32_t)0x00000040)
-#define CEC_FLAG_RBTF                           ((uint32_t)0x00000080)
-
-#define IS_CEC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFF03) == 0x00) && ((FLAG) != 0x00))
-                               
-#define IS_CEC_GET_FLAG(FLAG) (((FLAG) == CEC_FLAG_BTE) || ((FLAG) == CEC_FLAG_BPE) || \
-                               ((FLAG) == CEC_FLAG_RBTFE) || ((FLAG)== CEC_FLAG_SBE) || \
-                               ((FLAG) == CEC_FLAG_ACKE) || ((FLAG) == CEC_FLAG_LINE) || \
-                               ((FLAG) == CEC_FLAG_TBTFE) || ((FLAG) == CEC_FLAG_TEOM) || \
-                               ((FLAG) == CEC_FLAG_TERR) || ((FLAG) == CEC_FLAG_TBTRF) || \
-                               ((FLAG) == CEC_FLAG_RSOM) || ((FLAG) == CEC_FLAG_REOM) || \
-                               ((FLAG) == CEC_FLAG_RERR) || ((FLAG) == CEC_FLAG_RBTF))
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup CEC_Exported_Macros
-  * @{
-  */
- 
-/**
-  * @}
-  */
-
-/** @defgroup CEC_Exported_Functions
-  * @{
-  */ 
-void CEC_DeInit(void);
-void CEC_Init(CEC_InitTypeDef* CEC_InitStruct);
-void CEC_Cmd(FunctionalState NewState);
-void CEC_ITConfig(FunctionalState NewState);
-void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress);
-void CEC_SetPrescaler(uint16_t CEC_Prescaler);
-void CEC_SendDataByte(uint8_t Data);
-uint8_t CEC_ReceiveDataByte(void);
-void CEC_StartOfMessage(void);
-void CEC_EndOfMessageCmd(FunctionalState NewState);
-FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG);
-void CEC_ClearFlag(uint32_t CEC_FLAG);
-ITStatus CEC_GetITStatus(uint8_t CEC_IT);
-void CEC_ClearITPendingBit(uint16_t CEC_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_CEC_H */
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_conf.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_conf.h
deleted file mode 100644
index 06c898ffd..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_conf.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_conf.h 
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    08-April-2011
-  * @brief   Library configuration file.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_CONF_H
-#define __STM32F10x_CONF_H
-
-/* Includes ------------------------------------------------------------------*/
-/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
-#include "stm32f10x_adc.h"
-#include "stm32f10x_bkp.h"
-#include "stm32f10x_can.h"
-#include "stm32f10x_cec.h"
-#include "stm32f10x_crc.h"
-#include "stm32f10x_dac.h"
-#include "stm32f10x_dbgmcu.h"
-#include "stm32f10x_dma.h"
-#include "stm32f10x_exti.h"
-#include "stm32f10x_flash.h"
-#include "stm32f10x_fsmc.h"
-#include "stm32f10x_gpio.h"
-#include "stm32f10x_i2c.h"
-#include "stm32f10x_iwdg.h"
-#include "stm32f10x_pwr.h"
-#include "stm32f10x_rcc.h"
-#include "stm32f10x_rtc.h"
-#include "stm32f10x_sdio.h"
-#include "stm32f10x_spi.h"
-#include "stm32f10x_tim.h"
-#include "stm32f10x_usart.h"
-#include "stm32f10x_wwdg.h"
-#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
-
-// Samraksh
-#include "core_cm3.h"
-
-inline uint32_t JTAG_Attached() {
-    return (CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk);
-}
-
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Uncomment the line below to expanse the "assert_param" macro in the
-   Standard Peripheral Library drivers code */
-#if !defined(NDEBUG) && defined(DEBUG) && !defined(BUILD_RTM)
-//#define USE_FULL_ASSERT    1
-#endif
-/* Exported macro ------------------------------------------------------------*/
-#if defined(USE_FULL_ASSERT)
-
-/**
-  * @brief  The assert_param macro is used for function's parameters check.
-  * @param  expr: If expr is false, it calls assert_failed function which reports
-  *         the name of the source file and the source line number of the call
-  *         that failed. If expr is true, it returns no value.
-  * @retval None
-  */
-  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
-/* Exported functions ------------------------------------------------------- */
-
-
-
-  void assert_failed(uint8_t* file, uint32_t line) {
-      debug_printf("Assert fail at File %s Line %d", file, (int)line);
-      if(JTAG_Attached()) {
-          __ASM volatile("bkpt");
-      }
-      while(1) {__NOP();}
-      return;
-  }
-#else
-  #define assert_param(expr) ((void)0)
-#endif /* USE_FULL_ASSERT */
-// Samraksh
-
-#endif /* __STM32F10x_CONF_H */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_crc.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_crc.c
deleted file mode 100644
index 650172812..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_crc.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_crc.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the CRC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_crc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup CRC 
-  * @brief CRC driver modules
-  * @{
-  */
-
-/** @defgroup CRC_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Private_Defines
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Resets the CRC Data register (DR).
-  * @param  None
-  * @retval None
-  */
-void CRC_ResetDR(void)
-{
-  /* Reset CRC generator */
-  CRC->CR = CRC_CR_RESET;
-}
-
-/**
-  * @brief  Computes the 32-bit CRC of a given data word(32-bit).
-  * @param  Data: data word(32-bit) to compute its CRC
-  * @retval 32-bit CRC
-  */
-uint32_t CRC_CalcCRC(uint32_t Data)
-{
-  CRC->DR = Data;
-  
-  return (CRC->DR);
-}
-
-/**
-  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).
-  * @param  pBuffer: pointer to the buffer containing the data to be computed
-  * @param  BufferLength: length of the buffer to be computed					
-  * @retval 32-bit CRC
-  */
-uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
-{
-  uint32_t index = 0;
-  
-  for(index = 0; index < BufferLength; index++)
-  {
-    CRC->DR = pBuffer[index];
-  }
-  return (CRC->DR);
-}
-
-/**
-  * @brief  Returns the current CRC value.
-  * @param  None
-  * @retval 32-bit CRC
-  */
-uint32_t CRC_GetCRC(void)
-{
-  return (CRC->DR);
-}
-
-/**
-  * @brief  Stores a 8-bit data in the Independent Data(ID) register.
-  * @param  IDValue: 8-bit value to be stored in the ID register 					
-  * @retval None
-  */
-void CRC_SetIDRegister(uint8_t IDValue)
-{
-  CRC->IDR = IDValue;
-}
-
-/**
-  * @brief  Returns the 8-bit data stored in the Independent Data(ID) register
-  * @param  None
-  * @retval 8-bit value of the ID register 
-  */
-uint8_t CRC_GetIDRegister(void)
-{
-  return (CRC->IDR);
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_crc.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_crc.h
deleted file mode 100644
index 3362fcaa1..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_crc.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_crc.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the CRC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_CRC_H
-#define __STM32F10x_CRC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup CRC
-  * @{
-  */
-
-/** @defgroup CRC_Exported_Types
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Exported_Constants
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup CRC_Exported_Functions
-  * @{
-  */
-
-void CRC_ResetDR(void);
-uint32_t CRC_CalcCRC(uint32_t Data);
-uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
-uint32_t CRC_GetCRC(void);
-void CRC_SetIDRegister(uint8_t IDValue);
-uint8_t CRC_GetIDRegister(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_CRC_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dac.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dac.c
deleted file mode 100644
index 1cfc71ded..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dac.c
+++ /dev/null
@@ -1,571 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_dac.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the DAC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_dac.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup DAC 
-  * @brief DAC driver modules
-  * @{
-  */ 
-
-/** @defgroup DAC_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Private_Defines
-  * @{
-  */
-
-/* CR register Mask */
-#define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
-
-/* DAC Dual Channels SWTRIG masks */
-#define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
-#define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
-
-/* DHR registers offsets */
-#define DHR12R1_OFFSET             ((uint32_t)0x00000008)
-#define DHR12R2_OFFSET             ((uint32_t)0x00000014)
-#define DHR12RD_OFFSET             ((uint32_t)0x00000020)
-
-/* DOR register offset */
-#define DOR_OFFSET                 ((uint32_t)0x0000002C)
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void DAC_DeInit(void)
-{
-  /* Enable DAC reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
-  /* Release DAC from reset state */
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
-}
-
-/**
-  * @brief  Initializes the DAC peripheral according to the specified 
-  *         parameters in the DAC_InitStruct.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
-  *        contains the configuration information for the specified DAC channel.
-  * @retval None
-  */
-void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
-{
-  uint32_t tmpreg1 = 0, tmpreg2 = 0;
-  /* Check the DAC parameters */
-  assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
-  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
-  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
-  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
-/*---------------------------- DAC CR Configuration --------------------------*/
-  /* Get the DAC CR value */
-  tmpreg1 = DAC->CR;
-  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
-  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
-  /* Configure for the selected DAC channel: buffer output, trigger, wave generation,
-     mask/amplitude for wave generation */
-  /* Set TSELx and TENx bits according to DAC_Trigger value */
-  /* Set WAVEx bits according to DAC_WaveGeneration value */
-  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
-  /* Set BOFFx bit according to DAC_OutputBuffer value */   
-  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
-             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
-  /* Calculate CR register value depending on DAC_Channel */
-  tmpreg1 |= tmpreg2 << DAC_Channel;
-  /* Write to DAC CR */
-  DAC->CR = tmpreg1;
-}
-
-/**
-  * @brief  Fills each DAC_InitStruct member with its default value.
-  * @param  DAC_InitStruct : pointer to a DAC_InitTypeDef structure which will
-  *         be initialized.
-  * @retval None
-  */
-void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
-{
-/*--------------- Reset DAC init structure parameters values -----------------*/
-  /* Initialize the DAC_Trigger member */
-  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
-  /* Initialize the DAC_WaveGeneration member */
-  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
-  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
-  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
-  /* Initialize the DAC_OutputBuffer member */
-  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
-}
-
-/**
-  * @brief  Enables or disables the specified DAC channel.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  NewState: new state of the DAC channel. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC channel */
-    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
-  }
-  else
-  {
-    /* Disable the selected DAC channel */
-    DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel);
-  }
-}
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-/**
-  * @brief  Enables or disables the specified DAC interrupts.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
-  *   This parameter can be the following values:
-  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                      
-  * @param  NewState: new state of the specified DAC interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */ 
-void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_DAC_IT(DAC_IT)); 
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC interrupts */
-    DAC->CR |=  (DAC_IT << DAC_Channel);
-  }
-  else
-  {
-    /* Disable the selected DAC interrupts */
-    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
-  }
-}
-#endif
-
-/**
-  * @brief  Enables or disables the specified DAC channel DMA request.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  NewState: new state of the selected DAC channel DMA request.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DAC channel DMA request */
-    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
-  }
-  else
-  {
-    /* Disable the selected DAC channel DMA request */
-    DAC->CR &= ~(DAC_CR_DMAEN1 << DAC_Channel);
-  }
-}
-
-/**
-  * @brief  Enables or disables the selected DAC channel software trigger.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  NewState: new state of the selected DAC channel software trigger.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable software trigger for the selected DAC channel */
-    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
-  }
-  else
-  {
-    /* Disable software trigger for the selected DAC channel */
-    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
-  }
-}
-
-/**
-  * @brief  Enables or disables simultaneously the two DAC channels software
-  *   triggers.
-  * @param  NewState: new state of the DAC channels software triggers.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable software trigger for both DAC channels */
-    DAC->SWTRIGR |= DUAL_SWTRIG_SET ;
-  }
-  else
-  {
-    /* Disable software trigger for both DAC channels */
-    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
-  }
-}
-
-/**
-  * @brief  Enables or disables the selected DAC channel wave generation.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_Wave: Specifies the wave type to enable or disable.
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Wave_Noise: noise wave generation
-  *     @arg DAC_Wave_Triangle: triangle wave generation
-  * @param  NewState: new state of the selected DAC channel wave generation.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_WAVE(DAC_Wave)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected wave generation for the selected DAC channel */
-    DAC->CR |= DAC_Wave << DAC_Channel;
-  }
-  else
-  {
-    /* Disable the selected wave generation for the selected DAC channel */
-    DAC->CR &= ~(DAC_Wave << DAC_Channel);
-  }
-}
-
-/**
-  * @brief  Set the specified data holding register value for DAC channel1.
-  * @param  DAC_Align: Specifies the data alignment for DAC channel1.
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Align_8b_R: 8bit right data alignment selected
-  *     @arg DAC_Align_12b_L: 12bit left data alignment selected
-  *     @arg DAC_Align_12b_R: 12bit right data alignment selected
-  * @param  Data : Data to be loaded in the selected data holding register.
-  * @retval None
-  */
-void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
-{  
-  __IO uint32_t tmp = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data));
-  
-  tmp = (uint32_t)DAC_BASE; 
-  tmp += DHR12R1_OFFSET + DAC_Align;
-
-  /* Set the DAC channel1 selected data holding register */
-  *(__IO uint32_t *) tmp = Data;
-}
-
-/**
-  * @brief  Set the specified data holding register value for DAC channel2.
-  * @param  DAC_Align: Specifies the data alignment for DAC channel2.
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Align_8b_R: 8bit right data alignment selected
-  *     @arg DAC_Align_12b_L: 12bit left data alignment selected
-  *     @arg DAC_Align_12b_R: 12bit right data alignment selected
-  * @param  Data : Data to be loaded in the selected data holding register.
-  * @retval None
-  */
-void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
-{
-  __IO uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data));
-  
-  tmp = (uint32_t)DAC_BASE;
-  tmp += DHR12R2_OFFSET + DAC_Align;
-
-  /* Set the DAC channel2 selected data holding register */
-  *(__IO uint32_t *)tmp = Data;
-}
-
-/**
-  * @brief  Set the specified data holding register value for dual channel
-  *   DAC.
-  * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Align_8b_R: 8bit right data alignment selected
-  *     @arg DAC_Align_12b_L: 12bit left data alignment selected
-  *     @arg DAC_Align_12b_R: 12bit right data alignment selected
-  * @param  Data2: Data for DAC Channel2 to be loaded in the selected data 
-  *   holding register.
-  * @param  Data1: Data for DAC Channel1 to be loaded in the selected data 
-  *   holding register.
-  * @retval None
-  */
-void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
-{
-  uint32_t data = 0, tmp = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_DAC_ALIGN(DAC_Align));
-  assert_param(IS_DAC_DATA(Data1));
-  assert_param(IS_DAC_DATA(Data2));
-  
-  /* Calculate and set dual DAC data holding register value */
-  if (DAC_Align == DAC_Align_8b_R)
-  {
-    data = ((uint32_t)Data2 << 8) | Data1; 
-  }
-  else
-  {
-    data = ((uint32_t)Data2 << 16) | Data1;
-  }
-  
-  tmp = (uint32_t)DAC_BASE;
-  tmp += DHR12RD_OFFSET + DAC_Align;
-
-  /* Set the dual DAC selected data holding register */
-  *(__IO uint32_t *)tmp = data;
-}
-
-/**
-  * @brief  Returns the last data output value of the selected DAC channel.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @retval The selected DAC channel data output value.
-  */
-uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
-{
-  __IO uint32_t tmp = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  
-  tmp = (uint32_t) DAC_BASE ;
-  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
-  
-  /* Returns the DAC channel data output register value */
-  return (uint16_t) (*(__IO uint32_t*) tmp);
-}
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-/**
-  * @brief  Checks whether the specified DAC flag is set or not.
-  * @param  DAC_Channel: thee selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_FLAG: specifies the flag to check. 
-  *   This parameter can be only of the following value:
-  *     @arg DAC_FLAG_DMAUDR: DMA underrun flag                                                 
-  * @retval The new state of DAC_FLAG (SET or RESET).
-  */
-FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_FLAG(DAC_FLAG));
-
-  /* Check the status of the specified DAC flag */
-  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
-  {
-    /* DAC_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DAC_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the DAC_FLAG status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the DAC channelx's pending flags.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_FLAG: specifies the flag to clear. 
-  *   This parameter can be of the following value:
-  *     @arg DAC_FLAG_DMAUDR: DMA underrun flag                           
-  * @retval None
-  */
-void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_FLAG(DAC_FLAG));
-
-  /* Clear the selected DAC flags */
-  DAC->SR = (DAC_FLAG << DAC_Channel);
-}
-
-/**
-  * @brief  Checks whether the specified DAC interrupt has occurred or not.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_IT: specifies the DAC interrupt source to check. 
-  *   This parameter can be the following values:
-  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                       
-  * @retval The new state of DAC_IT (SET or RESET).
-  */
-ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t enablestatus = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_IT(DAC_IT));
-
-  /* Get the DAC_IT enable bit status */
-  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
-  
-  /* Check the status of the specified DAC interrupt */
-  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
-  {
-    /* DAC_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DAC_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the DAC_IT status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the DAC channelx's interrupt pending bits.
-  * @param  DAC_Channel: the selected DAC channel. 
-  *   This parameter can be one of the following values:
-  *     @arg DAC_Channel_1: DAC Channel1 selected
-  *     @arg DAC_Channel_2: DAC Channel2 selected
-  * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
-  *   This parameter can be the following values:
-  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
-  * @retval None
-  */
-void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_DAC_CHANNEL(DAC_Channel));
-  assert_param(IS_DAC_IT(DAC_IT)); 
-
-  /* Clear the selected DAC interrupt pending bits */
-  DAC->SR = (DAC_IT << DAC_Channel);
-}
-#endif
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dac.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dac.h
deleted file mode 100644
index 174773cdb..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dac.h
+++ /dev/null
@@ -1,317 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_dac.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the DAC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_DAC_H
-#define __STM32F10x_DAC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup DAC
-  * @{
-  */
-
-/** @defgroup DAC_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  DAC Init structure definition
-  */
-
-typedef struct
-{
-  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
-                                                  This parameter can be a value of @ref DAC_trigger_selection */
-
-  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
-                                                  are generated, or whether no wave is generated.
-                                                  This parameter can be a value of @ref DAC_wave_generation */
-
-  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
-                                                  the maximum amplitude triangle generation for the DAC channel. 
-                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
-
-  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
-                                                  This parameter can be a value of @ref DAC_output_buffer */
-}DAC_InitTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Exported_Constants
-  * @{
-  */
-
-/** @defgroup DAC_trigger_selection 
-  * @{
-  */
-
-#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
-                                                                       has been loaded, and not by external trigger */
-#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
-#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel
-                                                                       only in High-density devices*/
-#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel
-                                                                       only in Connectivity line, Medium-density and Low-density Value Line devices */
-#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
-#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
-#define DAC_Trigger_T15_TRGO               ((uint32_t)0x0000001C) /*!< TIM15 TRGO selected as external conversion trigger for DAC channel 
-                                                                       only in Medium-density and Low-density Value Line devices*/
-#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
-#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
-#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
-#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */
-
-#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
-                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
-                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
-                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
-                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
-                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
-                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
-                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
-                                 ((TRIGGER) == DAC_Trigger_Software))
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_wave_generation 
-  * @{
-  */
-
-#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
-#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
-#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
-#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
-                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
-                                    ((WAVE) == DAC_WaveGeneration_Triangle))
-/**
-  * @}
-  */
-
-/** @defgroup DAC_lfsrunmask_triangleamplitude
-  * @{
-  */
-
-#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
-#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
-#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
-#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
-#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
-#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
-#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
-#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
-#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
-#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
-#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
-#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
-#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
-#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
-#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
-
-#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
-                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
-                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
-/**
-  * @}
-  */
-
-/** @defgroup DAC_output_buffer 
-  * @{
-  */
-
-#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
-#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
-#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
-                                           ((STATE) == DAC_OutputBuffer_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Channel_selection 
-  * @{
-  */
-
-#define DAC_Channel_1                      ((uint32_t)0x00000000)
-#define DAC_Channel_2                      ((uint32_t)0x00000010)
-#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
-                                 ((CHANNEL) == DAC_Channel_2))
-/**
-  * @}
-  */
-
-/** @defgroup DAC_data_alignment 
-  * @{
-  */
-
-#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
-#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
-#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
-#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
-                             ((ALIGN) == DAC_Align_12b_L) || \
-                             ((ALIGN) == DAC_Align_8b_R))
-/**
-  * @}
-  */
-
-/** @defgroup DAC_wave_generation 
-  * @{
-  */
-
-#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
-#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
-#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
-                           ((WAVE) == DAC_Wave_Triangle))
-/**
-  * @}
-  */
-
-/** @defgroup DAC_data 
-  * @{
-  */
-
-#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
-/**
-  * @}
-  */
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)  || defined (STM32F10X_HD_VL)
-/** @defgroup DAC_interrupts_definition 
-  * @{
-  */ 
-  
-#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
-#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup DAC_flags_definition 
-  * @{
-  */ 
-  
-#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)  
-#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  
-
-/**
-  * @}
-  */
-#endif
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DAC_Exported_Functions
-  * @{
-  */
-
-void DAC_DeInit(void);
-void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
-void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
-void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
-#endif
-void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
-void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
-void DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
-void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
-void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
-void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
-void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
-uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) 
-FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
-void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
-ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
-void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_DAC_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dbgmcu.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dbgmcu.c
deleted file mode 100644
index 96a8fde37..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dbgmcu.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_dbgmcu.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the DBGMCU firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_dbgmcu.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup DBGMCU 
-  * @brief DBGMCU driver modules
-  * @{
-  */ 
-
-/** @defgroup DBGMCU_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Private_Defines
-  * @{
-  */
-
-#define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Returns the device revision identifier.
-  * @param  None
-  * @retval Device revision identifier
-  */
-uint32_t DBGMCU_GetREVID(void)
-{
-   return(DBGMCU->IDCODE >> 16);
-}
-
-/**
-  * @brief  Returns the device identifier.
-  * @param  None
-  * @retval Device identifier
-  */
-uint32_t DBGMCU_GetDEVID(void)
-{
-   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
-}
-
-/**
-  * @brief  Configures the specified peripheral and low power mode behavior
-  *   when the MCU under Debug mode.
-  * @param  DBGMCU_Periph: specifies the peripheral and low power mode.
-  *   This parameter can be any combination of the following values:
-  *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode              
-  *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode               
-  *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode            
-  *     @arg DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted          
-  *     @arg DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted          
-  *     @arg DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted          
-  *     @arg DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted          
-  *     @arg DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted          
-  *     @arg DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted          
-  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted           
-  *     @arg DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped when Core is halted
-  *     @arg DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped when Core is halted
-  *     @arg DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted          
-  *     @arg DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted          
-  *     @arg DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted          
-  *     @arg DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted
-  *     @arg DBGMCU_CAN2_STOP: Debug CAN2 stopped when Core is halted 
-  *     @arg DBGMCU_TIM15_STOP: TIM15 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM16_STOP: TIM16 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM17_STOP: TIM17 counter stopped when Core is halted                
-  *     @arg DBGMCU_TIM9_STOP: TIM9 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM10_STOP: TIM10 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM11_STOP: TIM11 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM12_STOP: TIM12 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM13_STOP: TIM13 counter stopped when Core is halted
-  *     @arg DBGMCU_TIM14_STOP: TIM14 counter stopped when Core is halted
-  * @param  NewState: new state of the specified peripheral in Debug mode.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    DBGMCU->CR |= DBGMCU_Periph;
-  }
-  else
-  {
-    DBGMCU->CR &= ~DBGMCU_Periph;
-  }
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dbgmcu.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dbgmcu.h
deleted file mode 100644
index 89ceb9a41..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dbgmcu.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_dbgmcu.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the DBGMCU 
-  *          firmware library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_DBGMCU_H
-#define __STM32F10x_DBGMCU_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup DBGMCU
-  * @{
-  */
-
-/** @defgroup DBGMCU_Exported_Types
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Exported_Constants
-  * @{
-  */
-
-#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
-#define DBGMCU_STOP                  ((uint32_t)0x00000002)
-#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
-#define DBGMCU_IWDG_STOP             ((uint32_t)0x00000100)
-#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000200)
-#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000400)
-#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000800)
-#define DBGMCU_TIM3_STOP             ((uint32_t)0x00001000)
-#define DBGMCU_TIM4_STOP             ((uint32_t)0x00002000)
-#define DBGMCU_CAN1_STOP             ((uint32_t)0x00004000)
-#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)
-#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)
-#define DBGMCU_TIM8_STOP             ((uint32_t)0x00020000)
-#define DBGMCU_TIM5_STOP             ((uint32_t)0x00040000)
-#define DBGMCU_TIM6_STOP             ((uint32_t)0x00080000)
-#define DBGMCU_TIM7_STOP             ((uint32_t)0x00100000)
-#define DBGMCU_CAN2_STOP             ((uint32_t)0x00200000)
-#define DBGMCU_TIM15_STOP            ((uint32_t)0x00400000)
-#define DBGMCU_TIM16_STOP            ((uint32_t)0x00800000)
-#define DBGMCU_TIM17_STOP            ((uint32_t)0x01000000)
-#define DBGMCU_TIM12_STOP            ((uint32_t)0x02000000)
-#define DBGMCU_TIM13_STOP            ((uint32_t)0x04000000)
-#define DBGMCU_TIM14_STOP            ((uint32_t)0x08000000)
-#define DBGMCU_TIM9_STOP             ((uint32_t)0x10000000)
-#define DBGMCU_TIM10_STOP            ((uint32_t)0x20000000)
-#define DBGMCU_TIM11_STOP            ((uint32_t)0x40000000)
-                                              
-#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0x800000F8) == 0x00) && ((PERIPH) != 0x00))
-/**
-  * @}
-  */ 
-
-/** @defgroup DBGMCU_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DBGMCU_Exported_Functions
-  * @{
-  */
-
-uint32_t DBGMCU_GetREVID(void);
-uint32_t DBGMCU_GetDEVID(void);
-void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_DBGMCU_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dma.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dma.c
deleted file mode 100644
index bf072df3a..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dma.c
+++ /dev/null
@@ -1,714 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_dma.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the DMA firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_dma.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup DMA 
-  * @brief DMA driver modules
-  * @{
-  */ 
-
-/** @defgroup DMA_Private_TypesDefinitions
-  * @{
-  */ 
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Private_Defines
-  * @{
-  */
-
-
-/* DMA1 Channelx interrupt pending bit masks */
-#define DMA1_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))
-#define DMA1_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))
-#define DMA1_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))
-#define DMA1_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))
-#define DMA1_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))
-#define DMA1_Channel6_IT_Mask    ((uint32_t)(DMA_ISR_GIF6 | DMA_ISR_TCIF6 | DMA_ISR_HTIF6 | DMA_ISR_TEIF6))
-#define DMA1_Channel7_IT_Mask    ((uint32_t)(DMA_ISR_GIF7 | DMA_ISR_TCIF7 | DMA_ISR_HTIF7 | DMA_ISR_TEIF7))
-
-/* DMA2 Channelx interrupt pending bit masks */
-#define DMA2_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))
-#define DMA2_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))
-#define DMA2_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))
-#define DMA2_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))
-#define DMA2_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))
-
-/* DMA2 FLAG mask */
-#define FLAG_Mask                ((uint32_t)0x10000000)
-
-/* DMA registers Masks */
-#define CCR_CLEAR_Mask           ((uint32_t)0xFFFF800F)
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the DMAy Channelx registers to their default reset
-  *         values.
-  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
-  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
-  * @retval None
-  */
-void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  
-  /* Disable the selected DMAy Channelx */
-  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
-  
-  /* Reset DMAy Channelx control register */
-  DMAy_Channelx->CCR  = 0;
-  
-  /* Reset DMAy Channelx remaining bytes register */
-  DMAy_Channelx->CNDTR = 0;
-  
-  /* Reset DMAy Channelx peripheral address register */
-  DMAy_Channelx->CPAR  = 0;
-  
-  /* Reset DMAy Channelx memory address register */
-  DMAy_Channelx->CMAR = 0;
-  
-  if (DMAy_Channelx == DMA1_Channel1)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel1 */
-    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA1_Channel2)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel2 */
-    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA1_Channel3)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel3 */
-    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA1_Channel4)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel4 */
-    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA1_Channel5)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel5 */
-    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA1_Channel6)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel6 */
-    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA1_Channel7)
-  {
-    /* Reset interrupt pending bits for DMA1 Channel7 */
-    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA2_Channel1)
-  {
-    /* Reset interrupt pending bits for DMA2 Channel1 */
-    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA2_Channel2)
-  {
-    /* Reset interrupt pending bits for DMA2 Channel2 */
-    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA2_Channel3)
-  {
-    /* Reset interrupt pending bits for DMA2 Channel3 */
-    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
-  }
-  else if (DMAy_Channelx == DMA2_Channel4)
-  {
-    /* Reset interrupt pending bits for DMA2 Channel4 */
-    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
-  }
-  else
-  { 
-    if (DMAy_Channelx == DMA2_Channel5)
-    {
-      /* Reset interrupt pending bits for DMA2 Channel5 */
-      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
-    }
-  }
-}
-
-/**
-  * @brief  Initializes the DMAy Channelx according to the specified
-  *         parameters in the DMA_InitStruct.
-  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
-  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
-  *         contains the configuration information for the specified DMA Channel.
-  * @retval None
-  */
-void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
-{
-  uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));
-  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
-  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
-  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));   
-  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
-  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
-  assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
-  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
-  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));
-
-/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
-  /* Get the DMAy_Channelx CCR value */
-  tmpreg = DMAy_Channelx->CCR;
-  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
-  tmpreg &= CCR_CLEAR_Mask;
-  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
-  /* Set DIR bit according to DMA_DIR value */
-  /* Set CIRC bit according to DMA_Mode value */
-  /* Set PINC bit according to DMA_PeripheralInc value */
-  /* Set MINC bit according to DMA_MemoryInc value */
-  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
-  /* Set MSIZE bits according to DMA_MemoryDataSize value */
-  /* Set PL bits according to DMA_Priority value */
-  /* Set the MEM2MEM bit according to DMA_M2M value */
-  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
-            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
-            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
-            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
-
-  /* Write to DMAy Channelx CCR */
-  DMAy_Channelx->CCR = tmpreg;
-
-/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
-  /* Write to DMAy Channelx CNDTR */
-  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
-
-/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
-  /* Write to DMAy Channelx CPAR */
-  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
-
-/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
-  /* Write to DMAy Channelx CMAR */
-  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
-}
-
-/**
-  * @brief  Fills each DMA_InitStruct member with its default value.
-  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will
-  *         be initialized.
-  * @retval None
-  */
-void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
-{
-/*-------------- Reset DMA init structure parameters values ------------------*/
-  /* Initialize the DMA_PeripheralBaseAddr member */
-  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
-  /* Initialize the DMA_MemoryBaseAddr member */
-  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
-  /* Initialize the DMA_DIR member */
-  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
-  /* Initialize the DMA_BufferSize member */
-  DMA_InitStruct->DMA_BufferSize = 0;
-  /* Initialize the DMA_PeripheralInc member */
-  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-  /* Initialize the DMA_MemoryInc member */
-  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
-  /* Initialize the DMA_PeripheralDataSize member */
-  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
-  /* Initialize the DMA_MemoryDataSize member */
-  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
-  /* Initialize the DMA_Mode member */
-  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
-  /* Initialize the DMA_Priority member */
-  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
-  /* Initialize the DMA_M2M member */
-  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
-}
-
-/**
-  * @brief  Enables or disables the specified DMAy Channelx.
-  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
-  * @param  NewState: new state of the DMAy Channelx. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DMAy Channelx */
-    DMAy_Channelx->CCR |= DMA_CCR1_EN;
-  }
-  else
-  {
-    /* Disable the selected DMAy Channelx */
-    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified DMAy Channelx interrupts.
-  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
-  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled
-  *   or disabled. 
-  *   This parameter can be any combination of the following values:
-  *     @arg DMA_IT_TC:  Transfer complete interrupt mask
-  *     @arg DMA_IT_HT:  Half transfer interrupt mask
-  *     @arg DMA_IT_TE:  Transfer error interrupt mask
-  * @param  NewState: new state of the specified DMA interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected DMA interrupts */
-    DMAy_Channelx->CCR |= DMA_IT;
-  }
-  else
-  {
-    /* Disable the selected DMA interrupts */
-    DMAy_Channelx->CCR &= ~DMA_IT;
-  }
-}
-
-/**
-  * @brief  Sets the number of data units in the current DMAy Channelx transfer.
-  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-  *         x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
-  * @param  DataNumber: The number of data units in the current DMAy Channelx
-  *         transfer.   
-  * @note   This function can only be used when the DMAy_Channelx is disabled.                 
-  * @retval None.
-  */
-void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  
-/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
-  /* Write to DMAy Channelx CNDTR */
-  DMAy_Channelx->CNDTR = DataNumber;  
-}
-
-/**
-  * @brief  Returns the number of remaining data units in the current
-  *         DMAy Channelx transfer.
-  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
-  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
-  * @retval The number of remaining data units in the current DMAy Channelx
-  *         transfer.
-  */
-uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
-  /* Return the number of remaining data units for DMAy Channelx */
-  return ((uint16_t)(DMAy_Channelx->CNDTR));
-}
-
-/**
-  * @brief  Checks whether the specified DMAy Channelx flag is set or not.
-  * @param  DMAy_FLAG: specifies the flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.
-  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
-  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
-  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
-  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.
-  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
-  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
-  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
-  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.
-  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
-  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
-  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
-  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.
-  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
-  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
-  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
-  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.
-  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
-  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
-  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
-  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.
-  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
-  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
-  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
-  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.
-  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
-  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
-  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
-  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.
-  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
-  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
-  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
-  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.
-  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
-  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
-  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
-  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.
-  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
-  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
-  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
-  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.
-  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
-  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
-  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
-  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.
-  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
-  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
-  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
-  * @retval The new state of DMAy_FLAG (SET or RESET).
-  */
-FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  uint32_t tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));
-
-  /* Calculate the used DMAy */
-  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
-  {
-    /* Get DMA2 ISR register value */
-    tmpreg = DMA2->ISR ;
-  }
-  else
-  {
-    /* Get DMA1 ISR register value */
-    tmpreg = DMA1->ISR ;
-  }
-
-  /* Check the status of the specified DMAy flag */
-  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
-  {
-    /* DMAy_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DMAy_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the DMAy_FLAG status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the DMAy Channelx's pending flags.
-  * @param  DMAy_FLAG: specifies the flag to clear.
-  *   This parameter can be any combination (for the same DMA) of the following values:
-  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.
-  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
-  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
-  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
-  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.
-  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
-  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
-  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
-  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.
-  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
-  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
-  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
-  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.
-  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
-  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
-  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
-  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.
-  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
-  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
-  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
-  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.
-  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
-  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
-  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
-  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.
-  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
-  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
-  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
-  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.
-  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
-  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
-  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
-  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.
-  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
-  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
-  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
-  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.
-  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
-  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
-  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
-  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.
-  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
-  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
-  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
-  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.
-  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
-  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
-  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
-  * @retval None
-  */
-void DMA_ClearFlag(uint32_t DMAy_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));
-
-  /* Calculate the used DMAy */
-  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
-  {
-    /* Clear the selected DMAy flags */
-    DMA2->IFCR = DMAy_FLAG;
-  }
-  else
-  {
-    /* Clear the selected DMAy flags */
-    DMA1->IFCR = DMAy_FLAG;
-  }
-}
-
-/**
-  * @brief  Checks whether the specified DMAy Channelx interrupt has occurred or not.
-  * @param  DMAy_IT: specifies the DMAy interrupt source to check. 
-  *   This parameter can be one of the following values:
-  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.
-  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
-  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
-  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
-  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.
-  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
-  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
-  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
-  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.
-  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
-  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
-  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
-  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.
-  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
-  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
-  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
-  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.
-  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
-  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
-  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
-  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.
-  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
-  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
-  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
-  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.
-  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
-  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
-  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
-  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.
-  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
-  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
-  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
-  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.
-  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
-  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
-  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
-  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.
-  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
-  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
-  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
-  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.
-  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
-  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
-  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
-  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.
-  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
-  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
-  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
-  * @retval The new state of DMAy_IT (SET or RESET).
-  */
-ITStatus DMA_GetITStatus(uint32_t DMAy_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_DMA_GET_IT(DMAy_IT));
-
-  /* Calculate the used DMA */
-  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
-  {
-    /* Get DMA2 ISR register value */
-    tmpreg = DMA2->ISR;
-  }
-  else
-  {
-    /* Get DMA1 ISR register value */
-    tmpreg = DMA1->ISR;
-  }
-
-  /* Check the status of the specified DMAy interrupt */
-  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
-  {
-    /* DMAy_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* DMAy_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the DMA_IT status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the DMAy Channelx's interrupt pending bits.
-  * @param  DMAy_IT: specifies the DMAy interrupt pending bit to clear.
-  *   This parameter can be any combination (for the same DMA) of the following values:
-  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.
-  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
-  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
-  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
-  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.
-  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
-  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
-  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
-  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.
-  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
-  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
-  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
-  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.
-  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
-  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
-  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
-  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.
-  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
-  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
-  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
-  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.
-  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
-  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
-  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
-  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.
-  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
-  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
-  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
-  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.
-  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
-  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
-  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
-  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.
-  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
-  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
-  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
-  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.
-  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
-  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
-  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
-  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.
-  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
-  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
-  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
-  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.
-  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
-  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
-  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
-  * @retval None
-  */
-void DMA_ClearITPendingBit(uint32_t DMAy_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));
-
-  /* Calculate the used DMAy */
-  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
-  {
-    /* Clear the selected DMAy interrupt pending bits */
-    DMA2->IFCR = DMAy_IT;
-  }
-  else
-  {
-    /* Clear the selected DMAy interrupt pending bits */
-    DMA1->IFCR = DMAy_IT;
-  }
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dma.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dma.h
deleted file mode 100644
index 14275fe1a..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_dma.h
+++ /dev/null
@@ -1,439 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_dma.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the DMA firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_DMA_H
-#define __STM32F10x_DMA_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup DMA
-  * @{
-  */
-
-/** @defgroup DMA_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  DMA Init structure definition
-  */
-
-typedef struct
-{
-  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */
-
-  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */
-
-  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.
-                                        This parameter can be a value of @ref DMA_data_transfer_direction */
-
-  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. 
-                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
-                                        or DMA_MemoryDataSize members depending in the transfer direction. */
-
-  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.
-                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
-
-  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.
-                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
-
-  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
-                                        This parameter can be a value of @ref DMA_peripheral_data_size */
-
-  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
-                                        This parameter can be a value of @ref DMA_memory_data_size */
-
-  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.
-                                        This parameter can be a value of @ref DMA_circular_normal_mode.
-                                        @note: The circular buffer mode cannot be used if the memory-to-memory
-                                              data transfer is configured on the selected Channel */
-
-  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.
-                                        This parameter can be a value of @ref DMA_priority_level */
-
-  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
-                                        This parameter can be a value of @ref DMA_memory_to_memory */
-}DMA_InitTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Exported_Constants
-  * @{
-  */
-
-#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
-                                   ((PERIPH) == DMA1_Channel2) || \
-                                   ((PERIPH) == DMA1_Channel3) || \
-                                   ((PERIPH) == DMA1_Channel4) || \
-                                   ((PERIPH) == DMA1_Channel5) || \
-                                   ((PERIPH) == DMA1_Channel6) || \
-                                   ((PERIPH) == DMA1_Channel7) || \
-                                   ((PERIPH) == DMA2_Channel1) || \
-                                   ((PERIPH) == DMA2_Channel2) || \
-                                   ((PERIPH) == DMA2_Channel3) || \
-                                   ((PERIPH) == DMA2_Channel4) || \
-                                   ((PERIPH) == DMA2_Channel5))
-
-/** @defgroup DMA_data_transfer_direction 
-  * @{
-  */
-
-#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)
-#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
-#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \
-                         ((DIR) == DMA_DIR_PeripheralSRC))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_peripheral_incremented_mode 
-  * @{
-  */
-
-#define DMA_PeripheralInc_Enable           ((uint32_t)0x00000040)
-#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
-#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
-                                            ((STATE) == DMA_PeripheralInc_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_memory_incremented_mode 
-  * @{
-  */
-
-#define DMA_MemoryInc_Enable               ((uint32_t)0x00000080)
-#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
-#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
-                                        ((STATE) == DMA_MemoryInc_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_peripheral_data_size 
-  * @{
-  */
-
-#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
-#define DMA_PeripheralDataSize_HalfWord    ((uint32_t)0x00000100)
-#define DMA_PeripheralDataSize_Word        ((uint32_t)0x00000200)
-#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
-                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
-                                           ((SIZE) == DMA_PeripheralDataSize_Word))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_memory_data_size 
-  * @{
-  */
-
-#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
-#define DMA_MemoryDataSize_HalfWord        ((uint32_t)0x00000400)
-#define DMA_MemoryDataSize_Word            ((uint32_t)0x00000800)
-#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
-                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
-                                       ((SIZE) == DMA_MemoryDataSize_Word))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_circular_normal_mode 
-  * @{
-  */
-
-#define DMA_Mode_Circular                  ((uint32_t)0x00000020)
-#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
-#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_priority_level 
-  * @{
-  */
-
-#define DMA_Priority_VeryHigh              ((uint32_t)0x00003000)
-#define DMA_Priority_High                  ((uint32_t)0x00002000)
-#define DMA_Priority_Medium                ((uint32_t)0x00001000)
-#define DMA_Priority_Low                   ((uint32_t)0x00000000)
-#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
-                                   ((PRIORITY) == DMA_Priority_High) || \
-                                   ((PRIORITY) == DMA_Priority_Medium) || \
-                                   ((PRIORITY) == DMA_Priority_Low))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_memory_to_memory 
-  * @{
-  */
-
-#define DMA_M2M_Enable                     ((uint32_t)0x00004000)
-#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
-#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_interrupts_definition 
-  * @{
-  */
-
-#define DMA_IT_TC                          ((uint32_t)0x00000002)
-#define DMA_IT_HT                          ((uint32_t)0x00000004)
-#define DMA_IT_TE                          ((uint32_t)0x00000008)
-#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
-
-#define DMA1_IT_GL1                        ((uint32_t)0x00000001)
-#define DMA1_IT_TC1                        ((uint32_t)0x00000002)
-#define DMA1_IT_HT1                        ((uint32_t)0x00000004)
-#define DMA1_IT_TE1                        ((uint32_t)0x00000008)
-#define DMA1_IT_GL2                        ((uint32_t)0x00000010)
-#define DMA1_IT_TC2                        ((uint32_t)0x00000020)
-#define DMA1_IT_HT2                        ((uint32_t)0x00000040)
-#define DMA1_IT_TE2                        ((uint32_t)0x00000080)
-#define DMA1_IT_GL3                        ((uint32_t)0x00000100)
-#define DMA1_IT_TC3                        ((uint32_t)0x00000200)
-#define DMA1_IT_HT3                        ((uint32_t)0x00000400)
-#define DMA1_IT_TE3                        ((uint32_t)0x00000800)
-#define DMA1_IT_GL4                        ((uint32_t)0x00001000)
-#define DMA1_IT_TC4                        ((uint32_t)0x00002000)
-#define DMA1_IT_HT4                        ((uint32_t)0x00004000)
-#define DMA1_IT_TE4                        ((uint32_t)0x00008000)
-#define DMA1_IT_GL5                        ((uint32_t)0x00010000)
-#define DMA1_IT_TC5                        ((uint32_t)0x00020000)
-#define DMA1_IT_HT5                        ((uint32_t)0x00040000)
-#define DMA1_IT_TE5                        ((uint32_t)0x00080000)
-#define DMA1_IT_GL6                        ((uint32_t)0x00100000)
-#define DMA1_IT_TC6                        ((uint32_t)0x00200000)
-#define DMA1_IT_HT6                        ((uint32_t)0x00400000)
-#define DMA1_IT_TE6                        ((uint32_t)0x00800000)
-#define DMA1_IT_GL7                        ((uint32_t)0x01000000)
-#define DMA1_IT_TC7                        ((uint32_t)0x02000000)
-#define DMA1_IT_HT7                        ((uint32_t)0x04000000)
-#define DMA1_IT_TE7                        ((uint32_t)0x08000000)
-
-#define DMA2_IT_GL1                        ((uint32_t)0x10000001)
-#define DMA2_IT_TC1                        ((uint32_t)0x10000002)
-#define DMA2_IT_HT1                        ((uint32_t)0x10000004)
-#define DMA2_IT_TE1                        ((uint32_t)0x10000008)
-#define DMA2_IT_GL2                        ((uint32_t)0x10000010)
-#define DMA2_IT_TC2                        ((uint32_t)0x10000020)
-#define DMA2_IT_HT2                        ((uint32_t)0x10000040)
-#define DMA2_IT_TE2                        ((uint32_t)0x10000080)
-#define DMA2_IT_GL3                        ((uint32_t)0x10000100)
-#define DMA2_IT_TC3                        ((uint32_t)0x10000200)
-#define DMA2_IT_HT3                        ((uint32_t)0x10000400)
-#define DMA2_IT_TE3                        ((uint32_t)0x10000800)
-#define DMA2_IT_GL4                        ((uint32_t)0x10001000)
-#define DMA2_IT_TC4                        ((uint32_t)0x10002000)
-#define DMA2_IT_HT4                        ((uint32_t)0x10004000)
-#define DMA2_IT_TE4                        ((uint32_t)0x10008000)
-#define DMA2_IT_GL5                        ((uint32_t)0x10010000)
-#define DMA2_IT_TC5                        ((uint32_t)0x10020000)
-#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
-#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
-
-#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
-
-#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
-                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
-                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
-                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
-                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
-                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
-                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
-                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
-                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
-                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
-                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
-                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
-                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
-                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
-                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
-                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
-                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
-                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
-                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
-                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
-                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
-                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
-                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
-                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_flags_definition 
-  * @{
-  */
-#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)
-#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)
-#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)
-#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)
-#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)
-#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)
-#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)
-#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)
-#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)
-#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)
-#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)
-#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)
-#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)
-#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)
-#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)
-#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)
-#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)
-#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)
-#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)
-#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)
-#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)
-#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)
-#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)
-#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)
-#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)
-#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)
-#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)
-#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)
-
-#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
-#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
-#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
-#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
-#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
-#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
-#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
-#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
-#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
-#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
-#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
-#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
-#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
-#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
-#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
-#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
-#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
-#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
-#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
-#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
-
-#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
-
-#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
-                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
-                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
-                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
-                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
-                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
-                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
-                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
-                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
-                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
-                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
-                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
-                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
-                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
-                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
-                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
-                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
-                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
-                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
-                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
-                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
-                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
-                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
-                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Buffer_Size 
-  * @{
-  */
-
-#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup DMA_Exported_Functions
-  * @{
-  */
-
-void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
-void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
-void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
-void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
-void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
-void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber); 
-uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
-FlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);
-void DMA_ClearFlag(uint32_t DMAy_FLAG);
-ITStatus DMA_GetITStatus(uint32_t DMAy_IT);
-void DMA_ClearITPendingBit(uint32_t DMAy_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_DMA_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_exti.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_exti.c
deleted file mode 100644
index b6290d582..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_exti.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_exti.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the EXTI firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_exti.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup EXTI 
-  * @brief EXTI driver modules
-  * @{
-  */
-
-/** @defgroup EXTI_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Private_Defines
-  * @{
-  */
-
-#define EXTI_LINENONE    ((uint32_t)0x00000)  /* No interrupt selected */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void EXTI_DeInit(void)
-{
-  EXTI->IMR = 0x00000000;
-  EXTI->EMR = 0x00000000;
-  EXTI->RTSR = 0x00000000; 
-  EXTI->FTSR = 0x00000000; 
-  EXTI->PR = 0x000FFFFF;
-}
-
-/**
-  * @brief  Initializes the EXTI peripheral according to the specified
-  *         parameters in the EXTI_InitStruct.
-  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
-  *         that contains the configuration information for the EXTI peripheral.
-  * @retval None
-  */
-void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
-{
-  uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
-  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
-  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
-  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));
-
-  tmp = (uint32_t)EXTI_BASE;
-     
-  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
-  {
-    /* Clear EXTI line configuration */
-    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
-    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
-    
-    tmp += EXTI_InitStruct->EXTI_Mode;
-
-    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
-
-    /* Clear Rising Falling edge configuration */
-    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
-    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
-    
-    /* Select the trigger for the selected external interrupts */
-    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
-    {
-      /* Rising Falling edge */
-      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
-      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
-    }
-    else
-    {
-      tmp = (uint32_t)EXTI_BASE;
-      tmp += EXTI_InitStruct->EXTI_Trigger;
-
-      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
-    }
-  }
-  else
-  {
-    tmp += EXTI_InitStruct->EXTI_Mode;
-
-    /* Disable the selected external lines */
-    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
-  }
-}
-
-/**
-  * @brief  Fills each EXTI_InitStruct member with its reset value.
-  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will
-  *         be initialized.
-  * @retval None
-  */
-void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
-{
-  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
-  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
-  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
-  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
-}
-
-/**
-  * @brief  Generates a Software interrupt.
-  * @param  EXTI_Line: specifies the EXTI lines to be enabled or disabled.
-  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
-  * @retval None
-  */
-void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI->SWIER |= EXTI_Line;
-}
-
-/**
-  * @brief  Checks whether the specified EXTI line flag is set or not.
-  * @param  EXTI_Line: specifies the EXTI line flag to check.
-  *   This parameter can be:
-  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
-  * @retval The new state of EXTI_Line (SET or RESET).
-  */
-FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
-  
-  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the EXTI's line pending flags.
-  * @param  EXTI_Line: specifies the EXTI lines flags to clear.
-  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
-  * @retval None
-  */
-void EXTI_ClearFlag(uint32_t EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI->PR = EXTI_Line;
-}
-
-/**
-  * @brief  Checks whether the specified EXTI line is asserted or not.
-  * @param  EXTI_Line: specifies the EXTI line to check.
-  *   This parameter can be:
-  *     @arg EXTI_Linex: External interrupt line x where x(0..19)
-  * @retval The new state of EXTI_Line (SET or RESET).
-  */
-ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t enablestatus = 0;
-  /* Check the parameters */
-  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
-  
-  enablestatus =  EXTI->IMR & EXTI_Line;
-  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the EXTI's line pending bits.
-  * @param  EXTI_Line: specifies the EXTI lines to clear.
-  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).
-  * @retval None
-  */
-void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
-{
-  /* Check the parameters */
-  assert_param(IS_EXTI_LINE(EXTI_Line));
-  
-  EXTI->PR = EXTI_Line;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_exti.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_exti.h
deleted file mode 100644
index bb9d7f676..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_exti.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_exti.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the EXTI firmware
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_EXTI_H
-#define __STM32F10x_EXTI_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup EXTI
-  * @{
-  */
-
-/** @defgroup EXTI_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  EXTI mode enumeration  
-  */
-
-typedef enum
-{
-  EXTI_Mode_Interrupt = 0x00,
-  EXTI_Mode_Event = 0x04
-}EXTIMode_TypeDef;
-
-#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
-
-/** 
-  * @brief  EXTI Trigger enumeration  
-  */
-
-typedef enum
-{
-  EXTI_Trigger_Rising = 0x08,
-  EXTI_Trigger_Falling = 0x0C,  
-  EXTI_Trigger_Rising_Falling = 0x10
-}EXTITrigger_TypeDef;
-
-#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
-                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
-                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
-/** 
-  * @brief  EXTI Init Structure definition  
-  */
-
-typedef struct
-{
-  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
-                                         This parameter can be any combination of @ref EXTI_Lines */
-   
-  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
-                                         This parameter can be a value of @ref EXTIMode_TypeDef */
-
-  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
-                                         This parameter can be a value of @ref EXTIMode_TypeDef */
-
-  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
-                                         This parameter can be set either to ENABLE or DISABLE */ 
-}EXTI_InitTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Exported_Constants
-  * @{
-  */
-
-/** @defgroup EXTI_Lines 
-  * @{
-  */
-
-#define EXTI_Line0       ((uint32_t)0x00001)  /*!< External interrupt line 0 */
-#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */
-#define EXTI_Line2       ((uint32_t)0x00004)  /*!< External interrupt line 2 */
-#define EXTI_Line3       ((uint32_t)0x00008)  /*!< External interrupt line 3 */
-#define EXTI_Line4       ((uint32_t)0x00010)  /*!< External interrupt line 4 */
-#define EXTI_Line5       ((uint32_t)0x00020)  /*!< External interrupt line 5 */
-#define EXTI_Line6       ((uint32_t)0x00040)  /*!< External interrupt line 6 */
-#define EXTI_Line7       ((uint32_t)0x00080)  /*!< External interrupt line 7 */
-#define EXTI_Line8       ((uint32_t)0x00100)  /*!< External interrupt line 8 */
-#define EXTI_Line9       ((uint32_t)0x00200)  /*!< External interrupt line 9 */
-#define EXTI_Line10      ((uint32_t)0x00400)  /*!< External interrupt line 10 */
-#define EXTI_Line11      ((uint32_t)0x00800)  /*!< External interrupt line 11 */
-#define EXTI_Line12      ((uint32_t)0x01000)  /*!< External interrupt line 12 */
-#define EXTI_Line13      ((uint32_t)0x02000)  /*!< External interrupt line 13 */
-#define EXTI_Line14      ((uint32_t)0x04000)  /*!< External interrupt line 14 */
-#define EXTI_Line15      ((uint32_t)0x08000)  /*!< External interrupt line 15 */
-#define EXTI_Line16      ((uint32_t)0x10000)  /*!< External interrupt line 16 Connected to the PVD Output */
-#define EXTI_Line17      ((uint32_t)0x20000)  /*!< External interrupt line 17 Connected to the RTC Alarm event */
-#define EXTI_Line18      ((uint32_t)0x40000)  /*!< External interrupt line 18 Connected to the USB Device/USB OTG FS
-                                                   Wakeup from suspend event */                                    
-#define EXTI_Line19      ((uint32_t)0x80000)  /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
-                                          
-#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFFF00000) == 0x00) && ((LINE) != (uint16_t)0x00))
-#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
-                            ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
-                            ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
-                            ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
-                            ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
-                            ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
-                            ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
-                            ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
-                            ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
-                            ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19))
-
-                    
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup EXTI_Exported_Functions
-  * @{
-  */
-
-void EXTI_DeInit(void);
-void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
-void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
-void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
-FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
-void EXTI_ClearFlag(uint32_t EXTI_Line);
-ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
-void EXTI_ClearITPendingBit(uint32_t EXTI_Line);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_EXTI_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_flash.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_flash.c
deleted file mode 100644
index cdff9e9b8..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_flash.c
+++ /dev/null
@@ -1,1684 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_flash.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the FLASH firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_flash.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup FLASH 
-  * @brief FLASH driver modules
-  * @{
-  */ 
-
-/** @defgroup FLASH_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */ 
-
-/** @defgroup FLASH_Private_Defines
-  * @{
-  */ 
-
-/* Flash Access Control Register bits */
-#define ACR_LATENCY_Mask         ((uint32_t)0x00000038)
-#define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)
-#define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)
-
-/* Flash Access Control Register bits */
-#define ACR_PRFTBS_Mask          ((uint32_t)0x00000020) 
-
-/* Flash Control Register bits */
-#define CR_PG_Set                ((uint32_t)0x00000001)
-#define CR_PG_Reset              ((uint32_t)0x00001FFE) 
-#define CR_PER_Set               ((uint32_t)0x00000002)
-#define CR_PER_Reset             ((uint32_t)0x00001FFD)
-#define CR_MER_Set               ((uint32_t)0x00000004)
-#define CR_MER_Reset             ((uint32_t)0x00001FFB)
-#define CR_OPTPG_Set             ((uint32_t)0x00000010)
-#define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)
-#define CR_OPTER_Set             ((uint32_t)0x00000020)
-#define CR_OPTER_Reset           ((uint32_t)0x00001FDF)
-#define CR_STRT_Set              ((uint32_t)0x00000040)
-#define CR_LOCK_Set              ((uint32_t)0x00000080)
-
-/* FLASH Mask */
-#define RDPRT_Mask               ((uint32_t)0x00000002)
-#define WRP0_Mask                ((uint32_t)0x000000FF)
-#define WRP1_Mask                ((uint32_t)0x0000FF00)
-#define WRP2_Mask                ((uint32_t)0x00FF0000)
-#define WRP3_Mask                ((uint32_t)0xFF000000)
-#define OB_USER_BFB2             ((uint16_t)0x0008)
-
-/* FLASH Keys */
-#define RDP_Key                  ((uint16_t)0x00A5)
-#define FLASH_KEY1               ((uint32_t)0x45670123)
-#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
-
-/* FLASH BANK address */
-#define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)
-
-/* Delay definition */   
-#define EraseTimeout          ((uint32_t)0x000B0000)
-#define ProgramTimeout        ((uint32_t)0x00002000)
-/**
-  * @}
-  */ 
-
-/** @defgroup FLASH_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */ 
-
-/** @defgroup FLASH_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */ 
-
-/** @defgroup FLASH_Private_FunctionPrototypes
-  * @{
-  */
-  
-/**
-  * @}
-  */
-
-/** @defgroup FLASH_Private_Functions
-  * @{
-  */
-
-/**
-@code  
- 
- This driver provides functions to configure and program the Flash memory of all STM32F10x devices,
- including the latest STM32F10x_XL density devices. 
-
- STM32F10x_XL devices feature up to 1 Mbyte with dual bank architecture for read-while-write (RWW) capability:
-    - bank1: fixed size of 512 Kbytes (256 pages of 2Kbytes each)
-    - bank2: up to 512 Kbytes (up to 256 pages of 2Kbytes each)
- While other STM32F10x devices features only one bank with memory up to 512 Kbytes.
-
- In version V3.3.0, some functions were updated and new ones were added to support
- STM32F10x_XL devices. Thus some functions manages all devices, while other are 
- dedicated for XL devices only.
- 
- The table below presents the list of available functions depending on the used STM32F10x devices.  
-      
-   ***************************************************
-   * Legacy functions used for all STM32F10x devices *
-   ***************************************************
-   +----------------------------------------------------------------------------------------------------------------------------------+
-   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
-   |                                    |   devices  |  devices      |                                                                |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_SetLatency                    |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_HalfCycleAccessCmd            |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_PrefetchBufferCmd             |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_Unlock                        |    Yes     |      Yes      | - For STM32F10X_XL devices: unlock Bank1 and Bank2.            |
-   |                                    |            |               | - For other devices: unlock Bank1 and it is equivalent         |
-   |                                    |            |               |   to FLASH_UnlockBank1 function.                               |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_Lock                          |    Yes     |      Yes      | - For STM32F10X_XL devices: lock Bank1 and Bank2.              |
-   |                                    |            |               | - For other devices: lock Bank1 and it is equivalent           |
-   |                                    |            |               |   to FLASH_LockBank1 function.                                 |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ErasePage                     |    Yes     |      Yes      | - For STM32F10x_XL devices: erase a page in Bank1 and Bank2    |
-   |                                    |            |               | - For other devices: erase a page in Bank1                     |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_EraseAllPages                 |    Yes     |      Yes      | - For STM32F10x_XL devices: erase all pages in Bank1 and Bank2 |
-   |                                    |            |               | - For other devices: erase all pages in Bank1                  |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_EraseOptionBytes              |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ProgramWord                   |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ProgramHalfWord               |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ProgramOptionByteData         |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_EnableWriteProtection         |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ReadOutProtection             |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_UserOptionByteConfig          |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_GetUserOptionByte             |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_GetWriteProtectionOptionByte  |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_GetReadOutProtectionStatus    |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_GetPrefetchBufferStatus       |    Yes     |      Yes      | No change                                                      |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ITConfig                      |    Yes     |      Yes      | - For STM32F10x_XL devices: enable Bank1 and Bank2's interrupts|
-   |                                    |            |               | - For other devices: enable Bank1's interrupts                 |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_GetFlagStatus                 |    Yes     |      Yes      | - For STM32F10x_XL devices: return Bank1 and Bank2's flag status|
-   |                                    |            |               | - For other devices: return Bank1's flag status                |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_ClearFlag                     |    Yes     |      Yes      | - For STM32F10x_XL devices: clear Bank1 and Bank2's flag       |
-   |                                    |            |               | - For other devices: clear Bank1's flag                        |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_GetStatus                     |    Yes     |      Yes      | - Return the status of Bank1 (for all devices)                 |
-   |                                    |            |               |   equivalent to FLASH_GetBank1Status function                  |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_WaitForLastOperation          |    Yes     |      Yes      | - Wait for Bank1 last operation (for all devices)              |
-   |                                    |            |               |   equivalent to: FLASH_WaitForLastBank1Operation function      |
-   +----------------------------------------------------------------------------------------------------------------------------------+
-
-   ************************************************************************************************************************
-   * New functions used for all STM32F10x devices to manage Bank1:                                                        *
-   *   - These functions are mainly useful for STM32F10x_XL density devices, to have separate control for Bank1 and bank2 *
-   *   - For other devices, these functions are optional (covered by functions listed above)                              *
-   ************************************************************************************************************************
-   +----------------------------------------------------------------------------------------------------------------------------------+
-   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
-   |                                    |   devices  |  devices      |                                                                |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_UnlockBank1                  |    Yes     |      Yes      | - Unlock Bank1                                                 |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_LockBank1                     |    Yes     |      Yes      | - Lock Bank1                                                   |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_EraseAllBank1Pages           |    Yes     |      Yes      | - Erase all pages in Bank1                                     |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_GetBank1Status               |    Yes     |      Yes      | - Return the status of Bank1                                   |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_WaitForLastBank1Operation    |    Yes     |      Yes      | - Wait for Bank1 last operation                                |
-   +----------------------------------------------------------------------------------------------------------------------------------+
-
-   *****************************************************************************
-   * New Functions used only with STM32F10x_XL density devices to manage Bank2 *
-   *****************************************************************************
-   +----------------------------------------------------------------------------------------------------------------------------------+
-   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
-   |                                    |   devices  |  devices      |                                                                |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_UnlockBank2                  |    Yes     |      No       | - Unlock Bank2                                                 |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   |FLASH_LockBank2                     |    Yes     |      No       | - Lock Bank2                                                   |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_EraseAllBank2Pages           |    Yes     |      No       | - Erase all pages in Bank2                                     |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_GetBank2Status               |    Yes     |      No       | - Return the status of Bank2                                   |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_WaitForLastBank2Operation    |    Yes     |      No       | - Wait for Bank2 last operation                                |
-   |----------------------------------------------------------------------------------------------------------------------------------|
-   | FLASH_BootConfig                   |    Yes     |      No       | - Configure to boot from Bank1 or Bank2                        |
-   +----------------------------------------------------------------------------------------------------------------------------------+
-@endcode
-*/
-
-
-/**
-  * @brief  Sets the code latency value.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  FLASH_Latency: specifies the FLASH Latency value.
-  *   This parameter can be one of the following values:
-  *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
-  *     @arg FLASH_Latency_1: FLASH One Latency cycle
-  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
-  * @retval None
-  */
-void FLASH_SetLatency(uint32_t FLASH_Latency)
-{
-  uint32_t tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
-  
-  /* Read the ACR register */
-  tmpreg = FLASH->ACR;  
-  
-  /* Sets the Latency value */
-  tmpreg &= ACR_LATENCY_Mask;
-  tmpreg |= FLASH_Latency;
-  
-  /* Write the ACR register */
-  FLASH->ACR = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the Half cycle flash access.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.
-  *   This parameter can be one of the following values:
-  *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
-  *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
-  * @retval None
-  */
-void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
-  
-  /* Enable or disable the Half cycle access */
-  FLASH->ACR &= ACR_HLFCYA_Mask;
-  FLASH->ACR |= FLASH_HalfCycleAccess;
-}
-
-/**
-  * @brief  Enables or disables the Prefetch Buffer.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
-  *   This parameter can be one of the following values:
-  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
-  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
-  * @retval None
-  */
-void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
-{
-  /* Check the parameters */
-  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
-  
-  /* Enable or disable the Prefetch Buffer */
-  FLASH->ACR &= ACR_PRFTBE_Mask;
-  FLASH->ACR |= FLASH_PrefetchBuffer;
-}
-
-/**
-  * @brief  Unlocks the FLASH Program Erase Controller.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.
-  *         - For all other devices it unlocks Bank1 and it is equivalent 
-  *           to FLASH_UnlockBank1 function.. 
-  * @param  None
-  * @retval None
-  */
-void FLASH_Unlock(void)
-{
-  /* Authorize the FPEC of Bank1 Access */
-  FLASH->KEYR = FLASH_KEY1;
-  FLASH->KEYR = FLASH_KEY2;
-
-#ifdef STM32F10X_XL
-  /* Authorize the FPEC of Bank2 Access */
-  FLASH->KEYR2 = FLASH_KEY1;
-  FLASH->KEYR2 = FLASH_KEY2;
-#endif /* STM32F10X_XL */
-}
-/**
-  * @brief  Unlocks the FLASH Bank1 Program Erase Controller.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices this function unlocks Bank1.
-  *         - For all other devices it unlocks Bank1 and it is 
-  *           equivalent to FLASH_Unlock function.
-  * @param  None
-  * @retval None
-  */
-void FLASH_UnlockBank1(void)
-{
-  /* Authorize the FPEC of Bank1 Access */
-  FLASH->KEYR = FLASH_KEY1;
-  FLASH->KEYR = FLASH_KEY2;
-}
-
-#ifdef STM32F10X_XL
-/**
-  * @brief  Unlocks the FLASH Bank2 Program Erase Controller.
-  * @note   This function can be used only for STM32F10X_XL density devices.
-  * @param  None
-  * @retval None
-  */
-void FLASH_UnlockBank2(void)
-{
-  /* Authorize the FPEC of Bank2 Access */
-  FLASH->KEYR2 = FLASH_KEY1;
-  FLASH->KEYR2 = FLASH_KEY2;
-
-}
-#endif /* STM32F10X_XL */
-
-/**
-  * @brief  Locks the FLASH Program Erase Controller.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.
-  *         - For all other devices it Locks Bank1 and it is equivalent 
-  *           to FLASH_LockBank1 function.
-  * @param  None
-  * @retval None
-  */
-void FLASH_Lock(void)
-{
-  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
-  FLASH->CR |= CR_LOCK_Set;
-
-#ifdef STM32F10X_XL
-  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
-  FLASH->CR2 |= CR_LOCK_Set;
-#endif /* STM32F10X_XL */
-}
-
-/**
-  * @brief  Locks the FLASH Bank1 Program Erase Controller.
-  * @note   this function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices this function Locks Bank1.
-  *         - For all other devices it Locks Bank1 and it is equivalent 
-  *           to FLASH_Lock function.
-  * @param  None
-  * @retval None
-  */
-void FLASH_LockBank1(void)
-{
-  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
-  FLASH->CR |= CR_LOCK_Set;
-}
-
-#ifdef STM32F10X_XL
-/**
-  * @brief  Locks the FLASH Bank2 Program Erase Controller.
-  * @note   This function can be used only for STM32F10X_XL density devices.
-  * @param  None
-  * @retval None
-  */
-void FLASH_LockBank2(void)
-{
-  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
-  FLASH->CR2 |= CR_LOCK_Set;
-}
-#endif /* STM32F10X_XL */
-
-/**
-  * @brief  Erases a specified FLASH page.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  Page_Address: The page address to be erased.
-  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Page_Address));
-
-#ifdef STM32F10X_XL
-  if(Page_Address < FLASH_BANK1_END_ADDRESS)  
-  {
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
-    if(status == FLASH_COMPLETE)
-    { 
-      /* if the previous operation is completed, proceed to erase the page */
-      FLASH->CR|= CR_PER_Set;
-      FLASH->AR = Page_Address; 
-      FLASH->CR|= CR_STRT_Set;
-    
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
-
-      /* Disable the PER Bit */
-      FLASH->CR &= CR_PER_Reset;
-    }
-  }
-  else
-  {
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank2Operation(EraseTimeout);
-    if(status == FLASH_COMPLETE)
-    { 
-      /* if the previous operation is completed, proceed to erase the page */
-      FLASH->CR2|= CR_PER_Set;
-      FLASH->AR2 = Page_Address; 
-      FLASH->CR2|= CR_STRT_Set;
-    
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank2Operation(EraseTimeout);
-      
-      /* Disable the PER Bit */
-      FLASH->CR2 &= CR_PER_Reset;
-    }
-  }
-#else
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  { 
-    /* if the previous operation is completed, proceed to erase the page */
-    FLASH->CR|= CR_PER_Set;
-    FLASH->AR = Page_Address; 
-    FLASH->CR|= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-    
-    /* Disable the PER Bit */
-    FLASH->CR &= CR_PER_Reset;
-  }
-#endif /* STM32F10X_XL */
-
-  /* Return the Erase Status */
-  return status;
-}
-
-/**
-  * @brief  Erases all FLASH pages.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_EraseAllPages(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-
-#ifdef STM32F10X_XL
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastBank1Operation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH->CR |= CR_MER_Set;
-     FLASH->CR |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
-    
-    /* Disable the MER Bit */
-    FLASH->CR &= CR_MER_Reset;
-  }    
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH->CR2 |= CR_MER_Set;
-     FLASH->CR2 |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank2Operation(EraseTimeout);
-    
-    /* Disable the MER Bit */
-    FLASH->CR2 &= CR_MER_Reset;
-  }
-#else
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH->CR |= CR_MER_Set;
-     FLASH->CR |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-
-    /* Disable the MER Bit */
-    FLASH->CR &= CR_MER_Reset;
-  }
-#endif /* STM32F10X_XL */
-
-  /* Return the Erase Status */
-  return status;
-}
-
-/**
-  * @brief  Erases all Bank1 FLASH pages.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices this function erases all Bank1 pages.
-  *         - For all other devices it erases all Bank1 pages and it is equivalent 
-  *           to FLASH_EraseAllPages function.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_EraseAllBank1Pages(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastBank1Operation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH->CR |= CR_MER_Set;
-     FLASH->CR |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank1Operation(EraseTimeout);
-    
-    /* Disable the MER Bit */
-    FLASH->CR &= CR_MER_Reset;
-  }    
-  /* Return the Erase Status */
-  return status;
-}
-
-#ifdef STM32F10X_XL
-/**
-  * @brief  Erases all Bank2 FLASH pages.
-  * @note   This function can be used only for STM32F10x_XL density devices.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_EraseAllBank2Pages(void)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastBank2Operation(EraseTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to erase all pages */
-     FLASH->CR2 |= CR_MER_Set;
-     FLASH->CR2 |= CR_STRT_Set;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank2Operation(EraseTimeout);
-
-    /* Disable the MER Bit */
-    FLASH->CR2 &= CR_MER_Reset;
-  }    
-  /* Return the Erase Status */
-  return status;
-}
-#endif /* STM32F10X_XL */
-
-/**
-  * @brief  Erases the FLASH option bytes.
-  * @note   This functions erases all option bytes except the Read protection (RDP). 
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_EraseOptionBytes(void)
-{
-  uint16_t rdptmp = RDP_Key;
-
-  FLASH_Status status = FLASH_COMPLETE;
-
-  /* Get the actual read protection Option Byte value */ 
-  if(FLASH_GetReadOutProtectionStatus() != RESET)
-  {
-    rdptmp = 0x00;  
-  }
-
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorize the small information block programming */
-    FLASH->OPTKEYR = FLASH_KEY1;
-    FLASH->OPTKEYR = FLASH_KEY2;
-    
-    /* if the previous operation is completed, proceed to erase the option bytes */
-    FLASH->CR |= CR_OPTER_Set;
-    FLASH->CR |= CR_STRT_Set;
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-    
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the erase operation is completed, disable the OPTER Bit */
-      FLASH->CR &= CR_OPTER_Reset;
-       
-      /* Enable the Option Bytes Programming operation */
-      FLASH->CR |= CR_OPTPG_Set;
-      /* Restore the last read protection Option Byte value */
-      OB->RDP = (uint16_t)rdptmp; 
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-      if(status != FLASH_TIMEOUT)
-      {
-        /* if the program operation is completed, disable the OPTPG Bit */
-        FLASH->CR &= CR_OPTPG_Reset;
-      }
-    }
-    else
-    {
-      if (status != FLASH_TIMEOUT)
-      {
-        /* Disable the OPTPG Bit */
-        FLASH->CR &= CR_OPTPG_Reset;
-      }
-    }  
-  }
-  /* Return the erase status */
-  return status;
-}
-
-/**
-  * @brief  Programs a word at a specified address.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  Address: specifies the address to be programmed.
-  * @param  Data: specifies the data to be programmed.
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
-  */
-FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  __IO uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Address));
-
-#ifdef STM32F10X_XL
-  if(Address < FLASH_BANK1_END_ADDRESS - 2)
-  { 
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new first 
-        half word */
-      FLASH->CR |= CR_PG_Set;
-  
-      *(__IO uint16_t*)Address = (uint16_t)Data;
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-      if(status == FLASH_COMPLETE)
-      {
-        /* if the previous operation is completed, proceed to program the new second 
-        half word */
-        tmp = Address + 2;
-
-        *(__IO uint16_t*) tmp = Data >> 16;
-    
-        /* Wait for last operation to be completed */
-        status = FLASH_WaitForLastOperation(ProgramTimeout);
-        
-        /* Disable the PG Bit */
-        FLASH->CR &= CR_PG_Reset;
-      }
-      else
-      {
-        /* Disable the PG Bit */
-        FLASH->CR &= CR_PG_Reset;
-       }
-    }
-  }
-  else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
-  {
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
-
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new first 
-        half word */
-      FLASH->CR |= CR_PG_Set;
-  
-      *(__IO uint16_t*)Address = (uint16_t)Data;
-
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
-      
-	  /* Disable the PG Bit */
-      FLASH->CR &= CR_PG_Reset;
-    }
-    else
-    {
-      /* Disable the PG Bit */
-      FLASH->CR &= CR_PG_Reset;
-    }
-
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
-
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new second 
-      half word */
-      FLASH->CR2 |= CR_PG_Set;
-      tmp = Address + 2;
-
-      *(__IO uint16_t*) tmp = Data >> 16;
-    
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
-        
-      /* Disable the PG Bit */
-      FLASH->CR2 &= CR_PG_Reset;
-    }
-    else
-    {
-      /* Disable the PG Bit */
-      FLASH->CR2 &= CR_PG_Reset;
-    }
-  }
-  else
-  {
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
-
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new first 
-        half word */
-      FLASH->CR2 |= CR_PG_Set;
-  
-      *(__IO uint16_t*)Address = (uint16_t)Data;
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
- 
-      if(status == FLASH_COMPLETE)
-      {
-        /* if the previous operation is completed, proceed to program the new second 
-        half word */
-        tmp = Address + 2;
-
-        *(__IO uint16_t*) tmp = Data >> 16;
-    
-        /* Wait for last operation to be completed */
-        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
-        
-        /* Disable the PG Bit */
-        FLASH->CR2 &= CR_PG_Reset;
-      }
-      else
-      {
-        /* Disable the PG Bit */
-        FLASH->CR2 &= CR_PG_Reset;
-      }
-    }
-  }
-#else
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to program the new first 
-    half word */
-    FLASH->CR |= CR_PG_Set;
-  
-    *(__IO uint16_t*)Address = (uint16_t)Data;
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
- 
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new second 
-      half word */
-      tmp = Address + 2;
-
-      *(__IO uint16_t*) tmp = Data >> 16;
-    
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-        
-      /* Disable the PG Bit */
-      FLASH->CR &= CR_PG_Reset;
-    }
-    else
-    {
-      /* Disable the PG Bit */
-      FLASH->CR &= CR_PG_Reset;
-    }
-  }         
-#endif /* STM32F10X_XL */
-   
-  /* Return the Program Status */
-  return status;
-}
-
-/**
-  * @brief  Programs a half word at a specified address.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  Address: specifies the address to be programmed.
-  * @param  Data: specifies the data to be programmed.
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
-  */
-FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  /* Check the parameters */
-  assert_param(IS_FLASH_ADDRESS(Address));
-
-#ifdef STM32F10X_XL
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(Address < FLASH_BANK1_END_ADDRESS)
-  {
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new data */
-      FLASH->CR |= CR_PG_Set;
-  
-      *(__IO uint16_t*)Address = Data;
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
-
-      /* Disable the PG Bit */
-      FLASH->CR &= CR_PG_Reset;
-    }
-  }
-  else
-  {
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the previous operation is completed, proceed to program the new data */
-      FLASH->CR2 |= CR_PG_Set;
-  
-      *(__IO uint16_t*)Address = Data;
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
-
-      /* Disable the PG Bit */
-      FLASH->CR2 &= CR_PG_Reset;
-    }
-  }
-#else
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* if the previous operation is completed, proceed to program the new data */
-    FLASH->CR |= CR_PG_Set;
-  
-    *(__IO uint16_t*)Address = Data;
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-    
-    /* Disable the PG Bit */
-    FLASH->CR &= CR_PG_Reset;
-  } 
-#endif  /* STM32F10X_XL */
-  
-  /* Return the Program Status */
-  return status;
-}
-
-/**
-  * @brief  Programs a half word at a specified Option Byte Data address.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  Address: specifies the address to be programmed.
-  *   This parameter can be 0x1FFFF804 or 0x1FFFF806. 
-  * @param  Data: specifies the data to be programmed.
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
-  */
-FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  /* Check the parameters */
-  assert_param(IS_OB_DATA_ADDRESS(Address));
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorize the small information block programming */
-    FLASH->OPTKEYR = FLASH_KEY1;
-    FLASH->OPTKEYR = FLASH_KEY2;
-    /* Enables the Option Bytes Programming operation */
-    FLASH->CR |= CR_OPTPG_Set; 
-    *(__IO uint16_t*)Address = Data;
-    
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-    if(status != FLASH_TIMEOUT)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH->CR &= CR_OPTPG_Reset;
-    }
-  }
-  /* Return the Option Byte Data Program Status */
-  return status;
-}
-
-/**
-  * @brief  Write protects the desired pages
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  FLASH_Pages: specifies the address of the pages to be write protected.
-  *   This parameter can be:
-  *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31  
-  *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3
-  *       and FLASH_WRProt_Pages124to127
-  *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and
-  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255
-  *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and
-  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127    
-  *     @arg For @b STM32_XL-density_devices: value between FLASH_WRProt_Pages0to1 and
-  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to511
-  *     @arg FLASH_WRProt_AllPages
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
-{
-  uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
-  
-  FLASH_Status status = FLASH_COMPLETE;
-  
-  /* Check the parameters */
-  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
-  
-  FLASH_Pages = (uint32_t)(~FLASH_Pages);
-  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
-  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
-  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
-  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorizes the small information block programming */
-    FLASH->OPTKEYR = FLASH_KEY1;
-    FLASH->OPTKEYR = FLASH_KEY2;
-    FLASH->CR |= CR_OPTPG_Set;
-    if(WRP0_Data != 0xFF)
-    {
-      OB->WRP0 = WRP0_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
-    {
-      OB->WRP1 = WRP1_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
-    {
-      OB->WRP2 = WRP2_Data;
-      
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-    
-    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
-    {
-      OB->WRP3 = WRP3_Data;
-     
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(ProgramTimeout);
-    }
-          
-    if(status != FLASH_TIMEOUT)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH->CR &= CR_OPTPG_Reset;
-    }
-  } 
-  /* Return the write protection operation Status */
-  return status;       
-}
-
-/**
-  * @brief  Enables or disables the read out protection.
-  * @note   If the user has already programmed the other option bytes before calling 
-  *   this function, he must re-program them since this function erases all option bytes.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  Newstate: new state of the ReadOut Protection.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
-{
-  FLASH_Status status = FLASH_COMPLETE;
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  status = FLASH_WaitForLastOperation(EraseTimeout);
-  if(status == FLASH_COMPLETE)
-  {
-    /* Authorizes the small information block programming */
-    FLASH->OPTKEYR = FLASH_KEY1;
-    FLASH->OPTKEYR = FLASH_KEY2;
-    FLASH->CR |= CR_OPTER_Set;
-    FLASH->CR |= CR_STRT_Set;
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(EraseTimeout);
-    if(status == FLASH_COMPLETE)
-    {
-      /* if the erase operation is completed, disable the OPTER Bit */
-      FLASH->CR &= CR_OPTER_Reset;
-      /* Enable the Option Bytes Programming operation */
-      FLASH->CR |= CR_OPTPG_Set; 
-      if(NewState != DISABLE)
-      {
-        OB->RDP = 0x00;
-      }
-      else
-      {
-        OB->RDP = RDP_Key;  
-      }
-      /* Wait for last operation to be completed */
-      status = FLASH_WaitForLastOperation(EraseTimeout); 
-    
-      if(status != FLASH_TIMEOUT)
-      {
-        /* if the program operation is completed, disable the OPTPG Bit */
-        FLASH->CR &= CR_OPTPG_Reset;
-      }
-    }
-    else 
-    {
-      if(status != FLASH_TIMEOUT)
-      {
-        /* Disable the OPTER Bit */
-        FLASH->CR &= CR_OPTER_Reset;
-      }
-    }
-  }
-  /* Return the protection operation Status */
-  return status;       
-}
-
-/**
-  * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  OB_IWDG: Selects the IWDG mode
-  *   This parameter can be one of the following values:
-  *     @arg OB_IWDG_SW: Software IWDG selected
-  *     @arg OB_IWDG_HW: Hardware IWDG selected
-  * @param  OB_STOP: Reset event when entering STOP mode.
-  *   This parameter can be one of the following values:
-  *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
-  *     @arg OB_STOP_RST: Reset generated when entering in STOP
-  * @param  OB_STDBY: Reset event when entering Standby mode.
-  *   This parameter can be one of the following values:
-  *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
-  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
-{
-  FLASH_Status status = FLASH_COMPLETE; 
-
-  /* Check the parameters */
-  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
-  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
-  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
-
-  /* Authorize the small information block programming */
-  FLASH->OPTKEYR = FLASH_KEY1;
-  FLASH->OPTKEYR = FLASH_KEY2;
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {  
-    /* Enable the Option Bytes Programming operation */
-    FLASH->CR |= CR_OPTPG_Set; 
-           
-    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
-  
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-    if(status != FLASH_TIMEOUT)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH->CR &= CR_OPTPG_Reset;
-    }
-  }    
-  /* Return the Option Byte program Status */
-  return status;
-}
-
-#ifdef STM32F10X_XL
-/**
-  * @brief  Configures to boot from Bank1 or Bank2.  
-  * @note   This function can be used only for STM32F10x_XL density devices.
-  * @param  FLASH_BOOT: select the FLASH Bank to boot from.
-  *   This parameter can be one of the following values:
-  *     @arg FLASH_BOOT_Bank1: At startup, if boot pins are set in boot from user Flash
-  *        position and this parameter is selected the device will boot from Bank1(Default).
-  *     @arg FLASH_BOOT_Bank2: At startup, if boot pins are set in boot from user Flash
-  *        position and this parameter is selected the device will boot from Bank2 or Bank1,
-  *        depending on the activation of the bank. The active banks are checked in
-  *        the following order: Bank2, followed by Bank1.
-  *        The active bank is recognized by the value programmed at the base address
-  *        of the respective bank (corresponding to the initial stack pointer value
-  *        in the interrupt vector table).
-  *        For more information, please refer to AN2606 from www.st.com.    
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT)
-{ 
-  FLASH_Status status = FLASH_COMPLETE; 
-  assert_param(IS_FLASH_BOOT(FLASH_BOOT));
-  /* Authorize the small information block programming */
-  FLASH->OPTKEYR = FLASH_KEY1;
-  FLASH->OPTKEYR = FLASH_KEY2;
-  
-  /* Wait for last operation to be completed */
-  status = FLASH_WaitForLastOperation(ProgramTimeout);
-  
-  if(status == FLASH_COMPLETE)
-  {  
-    /* Enable the Option Bytes Programming operation */
-    FLASH->CR |= CR_OPTPG_Set; 
-
-    if(FLASH_BOOT == FLASH_BOOT_Bank1)
-    {
-      OB->USER |= OB_USER_BFB2;
-    }
-    else
-    {
-      OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));
-    }
-    /* Wait for last operation to be completed */
-    status = FLASH_WaitForLastOperation(ProgramTimeout);
-    if(status != FLASH_TIMEOUT)
-    {
-      /* if the program operation is completed, disable the OPTPG Bit */
-      FLASH->CR &= CR_OPTPG_Reset;
-    }
-  }    
-  /* Return the Option Byte program Status */
-  return status;
-}
-#endif /* STM32F10X_XL */
-
-/**
-  * @brief  Returns the FLASH User Option Bytes values.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  None
-  * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
-  *         and RST_STDBY(Bit2).
-  */
-uint32_t FLASH_GetUserOptionByte(void)
-{
-  /* Return the User Option Byte */
-  return (uint32_t)(FLASH->OBR >> 2);
-}
-
-/**
-  * @brief  Returns the FLASH Write Protection Option Bytes Register value.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  None
-  * @retval The FLASH Write Protection  Option Bytes Register value
-  */
-uint32_t FLASH_GetWriteProtectionOptionByte(void)
-{
-  /* Return the Flash write protection Register value */
-  return (uint32_t)(FLASH->WRPR);
-}
-
-/**
-  * @brief  Checks whether the FLASH Read Out Protection Status is set or not.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  None
-  * @retval FLASH ReadOut Protection Status(SET or RESET)
-  */
-FlagStatus FLASH_GetReadOutProtectionStatus(void)
-{
-  FlagStatus readoutstatus = RESET;
-  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
-  {
-    readoutstatus = SET;
-  }
-  else
-  {
-    readoutstatus = RESET;
-  }
-  return readoutstatus;
-}
-
-/**
-  * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.
-  * @note   This function can be used for all STM32F10x devices.
-  * @param  None
-  * @retval FLASH Prefetch Buffer Status (SET or RESET).
-  */
-FlagStatus FLASH_GetPrefetchBufferStatus(void)
-{
-  FlagStatus bitstatus = RESET;
-  
-  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
-  return bitstatus; 
-}
-
-/**
-  * @brief  Enables or disables the specified FLASH interrupts.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices, enables or disables the specified FLASH interrupts
-              for Bank1 and Bank2.
-  *         - For other devices it enables or disables the specified FLASH interrupts for Bank1.
-  * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
-  *   This parameter can be any combination of the following values:
-  *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
-  *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
-  * @param  NewState: new state of the specified Flash interrupts.
-  *   This parameter can be: ENABLE or DISABLE.      
-  * @retval None 
-  */
-void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
-{
-#ifdef STM32F10X_XL
-  /* Check the parameters */
-  assert_param(IS_FLASH_IT(FLASH_IT)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if((FLASH_IT & 0x80000000) != 0x0)
-  {
-    if(NewState != DISABLE)
-    {
-      /* Enable the interrupt sources */
-      FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
-    }
-    else
-    {
-      /* Disable the interrupt sources */
-      FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
-    }
-  }
-  else
-  {
-    if(NewState != DISABLE)
-    {
-      /* Enable the interrupt sources */
-      FLASH->CR |= FLASH_IT;
-    }
-    else
-    {
-      /* Disable the interrupt sources */
-      FLASH->CR &= ~(uint32_t)FLASH_IT;
-    }
-  }
-#else
-  /* Check the parameters */
-  assert_param(IS_FLASH_IT(FLASH_IT)); 
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if(NewState != DISABLE)
-  {
-    /* Enable the interrupt sources */
-    FLASH->CR |= FLASH_IT;
-  }
-  else
-  {
-    /* Disable the interrupt sources */
-    FLASH->CR &= ~(uint32_t)FLASH_IT;
-  }
-#endif /* STM32F10X_XL */
-}
-
-/**
-  * @brief  Checks whether the specified FLASH flag is set or not.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices, this function checks whether the specified 
-  *           Bank1 or Bank2 flag is set or not.
-  *         - For other devices, it checks whether the specified Bank1 flag is 
-  *           set or not.
-  * @param  FLASH_FLAG: specifies the FLASH flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg FLASH_FLAG_BSY: FLASH Busy flag           
-  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
-  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
-  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
-  *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
-  * @retval The new state of FLASH_FLAG (SET or RESET).
-  */
-FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-
-#ifdef STM32F10X_XL
-  /* Check the parameters */
-  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
-  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
-  {
-    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-  else
-  {
-    if((FLASH_FLAG & 0x80000000) != 0x0)
-    {
-      if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
-      {
-        bitstatus = SET;
-      }
-      else
-      {
-        bitstatus = RESET;
-      }
-    }
-    else
-    {
-      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
-      {
-        bitstatus = SET;
-      }
-      else
-      {
-        bitstatus = RESET;
-      }
-    }
-  }
-#else
-  /* Check the parameters */
-  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
-  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
-  {
-    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-  else
-  {
-   if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
-    {
-      bitstatus = SET;
-    }
-    else
-    {
-      bitstatus = RESET;
-    }
-  }
-#endif /* STM32F10X_XL */
-
-  /* Return the new state of FLASH_FLAG (SET or RESET) */
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the FLASH's pending flags.
-  * @note   This function can be used for all STM32F10x devices.
-  *         - For STM32F10X_XL devices, this function clears Bank1 or Bank2s pending flags
-  *         - For other devices, it clears Bank1s pending flags.
-  * @param  FLASH_FLAG: specifies the FLASH flags to clear.
-  *   This parameter can be any combination of the following values:         
-  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
-  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
-  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
-  * @retval None
-  */
-void FLASH_ClearFlag(uint32_t FLASH_FLAG)
-{
-#ifdef STM32F10X_XL
-  /* Check the parameters */
-  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
-
-  if((FLASH_FLAG & 0x80000000) != 0x0)
-  {
-    /* Clear the flags */
-    FLASH->SR2 = FLASH_FLAG;
-  }
-  else
-  {
-    /* Clear the flags */
-    FLASH->SR = FLASH_FLAG;
-  }  
-
-#else
-  /* Check the parameters */
-  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
-  
-  /* Clear the flags */
-  FLASH->SR = FLASH_FLAG;
-#endif /* STM32F10X_XL */
-}
-
-/**
-  * @brief  Returns the FLASH Status.
-  * @note   This function can be used for all STM32F10x devices, it is equivalent
-  *         to FLASH_GetBank1Status function.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP or FLASH_COMPLETE
-  */
-FLASH_Status FLASH_GetStatus(void)
-{
-  FLASH_Status flashstatus = FLASH_COMPLETE;
-  
-  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
-  {
-    flashstatus = FLASH_BUSY;
-  }
-  else 
-  {  
-    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
-    { 
-      flashstatus = FLASH_ERROR_PG;
-    }
-    else 
-    {
-      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
-      {
-        flashstatus = FLASH_ERROR_WRP;
-      }
-      else
-      {
-        flashstatus = FLASH_COMPLETE;
-      }
-    }
-  }
-  /* Return the Flash Status */
-  return flashstatus;
-}
-
-/**
-  * @brief  Returns the FLASH Bank1 Status.
-  * @note   This function can be used for all STM32F10x devices, it is equivalent
-  *         to FLASH_GetStatus function.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP or FLASH_COMPLETE
-  */
-FLASH_Status FLASH_GetBank1Status(void)
-{
-  FLASH_Status flashstatus = FLASH_COMPLETE;
-  
-  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
-  {
-    flashstatus = FLASH_BUSY;
-  }
-  else 
-  {  
-    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
-    { 
-      flashstatus = FLASH_ERROR_PG;
-    }
-    else 
-    {
-      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
-      {
-        flashstatus = FLASH_ERROR_WRP;
-      }
-      else
-      {
-        flashstatus = FLASH_COMPLETE;
-      }
-    }
-  }
-  /* Return the Flash Status */
-  return flashstatus;
-}
-
-#ifdef STM32F10X_XL
-/**
-  * @brief  Returns the FLASH Bank2 Status.
-  * @note   This function can be used for STM32F10x_XL density devices.
-  * @param  None
-  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
-  *        FLASH_ERROR_WRP or FLASH_COMPLETE
-  */
-FLASH_Status FLASH_GetBank2Status(void)
-{
-  FLASH_Status flashstatus = FLASH_COMPLETE;
-  
-  if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) 
-  {
-    flashstatus = FLASH_BUSY;
-  }
-  else 
-  {  
-    if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)
-    { 
-      flashstatus = FLASH_ERROR_PG;
-    }
-    else 
-    {
-      if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )
-      {
-        flashstatus = FLASH_ERROR_WRP;
-      }
-      else
-      {
-        flashstatus = FLASH_COMPLETE;
-      }
-    }
-  }
-  /* Return the Flash Status */
-  return flashstatus;
-}
-#endif /* STM32F10X_XL */
-/**
-  * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
-  * @note   This function can be used for all STM32F10x devices, 
-  *         it is equivalent to FLASH_WaitForLastBank1Operation.
-  *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation
-  *           to complete or a TIMEOUT to occur.
-  *         - For all other devices it waits for a Flash operation to complete 
-  *           or a TIMEOUT to occur.
-  * @param  Timeout: FLASH programming Timeout
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
-{ 
-  FLASH_Status status = FLASH_COMPLETE;
-   
-  /* Check for the Flash Status */
-  status = FLASH_GetBank1Status();
-  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
-  while((status == FLASH_BUSY) && (Timeout != 0x00))
-  {
-    status = FLASH_GetBank1Status();
-    Timeout--;
-  }
-  if(Timeout == 0x00 )
-  {
-    status = FLASH_TIMEOUT;
-  }
-  /* Return the operation status */
-  return status;
-}
-
-/**
-  * @brief  Waits for a Flash operation on Bank1 to complete or a TIMEOUT to occur.
-  * @note   This function can be used for all STM32F10x devices, 
-  *         it is equivalent to FLASH_WaitForLastOperation.
-  * @param  Timeout: FLASH programming Timeout
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
-{ 
-  FLASH_Status status = FLASH_COMPLETE;
-   
-  /* Check for the Flash Status */
-  status = FLASH_GetBank1Status();
-  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
-  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
-  {
-    status = FLASH_GetBank1Status();
-    Timeout--;
-  }
-  if(Timeout == 0x00 )
-  {
-    status = FLASH_TIMEOUT;
-  }
-  /* Return the operation status */
-  return status;
-}
-
-#ifdef STM32F10X_XL
-/**
-  * @brief  Waits for a Flash operation on Bank2 to complete or a TIMEOUT to occur.
-  * @note   This function can be used only for STM32F10x_XL density devices.
-  * @param  Timeout: FLASH programming Timeout
-  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
-  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
-  */
-FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)
-{ 
-  FLASH_Status status = FLASH_COMPLETE;
-   
-  /* Check for the Flash Status */
-  status = FLASH_GetBank2Status();
-  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
-  while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))
-  {
-    status = FLASH_GetBank2Status();
-    Timeout--;
-  }
-  if(Timeout == 0x00 )
-  {
-    status = FLASH_TIMEOUT;
-  }
-  /* Return the operation status */
-  return status;
-}
-#endif /* STM32F10X_XL */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_flash.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_flash.h
deleted file mode 100644
index 63720dea3..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_flash.h
+++ /dev/null
@@ -1,426 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_flash.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the FLASH 
-  *          firmware library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_FLASH_H
-#define __STM32F10x_FLASH_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup FLASH
-  * @{
-  */
-
-/** @defgroup FLASH_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  FLASH Status  
-  */
-
-typedef enum
-{ 
-  FLASH_BUSY = 1,
-  FLASH_ERROR_PG,
-  FLASH_ERROR_WRP,
-  FLASH_COMPLETE,
-  FLASH_TIMEOUT
-}FLASH_Status;
-
-/**
-  * @}
-  */
-
-/** @defgroup FLASH_Exported_Constants
-  * @{
-  */
-
-/** @defgroup Flash_Latency 
-  * @{
-  */
-
-#define FLASH_Latency_0                ((uint32_t)0x00000000)  /*!< FLASH Zero Latency cycle */
-#define FLASH_Latency_1                ((uint32_t)0x00000001)  /*!< FLASH One Latency cycle */
-#define FLASH_Latency_2                ((uint32_t)0x00000002)  /*!< FLASH Two Latency cycles */
-#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
-                                   ((LATENCY) == FLASH_Latency_1) || \
-                                   ((LATENCY) == FLASH_Latency_2))
-/**
-  * @}
-  */
-
-/** @defgroup Half_Cycle_Enable_Disable 
-  * @{
-  */
-
-#define FLASH_HalfCycleAccess_Enable   ((uint32_t)0x00000008)  /*!< FLASH Half Cycle Enable */
-#define FLASH_HalfCycleAccess_Disable  ((uint32_t)0x00000000)  /*!< FLASH Half Cycle Disable */
-#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \
-                                               ((STATE) == FLASH_HalfCycleAccess_Disable)) 
-/**
-  * @}
-  */
-
-/** @defgroup Prefetch_Buffer_Enable_Disable 
-  * @{
-  */
-
-#define FLASH_PrefetchBuffer_Enable    ((uint32_t)0x00000010)  /*!< FLASH Prefetch Buffer Enable */
-#define FLASH_PrefetchBuffer_Disable   ((uint32_t)0x00000000)  /*!< FLASH Prefetch Buffer Disable */
-#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \
-                                              ((STATE) == FLASH_PrefetchBuffer_Disable)) 
-/**
-  * @}
-  */
-
-/** @defgroup Option_Bytes_Write_Protection 
-  * @{
-  */
-
-/* Values to be used with STM32 Low and Medium density devices */
-#define FLASH_WRProt_Pages0to3         ((uint32_t)0x00000001) /*!< STM32 Low and Medium density devices: Write protection of page 0 to 3 */
-#define FLASH_WRProt_Pages4to7         ((uint32_t)0x00000002) /*!< STM32 Low and Medium density devices: Write protection of page 4 to 7 */
-#define FLASH_WRProt_Pages8to11        ((uint32_t)0x00000004) /*!< STM32 Low and Medium density devices: Write protection of page 8 to 11 */
-#define FLASH_WRProt_Pages12to15       ((uint32_t)0x00000008) /*!< STM32 Low and Medium density devices: Write protection of page 12 to 15 */
-#define FLASH_WRProt_Pages16to19       ((uint32_t)0x00000010) /*!< STM32 Low and Medium density devices: Write protection of page 16 to 19 */
-#define FLASH_WRProt_Pages20to23       ((uint32_t)0x00000020) /*!< STM32 Low and Medium density devices: Write protection of page 20 to 23 */
-#define FLASH_WRProt_Pages24to27       ((uint32_t)0x00000040) /*!< STM32 Low and Medium density devices: Write protection of page 24 to 27 */
-#define FLASH_WRProt_Pages28to31       ((uint32_t)0x00000080) /*!< STM32 Low and Medium density devices: Write protection of page 28 to 31 */
-
-/* Values to be used with STM32 Medium-density devices */
-#define FLASH_WRProt_Pages32to35       ((uint32_t)0x00000100) /*!< STM32 Medium-density devices: Write protection of page 32 to 35 */
-#define FLASH_WRProt_Pages36to39       ((uint32_t)0x00000200) /*!< STM32 Medium-density devices: Write protection of page 36 to 39 */
-#define FLASH_WRProt_Pages40to43       ((uint32_t)0x00000400) /*!< STM32 Medium-density devices: Write protection of page 40 to 43 */
-#define FLASH_WRProt_Pages44to47       ((uint32_t)0x00000800) /*!< STM32 Medium-density devices: Write protection of page 44 to 47 */
-#define FLASH_WRProt_Pages48to51       ((uint32_t)0x00001000) /*!< STM32 Medium-density devices: Write protection of page 48 to 51 */
-#define FLASH_WRProt_Pages52to55       ((uint32_t)0x00002000) /*!< STM32 Medium-density devices: Write protection of page 52 to 55 */
-#define FLASH_WRProt_Pages56to59       ((uint32_t)0x00004000) /*!< STM32 Medium-density devices: Write protection of page 56 to 59 */
-#define FLASH_WRProt_Pages60to63       ((uint32_t)0x00008000) /*!< STM32 Medium-density devices: Write protection of page 60 to 63 */
-#define FLASH_WRProt_Pages64to67       ((uint32_t)0x00010000) /*!< STM32 Medium-density devices: Write protection of page 64 to 67 */
-#define FLASH_WRProt_Pages68to71       ((uint32_t)0x00020000) /*!< STM32 Medium-density devices: Write protection of page 68 to 71 */
-#define FLASH_WRProt_Pages72to75       ((uint32_t)0x00040000) /*!< STM32 Medium-density devices: Write protection of page 72 to 75 */
-#define FLASH_WRProt_Pages76to79       ((uint32_t)0x00080000) /*!< STM32 Medium-density devices: Write protection of page 76 to 79 */
-#define FLASH_WRProt_Pages80to83       ((uint32_t)0x00100000) /*!< STM32 Medium-density devices: Write protection of page 80 to 83 */
-#define FLASH_WRProt_Pages84to87       ((uint32_t)0x00200000) /*!< STM32 Medium-density devices: Write protection of page 84 to 87 */
-#define FLASH_WRProt_Pages88to91       ((uint32_t)0x00400000) /*!< STM32 Medium-density devices: Write protection of page 88 to 91 */
-#define FLASH_WRProt_Pages92to95       ((uint32_t)0x00800000) /*!< STM32 Medium-density devices: Write protection of page 92 to 95 */
-#define FLASH_WRProt_Pages96to99       ((uint32_t)0x01000000) /*!< STM32 Medium-density devices: Write protection of page 96 to 99 */
-#define FLASH_WRProt_Pages100to103     ((uint32_t)0x02000000) /*!< STM32 Medium-density devices: Write protection of page 100 to 103 */
-#define FLASH_WRProt_Pages104to107     ((uint32_t)0x04000000) /*!< STM32 Medium-density devices: Write protection of page 104 to 107 */
-#define FLASH_WRProt_Pages108to111     ((uint32_t)0x08000000) /*!< STM32 Medium-density devices: Write protection of page 108 to 111 */
-#define FLASH_WRProt_Pages112to115     ((uint32_t)0x10000000) /*!< STM32 Medium-density devices: Write protection of page 112 to 115 */
-#define FLASH_WRProt_Pages116to119     ((uint32_t)0x20000000) /*!< STM32 Medium-density devices: Write protection of page 115 to 119 */
-#define FLASH_WRProt_Pages120to123     ((uint32_t)0x40000000) /*!< STM32 Medium-density devices: Write protection of page 120 to 123 */
-#define FLASH_WRProt_Pages124to127     ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 124 to 127 */
-
-/* Values to be used with STM32 High-density and STM32F10X Connectivity line devices */
-#define FLASH_WRProt_Pages0to1         ((uint32_t)0x00000001) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 0 to 1 */
-#define FLASH_WRProt_Pages2to3         ((uint32_t)0x00000002) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 2 to 3 */
-#define FLASH_WRProt_Pages4to5         ((uint32_t)0x00000004) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 4 to 5 */
-#define FLASH_WRProt_Pages6to7         ((uint32_t)0x00000008) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 6 to 7 */
-#define FLASH_WRProt_Pages8to9         ((uint32_t)0x00000010) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 8 to 9 */
-#define FLASH_WRProt_Pages10to11       ((uint32_t)0x00000020) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 10 to 11 */
-#define FLASH_WRProt_Pages12to13       ((uint32_t)0x00000040) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 12 to 13 */
-#define FLASH_WRProt_Pages14to15       ((uint32_t)0x00000080) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 14 to 15 */
-#define FLASH_WRProt_Pages16to17       ((uint32_t)0x00000100) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 16 to 17 */
-#define FLASH_WRProt_Pages18to19       ((uint32_t)0x00000200) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 18 to 19 */
-#define FLASH_WRProt_Pages20to21       ((uint32_t)0x00000400) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 20 to 21 */
-#define FLASH_WRProt_Pages22to23       ((uint32_t)0x00000800) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 22 to 23 */
-#define FLASH_WRProt_Pages24to25       ((uint32_t)0x00001000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 24 to 25 */
-#define FLASH_WRProt_Pages26to27       ((uint32_t)0x00002000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 26 to 27 */
-#define FLASH_WRProt_Pages28to29       ((uint32_t)0x00004000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 28 to 29 */
-#define FLASH_WRProt_Pages30to31       ((uint32_t)0x00008000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 30 to 31 */
-#define FLASH_WRProt_Pages32to33       ((uint32_t)0x00010000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 32 to 33 */
-#define FLASH_WRProt_Pages34to35       ((uint32_t)0x00020000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 34 to 35 */
-#define FLASH_WRProt_Pages36to37       ((uint32_t)0x00040000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 36 to 37 */
-#define FLASH_WRProt_Pages38to39       ((uint32_t)0x00080000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 38 to 39 */
-#define FLASH_WRProt_Pages40to41       ((uint32_t)0x00100000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 40 to 41 */
-#define FLASH_WRProt_Pages42to43       ((uint32_t)0x00200000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 42 to 43 */
-#define FLASH_WRProt_Pages44to45       ((uint32_t)0x00400000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 44 to 45 */
-#define FLASH_WRProt_Pages46to47       ((uint32_t)0x00800000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 46 to 47 */
-#define FLASH_WRProt_Pages48to49       ((uint32_t)0x01000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 48 to 49 */
-#define FLASH_WRProt_Pages50to51       ((uint32_t)0x02000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 50 to 51 */
-#define FLASH_WRProt_Pages52to53       ((uint32_t)0x04000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 52 to 53 */
-#define FLASH_WRProt_Pages54to55       ((uint32_t)0x08000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 54 to 55 */
-#define FLASH_WRProt_Pages56to57       ((uint32_t)0x10000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 56 to 57 */
-#define FLASH_WRProt_Pages58to59       ((uint32_t)0x20000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 58 to 59 */
-#define FLASH_WRProt_Pages60to61       ((uint32_t)0x40000000) /*!< STM32 High-density, XL-density and Connectivity line devices:
-                                                                   Write protection of page 60 to 61 */
-#define FLASH_WRProt_Pages62to127      ((uint32_t)0x80000000) /*!< STM32 Connectivity line devices: Write protection of page 62 to 127 */
-#define FLASH_WRProt_Pages62to255      ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 62 to 255 */
-#define FLASH_WRProt_Pages62to511      ((uint32_t)0x80000000) /*!< STM32 XL-density devices: Write protection of page 62 to 511 */
-
-#define FLASH_WRProt_AllPages          ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Pages */
-
-#define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))
-
-#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x080FFFFF))
-
-#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))
-
-/**
-  * @}
-  */
-
-/** @defgroup Option_Bytes_IWatchdog 
-  * @{
-  */
-
-#define OB_IWDG_SW                     ((uint16_t)0x0001)  /*!< Software IWDG selected */
-#define OB_IWDG_HW                     ((uint16_t)0x0000)  /*!< Hardware IWDG selected */
-#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
-
-/**
-  * @}
-  */
-
-/** @defgroup Option_Bytes_nRST_STOP 
-  * @{
-  */
-
-#define OB_STOP_NoRST                  ((uint16_t)0x0002) /*!< No reset generated when entering in STOP */
-#define OB_STOP_RST                    ((uint16_t)0x0000) /*!< Reset generated when entering in STOP */
-#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
-
-/**
-  * @}
-  */
-
-/** @defgroup Option_Bytes_nRST_STDBY 
-  * @{
-  */
-
-#define OB_STDBY_NoRST                 ((uint16_t)0x0004) /*!< No reset generated when entering in STANDBY */
-#define OB_STDBY_RST                   ((uint16_t)0x0000) /*!< Reset generated when entering in STANDBY */
-#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
-
-#ifdef STM32F10X_XL
-/**
-  * @}
-  */
-/** @defgroup FLASH_Boot
-  * @{
-  */
-#define FLASH_BOOT_Bank1  ((uint16_t)0x0000) /*!< At startup, if boot pins are set in boot from user Flash position
-                                                  and this parameter is selected the device will boot from Bank1(Default) */
-#define FLASH_BOOT_Bank2  ((uint16_t)0x0001) /*!< At startup, if boot pins are set in boot from user Flash position
-                                                  and this parameter is selected the device will boot from Bank 2 or Bank 1,
-                                                  depending on the activation of the bank */
-#define IS_FLASH_BOOT(BOOT) (((BOOT) == FLASH_BOOT_Bank1) || ((BOOT) == FLASH_BOOT_Bank2))
-#endif
-/**
-  * @}
-  */
-/** @defgroup FLASH_Interrupts 
-  * @{
-  */
-#ifdef STM32F10X_XL
-#define FLASH_IT_BANK2_ERROR                 ((uint32_t)0x80000400)  /*!< FPEC BANK2 error interrupt source */
-#define FLASH_IT_BANK2_EOP                   ((uint32_t)0x80001000)  /*!< End of FLASH BANK2 Operation Interrupt source */
-
-#define FLASH_IT_BANK1_ERROR                 FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */
-#define FLASH_IT_BANK1_EOP                   FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */
-
-#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC BANK1 error interrupt source */
-#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH BANK1 Operation Interrupt source */
-#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0x7FFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
-#else
-#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC error interrupt source */
-#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH Operation Interrupt source */
-#define FLASH_IT_BANK1_ERROR           FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */
-#define FLASH_IT_BANK1_EOP             FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */
-
-#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
-#endif
-
-/**
-  * @}
-  */
-
-/** @defgroup FLASH_Flags 
-  * @{
-  */
-#ifdef STM32F10X_XL
-#define FLASH_FLAG_BANK2_BSY                 ((uint32_t)0x80000001)  /*!< FLASH BANK2 Busy flag */
-#define FLASH_FLAG_BANK2_EOP                 ((uint32_t)0x80000020)  /*!< FLASH BANK2 End of Operation flag */
-#define FLASH_FLAG_BANK2_PGERR               ((uint32_t)0x80000004)  /*!< FLASH BANK2 Program error flag */
-#define FLASH_FLAG_BANK2_WRPRTERR            ((uint32_t)0x80000010)  /*!< FLASH BANK2 Write protected error flag */
-
-#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/
-#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */
-#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */
-#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */
-
-#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */
-#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */
-#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */
-#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */
-#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */
- 
-#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0x7FFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
-#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
-                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
-                                  ((FLAG) == FLASH_FLAG_OPTERR)|| \
-                                  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \
-                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \
-                                  ((FLAG) == FLASH_FLAG_BANK2_BSY) || ((FLAG) == FLASH_FLAG_BANK2_EOP) || \
-                                  ((FLAG) == FLASH_FLAG_BANK2_PGERR) || ((FLAG) == FLASH_FLAG_BANK2_WRPRTERR))
-#else
-#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */
-#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */
-#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */
-#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */
-#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */
-
-#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/
-#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */
-#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */
-#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */
- 
-#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
-#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
-                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
-								  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \
-                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \
-                                  ((FLAG) == FLASH_FLAG_OPTERR))
-#endif
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FLASH_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FLASH_Exported_Functions
-  * @{
-  */
-
-/*------------ Functions used for all STM32F10x devices -----*/
-void FLASH_SetLatency(uint32_t FLASH_Latency);
-void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess);
-void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer);
-void FLASH_Unlock(void);
-void FLASH_Lock(void);
-FLASH_Status FLASH_ErasePage(uint32_t Page_Address);
-FLASH_Status FLASH_EraseAllPages(void);
-FLASH_Status FLASH_EraseOptionBytes(void);
-FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
-FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
-FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data);
-FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages);
-FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);
-FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY);
-uint32_t FLASH_GetUserOptionByte(void);
-uint32_t FLASH_GetWriteProtectionOptionByte(void);
-FlagStatus FLASH_GetReadOutProtectionStatus(void);
-FlagStatus FLASH_GetPrefetchBufferStatus(void);
-void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
-FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
-void FLASH_ClearFlag(uint32_t FLASH_FLAG);
-FLASH_Status FLASH_GetStatus(void);
-FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
-
-/*------------ New function used for all STM32F10x devices -----*/
-void FLASH_UnlockBank1(void);
-void FLASH_LockBank1(void);
-FLASH_Status FLASH_EraseAllBank1Pages(void);
-FLASH_Status FLASH_GetBank1Status(void);
-FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout);
-
-#ifdef STM32F10X_XL
-/*---- New Functions used only with STM32F10x_XL density devices -----*/
-void FLASH_UnlockBank2(void);
-void FLASH_LockBank2(void);
-FLASH_Status FLASH_EraseAllBank2Pages(void);
-FLASH_Status FLASH_GetBank2Status(void);
-FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout);
-FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_FLASH_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_fsmc.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_fsmc.c
deleted file mode 100644
index 51669ee37..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_fsmc.c
+++ /dev/null
@@ -1,866 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_fsmc.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the FSMC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_fsmc.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup FSMC 
-  * @brief FSMC driver modules
-  * @{
-  */ 
-
-/** @defgroup FSMC_Private_TypesDefinitions
-  * @{
-  */ 
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Private_Defines
-  * @{
-  */
-
-/* --------------------- FSMC registers bit mask ---------------------------- */
-
-/* FSMC BCRx Mask */
-#define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
-#define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
-#define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
-
-/* FSMC PCRx Mask */
-#define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
-#define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
-#define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
-#define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
-#define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
-  *         reset values.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
-  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
-  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
-  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
-  * @retval None
-  */
-void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
-{
-  /* Check the parameter */
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
-  
-  /* FSMC_Bank1_NORSRAM1 */
-  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
-  {
-    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
-  }
-  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
-  else
-  {   
-    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
-  }
-  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
-  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
-}
-
-/**
-  * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
-  * @retval None
-  */
-void FSMC_NANDDeInit(uint32_t FSMC_Bank)
-{
-  /* Check the parameter */
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* Set the FSMC_Bank2 registers to their reset values */
-    FSMC_Bank2->PCR2 = 0x00000018;
-    FSMC_Bank2->SR2 = 0x00000040;
-    FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
-    FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
-  }
-  /* FSMC_Bank3_NAND */  
-  else
-  {
-    /* Set the FSMC_Bank3 registers to their reset values */
-    FSMC_Bank3->PCR3 = 0x00000018;
-    FSMC_Bank3->SR3 = 0x00000040;
-    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
-    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
-  }  
-}
-
-/**
-  * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
-  * @param  None                       
-  * @retval None
-  */
-void FSMC_PCCARDDeInit(void)
-{
-  /* Set the FSMC_Bank4 registers to their reset values */
-  FSMC_Bank4->PCR4 = 0x00000018; 
-  FSMC_Bank4->SR4 = 0x00000000;	
-  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
-  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
-  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
-}
-
-/**
-  * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
-  *         parameters in the FSMC_NORSRAMInitStruct.
-  * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
-  *         structure that contains the configuration information for 
-  *        the FSMC NOR/SRAM specified Banks.                       
-  * @retval None
-  */
-void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
-  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
-  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
-  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
-  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
-  assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
-  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
-  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
-  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
-  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
-  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
-  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
-  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
-  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
-  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
-  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
-  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
-  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
-  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
-  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
-  
-  /* Bank1 NOR/SRAM control register configuration */ 
-  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
-            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
-            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
-            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
-            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
-            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
-            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
-            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
-            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
-            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
-            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
-            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
-            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
-
-  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
-  {
-    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
-  }
-  
-  /* Bank1 NOR/SRAM timing register configuration */
-  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
-            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
-            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
-            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
-            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
-            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
-            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
-             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
-            
-    
-  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
-  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
-  {
-    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
-    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
-    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
-    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
-    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
-    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
-    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
-              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
-              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
-              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
-              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
-              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
-               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
-  }
-  else
-  {
-    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
-  }
-}
-
-/**
-  * @brief  Initializes the FSMC NAND Banks according to the specified 
-  *         parameters in the FSMC_NANDInitStruct.
-  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
-  *         structure that contains the configuration information for the FSMC 
-  *         NAND specified Banks.                       
-  * @retval None
-  */
-void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
-{
-  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
-    
-  /* Check the parameters */
-  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
-  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
-  assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
-  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
-  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
-  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
-  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
-  
-  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
-  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
-            PCR_MemoryType_NAND |
-            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
-            FSMC_NANDInitStruct->FSMC_ECC |
-            FSMC_NANDInitStruct->FSMC_ECCPageSize |
-            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
-            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
-            
-  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
-  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
-            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
-            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
-            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
-            
-  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
-  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
-            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
-            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
-            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
-  
-  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* FSMC_Bank2_NAND registers configuration */
-    FSMC_Bank2->PCR2 = tmppcr;
-    FSMC_Bank2->PMEM2 = tmppmem;
-    FSMC_Bank2->PATT2 = tmppatt;
-  }
-  else
-  {
-    /* FSMC_Bank3_NAND registers configuration */
-    FSMC_Bank3->PCR3 = tmppcr;
-    FSMC_Bank3->PMEM3 = tmppmem;
-    FSMC_Bank3->PATT3 = tmppatt;
-  }
-}
-
-/**
-  * @brief  Initializes the FSMC PCCARD Bank according to the specified 
-  *         parameters in the FSMC_PCCARDInitStruct.
-  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
-  *         structure that contains the configuration information for the FSMC 
-  *         PCCARD Bank.                       
-  * @retval None
-  */
-void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
-  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
-  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
- 
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
-  
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
-  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
-  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
-  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
-  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
-  
-  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
-  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
-                     FSMC_MemoryDataWidth_16b |  
-                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
-                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
-            
-  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
-  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
-                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
-                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
-                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
-            
-  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
-  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
-                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
-                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
-                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
-            
-  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
-  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
-                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
-                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
-                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
-}
-
-/**
-  * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
-  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
-  *         structure which will be initialized.
-  * @retval None
-  */
-void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
-{  
-  /* Reset NOR/SRAM Init structure parameters values */
-  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
-  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
-  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
-  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
-  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
-  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
-  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
-  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
-  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
-  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
-  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
-  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
-  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
-  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
-}
-
-/**
-  * @brief  Fills each FSMC_NANDInitStruct member with its default value.
-  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
-  *         structure which will be initialized.
-  * @retval None
-  */
-void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
-{ 
-  /* Reset NAND Init structure parameters values */
-  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
-  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
-  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
-  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
-  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
-  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
-  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
-  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
-  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
-}
-
-/**
-  * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
-  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
-  *         structure which will be initialized.
-  * @retval None
-  */
-void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
-{
-  /* Reset PCCARD Init structure parameters values */
-  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
-  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
-  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
-  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
-  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
-  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
-}
-
-/**
-  * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
-  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
-  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
-  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
-  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
-    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
-  }
-  else
-  {
-    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
-    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified NAND Memory Bank.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
-    }
-    else
-    {
-      FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
-    }
-  }
-  else
-  {
-    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
-    }
-    else
-    {
-      FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
-    }
-  }
-}
-
-/**
-  * @brief  Enables or disables the PCCARD Memory Bank.
-  * @param  NewState: new state of the PCCARD Memory Bank.  
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void FSMC_PCCARDCmd(FunctionalState NewState)
-{
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
-    FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
-  }
-  else
-  {
-    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
-    FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the FSMC NAND ECC feature.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  * @param  NewState: new state of the FSMC NAND ECC feature.  
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
-    }
-    else
-    {
-      FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
-    }
-  }
-  else
-  {
-    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
-    }
-    else
-    {
-      FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
-    }
-  }
-}
-
-/**
-  * @brief  Returns the error correction code register value.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  * @retval The Error Correction Code (ECC) value.
-  */
-uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
-{
-  uint32_t eccval = 0x00000000;
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    /* Get the ECCR2 register value */
-    eccval = FSMC_Bank2->ECCR2;
-  }
-  else
-  {
-    /* Get the ECCR3 register value */
-    eccval = FSMC_Bank3->ECCR3;
-  }
-  /* Return the error correction code value */
-  return(eccval);
-}
-
-/**
-  * @brief  Enables or disables the specified FSMC interrupts.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-  * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
-  *   This parameter can be any combination of the following values:
-  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-  *     @arg FSMC_IT_Level: Level edge detection interrupt.
-  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
-  * @param  NewState: new state of the specified FSMC interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
-{
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_IT(FSMC_IT));	
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected FSMC_Bank2 interrupts */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      FSMC_Bank2->SR2 |= FSMC_IT;
-    }
-    /* Enable the selected FSMC_Bank3 interrupts */
-    else if (FSMC_Bank == FSMC_Bank3_NAND)
-    {
-      FSMC_Bank3->SR3 |= FSMC_IT;
-    }
-    /* Enable the selected FSMC_Bank4 interrupts */
-    else
-    {
-      FSMC_Bank4->SR4 |= FSMC_IT;    
-    }
-  }
-  else
-  {
-    /* Disable the selected FSMC_Bank2 interrupts */
-    if(FSMC_Bank == FSMC_Bank2_NAND)
-    {
-      
-      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
-    }
-    /* Disable the selected FSMC_Bank3 interrupts */
-    else if (FSMC_Bank == FSMC_Bank3_NAND)
-    {
-      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
-    }
-    /* Disable the selected FSMC_Bank4 interrupts */
-    else
-    {
-      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
-    }
-  }
-}
-
-/**
-  * @brief  Checks whether the specified FSMC flag is set or not.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-  * @param  FSMC_FLAG: specifies the flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
-  *     @arg FSMC_FLAG_Level: Level detection Flag.
-  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
-  *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
-  * @retval The new state of FSMC_FLAG (SET or RESET).
-  */
-FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  uint32_t tmpsr = 0x00000000;
-  
-  /* Check the parameters */
-  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    tmpsr = FSMC_Bank2->SR2;
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    tmpsr = FSMC_Bank3->SR3;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    tmpsr = FSMC_Bank4->SR4;
-  } 
-  
-  /* Get the flag status */
-  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the FSMC's pending flags.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-  * @param  FSMC_FLAG: specifies the flag to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
-  *     @arg FSMC_FLAG_Level: Level detection Flag.
-  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
-  * @retval None
-  */
-void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
-{
- /* Check the parameters */
-  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
-    
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
-  }
-}
-
-/**
-  * @brief  Checks whether the specified FSMC interrupt has occurred or not.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-  * @param  FSMC_IT: specifies the FSMC interrupt source to check.
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-  *     @arg FSMC_IT_Level: Level edge detection interrupt.
-  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
-  * @retval The new state of FSMC_IT (SET or RESET).
-  */
-ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
-  
-  /* Check the parameters */
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_GET_IT(FSMC_IT));
-  
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    tmpsr = FSMC_Bank2->SR2;
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    tmpsr = FSMC_Bank3->SR3;
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    tmpsr = FSMC_Bank4->SR4;
-  } 
-  
-  itstatus = tmpsr & FSMC_IT;
-  
-  itenable = tmpsr & (FSMC_IT >> 3);
-  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus; 
-}
-
-/**
-  * @brief  Clears the FSMC's interrupt pending bits.
-  * @param  FSMC_Bank: specifies the FSMC Bank to be used
-  *   This parameter can be one of the following values:
-  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
-  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
-  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
-  * @param  FSMC_IT: specifies the interrupt pending bit to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
-  *     @arg FSMC_IT_Level: Level edge detection interrupt.
-  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
-  * @retval None
-  */
-void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
-  assert_param(IS_FSMC_IT(FSMC_IT));
-    
-  if(FSMC_Bank == FSMC_Bank2_NAND)
-  {
-    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
-  }  
-  else if(FSMC_Bank == FSMC_Bank3_NAND)
-  {
-    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
-  }
-  /* FSMC_Bank4_PCCARD*/
-  else
-  {
-    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
-  }
-}
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_fsmc.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_fsmc.h
deleted file mode 100644
index 6e1769d9f..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_fsmc.h
+++ /dev/null
@@ -1,733 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_fsmc.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the FSMC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_FSMC_H
-#define __STM32F10x_FSMC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup FSMC
-  * @{
-  */
-
-/** @defgroup FSMC_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  Timing parameters For NOR/SRAM Banks  
-  */
-
-typedef struct
-{
-  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
-                                             the duration of the address setup time. 
-                                             This parameter can be a value between 0 and 0xF.
-                                             @note: It is not used with synchronous NOR Flash memories. */
-
-  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
-                                             the duration of the address hold time.
-                                             This parameter can be a value between 0 and 0xF. 
-                                             @note: It is not used with synchronous NOR Flash memories.*/
-
-  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
-                                             the duration of the data setup time.
-                                             This parameter can be a value between 0 and 0xFF.
-                                             @note: It is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
-
-  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
-                                             the duration of the bus turnaround.
-                                             This parameter can be a value between 0 and 0xF.
-                                             @note: It is only used for multiplexed NOR Flash memories. */
-
-  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
-                                             This parameter can be a value between 1 and 0xF.
-                                             @note: This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
-
-  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
-                                             to the memory before getting the first data.
-                                             The value of this parameter depends on the memory type as shown below:
-                                              - It must be set to 0 in case of a CRAM
-                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
-                                              - It may assume a value between 0 and 0xF in NOR Flash memories
-                                                with synchronous burst mode enable */
-
-  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
-                                             This parameter can be a value of @ref FSMC_Access_Mode */
-}FSMC_NORSRAMTimingInitTypeDef;
-
-/** 
-  * @brief  FSMC NOR/SRAM Init structure definition
-  */
-
-typedef struct
-{
-  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
-                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
-
-  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
-                                          multiplexed on the databus or not. 
-                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
-
-  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
-                                          the corresponding memory bank.
-                                          This parameter can be a value of @ref FSMC_Memory_Type */
-
-  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
-                                          This parameter can be a value of @ref FSMC_Data_Width */
-
-  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
-                                          valid only with synchronous burst Flash memories.
-                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
-                                       
-  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
-                                          valid only with asynchronous Flash memories.
-                                          This parameter can be a value of @ref FSMC_AsynchronousWait */
-
-  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
-                                          the Flash memory in burst mode.
-                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
-
-  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
-                                          memory, valid only when accessing Flash memories in burst mode.
-                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
-
-  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
-                                          clock cycle before the wait state or during the wait state,
-                                          valid only when accessing memories in burst mode. 
-                                          This parameter can be a value of @ref FSMC_Wait_Timing */
-
-  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC. 
-                                          This parameter can be a value of @ref FSMC_Write_Operation */
-
-  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait-state insertion via wait
-                                          signal, valid for Flash memory access in burst mode. 
-                                          This parameter can be a value of @ref FSMC_Wait_Signal */
-
-  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
-                                          This parameter can be a value of @ref FSMC_Extended_Mode */
-
-  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
-                                          This parameter can be a value of @ref FSMC_Write_Burst */ 
-
-  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  ExtendedMode is not used*/  
-
-  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  ExtendedMode is used*/      
-}FSMC_NORSRAMInitTypeDef;
-
-/** 
-  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
-  */
-
-typedef struct
-{
-  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
-                                     the command assertion for NAND-Flash read or write access
-                                     to common/Attribute or I/O memory space (depending on
-                                     the memory space timing to be configured).
-                                     This parameter can be a value between 0 and 0xFF.*/
-
-  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
-                                     command for NAND-Flash read or write access to
-                                     common/Attribute or I/O memory space (depending on the
-                                     memory space timing to be configured). 
-                                     This parameter can be a number between 0x00 and 0xFF */
-
-  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
-                                     (and data for write access) after the command deassertion
-                                     for NAND-Flash read or write access to common/Attribute
-                                     or I/O memory space (depending on the memory space timing
-                                     to be configured).
-                                     This parameter can be a number between 0x00 and 0xFF */
-
-  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
-                                     databus is kept in HiZ after the start of a NAND-Flash
-                                     write access to common/Attribute or I/O memory space (depending
-                                     on the memory space timing to be configured).
-                                     This parameter can be a number between 0x00 and 0xFF */
-}FSMC_NAND_PCCARDTimingInitTypeDef;
-
-/** 
-  * @brief  FSMC NAND Init structure definition
-  */
-
-typedef struct
-{
-  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
-                                      This parameter can be a value of @ref FSMC_NAND_Bank */
-
-  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
-                                       This parameter can be any value of @ref FSMC_Wait_feature */
-
-  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
-                                       This parameter can be any value of @ref FSMC_Data_Width */
-
-  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.
-                                       This parameter can be any value of @ref FSMC_ECC */
-
-  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
-                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */
-
-  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
-                                       delay between CLE low and RE low.
-                                       This parameter can be a value between 0 and 0xFF. */
-
-  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
-                                       delay between ALE low and RE low.
-                                       This parameter can be a number between 0x0 and 0xFF */ 
-
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */ 
-
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */
-}FSMC_NANDInitTypeDef;
-
-/** 
-  * @brief  FSMC PCCARD Init structure definition
-  */
-
-typedef struct
-{
-  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
-                                    This parameter can be any value of @ref FSMC_Wait_feature */
-
-  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
-                                     delay between CLE low and RE low.
-                                     This parameter can be a value between 0 and 0xFF. */
-
-  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
-                                     delay between ALE low and RE low.
-                                     This parameter can be a number between 0x0 and 0xFF */ 
-
-  
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */
-
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */ 
-  
-  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */  
-}FSMC_PCCARDInitTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Exported_Constants
-  * @{
-  */
-
-/** @defgroup FSMC_NORSRAM_Bank 
-  * @{
-  */
-#define FSMC_Bank1_NORSRAM1                             ((uint32_t)0x00000000)
-#define FSMC_Bank1_NORSRAM2                             ((uint32_t)0x00000002)
-#define FSMC_Bank1_NORSRAM3                             ((uint32_t)0x00000004)
-#define FSMC_Bank1_NORSRAM4                             ((uint32_t)0x00000006)
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_NAND_Bank 
-  * @{
-  */  
-#define FSMC_Bank2_NAND                                 ((uint32_t)0x00000010)
-#define FSMC_Bank3_NAND                                 ((uint32_t)0x00000100)
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_PCCARD_Bank 
-  * @{
-  */    
-#define FSMC_Bank4_PCCARD                               ((uint32_t)0x00001000)
-/**
-  * @}
-  */
-
-#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
-                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
-                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
-                                    ((BANK) == FSMC_Bank1_NORSRAM4))
-
-#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
-                                 ((BANK) == FSMC_Bank3_NAND))
-
-#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
-                                    ((BANK) == FSMC_Bank3_NAND) || \
-                                    ((BANK) == FSMC_Bank4_PCCARD))
-
-#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
-                               ((BANK) == FSMC_Bank3_NAND) || \
-                               ((BANK) == FSMC_Bank4_PCCARD))
-
-/** @defgroup NOR_SRAM_Controller 
-  * @{
-  */
-
-/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
-  * @{
-  */
-
-#define FSMC_DataAddressMux_Disable                       ((uint32_t)0x00000000)
-#define FSMC_DataAddressMux_Enable                        ((uint32_t)0x00000002)
-#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
-                          ((MUX) == FSMC_DataAddressMux_Enable))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Memory_Type 
-  * @{
-  */
-
-#define FSMC_MemoryType_SRAM                            ((uint32_t)0x00000000)
-#define FSMC_MemoryType_PSRAM                           ((uint32_t)0x00000004)
-#define FSMC_MemoryType_NOR                             ((uint32_t)0x00000008)
-#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
-                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
-                                ((MEMORY) == FSMC_MemoryType_NOR))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Data_Width 
-  * @{
-  */
-
-#define FSMC_MemoryDataWidth_8b                         ((uint32_t)0x00000000)
-#define FSMC_MemoryDataWidth_16b                        ((uint32_t)0x00000010)
-#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
-                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Burst_Access_Mode 
-  * @{
-  */
-
-#define FSMC_BurstAccessMode_Disable                    ((uint32_t)0x00000000) 
-#define FSMC_BurstAccessMode_Enable                     ((uint32_t)0x00000100)
-#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
-                                  ((STATE) == FSMC_BurstAccessMode_Enable))
-/**
-  * @}
-  */
-  
-/** @defgroup FSMC_AsynchronousWait 
-  * @{
-  */
-#define FSMC_AsynchronousWait_Disable                   ((uint32_t)0x00000000)
-#define FSMC_AsynchronousWait_Enable                    ((uint32_t)0x00008000)
-#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
-                                 ((STATE) == FSMC_AsynchronousWait_Enable))
-
-/**
-  * @}
-  */
-  
-/** @defgroup FSMC_Wait_Signal_Polarity 
-  * @{
-  */
-
-#define FSMC_WaitSignalPolarity_Low                     ((uint32_t)0x00000000)
-#define FSMC_WaitSignalPolarity_High                    ((uint32_t)0x00000200)
-#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
-                                         ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Wrap_Mode 
-  * @{
-  */
-
-#define FSMC_WrapMode_Disable                           ((uint32_t)0x00000000)
-#define FSMC_WrapMode_Enable                            ((uint32_t)0x00000400) 
-#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
-                                 ((MODE) == FSMC_WrapMode_Enable))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Wait_Timing 
-  * @{
-  */
-
-#define FSMC_WaitSignalActive_BeforeWaitState           ((uint32_t)0x00000000)
-#define FSMC_WaitSignalActive_DuringWaitState           ((uint32_t)0x00000800) 
-#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
-                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Write_Operation 
-  * @{
-  */
-
-#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
-#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
-#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
-                                            ((OPERATION) == FSMC_WriteOperation_Enable))
-                              
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Wait_Signal 
-  * @{
-  */
-
-#define FSMC_WaitSignal_Disable                         ((uint32_t)0x00000000)
-#define FSMC_WaitSignal_Enable                          ((uint32_t)0x00002000) 
-#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
-                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Extended_Mode 
-  * @{
-  */
-
-#define FSMC_ExtendedMode_Disable                       ((uint32_t)0x00000000)
-#define FSMC_ExtendedMode_Enable                        ((uint32_t)0x00004000)
-
-#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
-                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Write_Burst 
-  * @{
-  */
-
-#define FSMC_WriteBurst_Disable                         ((uint32_t)0x00000000)
-#define FSMC_WriteBurst_Enable                          ((uint32_t)0x00080000) 
-#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
-                                    ((BURST) == FSMC_WriteBurst_Enable))
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Address_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Address_Hold_Time 
-  * @{
-  */
-
-#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Data_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Bus_Turn_around_Duration 
-  * @{
-  */
-
-#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_CLK_Division 
-  * @{
-  */
-
-#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Data_Latency 
-  * @{
-  */
-
-#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Access_Mode 
-  * @{
-  */
-
-#define FSMC_AccessMode_A                               ((uint32_t)0x00000000)
-#define FSMC_AccessMode_B                               ((uint32_t)0x10000000) 
-#define FSMC_AccessMode_C                               ((uint32_t)0x20000000)
-#define FSMC_AccessMode_D                               ((uint32_t)0x30000000)
-#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
-                                   ((MODE) == FSMC_AccessMode_B) || \
-                                   ((MODE) == FSMC_AccessMode_C) || \
-                                   ((MODE) == FSMC_AccessMode_D)) 
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-  
-/** @defgroup NAND_PCCARD_Controller 
-  * @{
-  */
-
-/** @defgroup FSMC_Wait_feature 
-  * @{
-  */
-
-#define FSMC_Waitfeature_Disable                        ((uint32_t)0x00000000)
-#define FSMC_Waitfeature_Enable                         ((uint32_t)0x00000002)
-#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
-                                       ((FEATURE) == FSMC_Waitfeature_Enable))
-
-/**
-  * @}
-  */
-
-
-/** @defgroup FSMC_ECC 
-  * @{
-  */
-
-#define FSMC_ECC_Disable                                ((uint32_t)0x00000000)
-#define FSMC_ECC_Enable                                 ((uint32_t)0x00000040)
-#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
-                                  ((STATE) == FSMC_ECC_Enable))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_ECC_Page_Size 
-  * @{
-  */
-
-#define FSMC_ECCPageSize_256Bytes                       ((uint32_t)0x00000000)
-#define FSMC_ECCPageSize_512Bytes                       ((uint32_t)0x00020000)
-#define FSMC_ECCPageSize_1024Bytes                      ((uint32_t)0x00040000)
-#define FSMC_ECCPageSize_2048Bytes                      ((uint32_t)0x00060000)
-#define FSMC_ECCPageSize_4096Bytes                      ((uint32_t)0x00080000)
-#define FSMC_ECCPageSize_8192Bytes                      ((uint32_t)0x000A0000)
-#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
-                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
-                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
-                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
-                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
-                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_TCLR_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_TAR_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Wait_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Hold_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_HiZ_Setup_Time 
-  * @{
-  */
-
-#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Interrupt_sources 
-  * @{
-  */
-
-#define FSMC_IT_RisingEdge                              ((uint32_t)0x00000008)
-#define FSMC_IT_Level                                   ((uint32_t)0x00000010)
-#define FSMC_IT_FallingEdge                             ((uint32_t)0x00000020)
-#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
-#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
-                            ((IT) == FSMC_IT_Level) || \
-                            ((IT) == FSMC_IT_FallingEdge)) 
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Flags 
-  * @{
-  */
-
-#define FSMC_FLAG_RisingEdge                            ((uint32_t)0x00000001)
-#define FSMC_FLAG_Level                                 ((uint32_t)0x00000002)
-#define FSMC_FLAG_FallingEdge                           ((uint32_t)0x00000004)
-#define FSMC_FLAG_FEMPT                                 ((uint32_t)0x00000040)
-#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
-                                ((FLAG) == FSMC_FLAG_Level) || \
-                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
-                                ((FLAG) == FSMC_FLAG_FEMPT))
-
-#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup FSMC_Exported_Functions
-  * @{
-  */
-
-void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
-void FSMC_NANDDeInit(uint32_t FSMC_Bank);
-void FSMC_PCCARDDeInit(void);
-void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
-void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
-void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
-void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
-void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
-void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
-void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
-void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
-void FSMC_PCCARDCmd(FunctionalState NewState);
-void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
-uint32_t FSMC_GetECC(uint32_t FSMC_Bank);
-void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
-FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
-void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
-ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
-void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_FSMC_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_gpio.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_gpio.c
deleted file mode 100644
index 457ff112f..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_gpio.c
+++ /dev/null
@@ -1,650 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_gpio.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the GPIO firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_gpio.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup GPIO 
-  * @brief GPIO driver modules
-  * @{
-  */ 
-
-/** @defgroup GPIO_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Private_Defines
-  * @{
-  */
-
-/* ------------ RCC registers bit address in the alias region ----------------*/
-#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
-
-/* --- EVENTCR Register -----*/
-
-/* Alias word address of EVOE bit */
-#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
-#define EVOE_BitNumber              ((uint8_t)0x07)
-#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
-
-
-/* ---  MAPR Register ---*/ 
-/* Alias word address of MII_RMII_SEL bit */ 
-#define MAPR_OFFSET                 (AFIO_OFFSET + 0x04) 
-#define MII_RMII_SEL_BitNumber      ((u8)0x17) 
-#define MAPR_MII_RMII_SEL_BB        (PERIPH_BB_BASE + (MAPR_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4))
-
-
-#define EVCR_PORTPINCONFIG_MASK     ((uint16_t)0xFF80)
-#define LSB_MASK                    ((uint16_t)0xFFFF)
-#define DBGAFR_POSITION_MASK        ((uint32_t)0x000F0000)
-#define DBGAFR_SWJCFG_MASK          ((uint32_t)0xF0FFFFFF)
-#define DBGAFR_LOCATION_MASK        ((uint32_t)0x00200000)
-#define DBGAFR_NUMBITS_MASK         ((uint32_t)0x00100000)
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @retval None
-  */
-void GPIO_DeInit(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  if (GPIOx == GPIOA)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
-  }
-  else if (GPIOx == GPIOB)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
-  }
-  else if (GPIOx == GPIOC)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
-  }
-  else if (GPIOx == GPIOD)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
-  }    
-  else if (GPIOx == GPIOE)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
-  } 
-  else if (GPIOx == GPIOF)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
-  }
-  else
-  {
-    if (GPIOx == GPIOG)
-    {
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
-    }
-  }
-}
-
-/**
-  * @brief  Deinitializes the Alternate Functions (remap, event control
-  *   and EXTI configuration) registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void GPIO_AFIODeInit(void)
-{
-  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
-  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
-}
-
-/**
-  * @brief  Initializes the GPIOx peripheral according to the specified
-  *         parameters in the GPIO_InitStruct.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
-  *         contains the configuration information for the specified GPIO peripheral.
-  * @retval None
-  */
-void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
-{
-  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
-  uint32_t tmpreg = 0x00, pinmask = 0x00;
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
-  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
-  
-/*---------------------------- GPIO Mode Configuration -----------------------*/
-  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
-  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
-  { 
-    /* Check the parameters */
-    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
-    /* Output mode */
-    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
-  }
-/*---------------------------- GPIO CRL Configuration ------------------------*/
-  /* Configure the eight low port pins */
-  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
-  {
-    tmpreg = GPIOx->CRL;
-    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
-    {
-      pos = ((uint32_t)0x01) << pinpos;
-      /* Get the port pins position */
-      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
-      if (currentpin == pos)
-      {
-        pos = pinpos << 2;
-        /* Clear the corresponding low control register bits */
-        pinmask = ((uint32_t)0x0F) << pos;
-        tmpreg &= ~pinmask;
-        /* Write the mode configuration in the corresponding bits */
-        tmpreg |= (currentmode << pos);
-        /* Reset the corresponding ODR bit */
-        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
-        {
-          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
-        }
-        else
-        {
-          /* Set the corresponding ODR bit */
-          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
-          {
-            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
-          }
-        }
-      }
-    }
-    GPIOx->CRL = tmpreg;
-  }
-/*---------------------------- GPIO CRH Configuration ------------------------*/
-  /* Configure the eight high port pins */
-  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
-  {
-    tmpreg = GPIOx->CRH;
-    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
-    {
-      pos = (((uint32_t)0x01) << (pinpos + 0x08));
-      /* Get the port pins position */
-      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
-      if (currentpin == pos)
-      {
-        pos = pinpos << 2;
-        /* Clear the corresponding high control register bits */
-        pinmask = ((uint32_t)0x0F) << pos;
-        tmpreg &= ~pinmask;
-        /* Write the mode configuration in the corresponding bits */
-        tmpreg |= (currentmode << pos);
-        /* Reset the corresponding ODR bit */
-        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
-        {
-          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
-        }
-        /* Set the corresponding ODR bit */
-        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
-        {
-          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
-        }
-      }
-    }
-    GPIOx->CRH = tmpreg;
-  }
-}
-
-/**
-  * @brief  Fills each GPIO_InitStruct member with its default value.
-  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
-  *         be initialized.
-  * @retval None
-  */
-void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
-{
-  /* Reset GPIO init structure parameters values */
-  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
-  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
-  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
-}
-
-/**
-  * @brief  Reads the specified input port pin.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_Pin:  specifies the port bit to read.
-  *   This parameter can be GPIO_Pin_x where x can be (0..15).
-  * @retval The input port pin value.
-  */
-uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
-{
-  uint8_t bitstatus = 0x00;
-  
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
-  
-  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
-  {
-    bitstatus = (uint8_t)Bit_SET;
-  }
-  else
-  {
-    bitstatus = (uint8_t)Bit_RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Reads the specified GPIO input data port.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @retval GPIO input data port value.
-  */
-uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  return ((uint16_t)GPIOx->IDR);
-}
-
-/**
-  * @brief  Reads the specified output data port bit.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_Pin:  specifies the port bit to read.
-  *   This parameter can be GPIO_Pin_x where x can be (0..15).
-  * @retval The output port pin value.
-  */
-uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
-{
-  uint8_t bitstatus = 0x00;
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
-  
-  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
-  {
-    bitstatus = (uint8_t)Bit_SET;
-  }
-  else
-  {
-    bitstatus = (uint8_t)Bit_RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Reads the specified GPIO output data port.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @retval GPIO output data port value.
-  */
-uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-    
-  return ((uint16_t)GPIOx->ODR);
-}
-
-/**
-  * @brief  Sets the selected data port bits.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_Pin: specifies the port bits to be written.
-  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
-  * @retval None
-  */
-void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  GPIOx->BSRR = GPIO_Pin;
-}
-
-/**
-  * @brief  Clears the selected data port bits.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_Pin: specifies the port bits to be written.
-  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
-  * @retval None
-  */
-void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  GPIOx->BRR = GPIO_Pin;
-}
-
-/**
-  * @brief  Sets or clears the selected data port bit.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_Pin: specifies the port bit to be written.
-  *   This parameter can be one of GPIO_Pin_x where x can be (0..15).
-  * @param  BitVal: specifies the value to be written to the selected bit.
-  *   This parameter can be one of the BitAction enum values:
-  *     @arg Bit_RESET: to clear the port pin
-  *     @arg Bit_SET: to set the port pin
-  * @retval None
-  */
-void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
-  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
-  
-  if (BitVal != Bit_RESET)
-  {
-    GPIOx->BSRR = GPIO_Pin;
-  }
-  else
-  {
-    GPIOx->BRR = GPIO_Pin;
-  }
-}
-
-/**
-  * @brief  Writes data to the specified GPIO data port.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  PortVal: specifies the value to be written to the port output data register.
-  * @retval None
-  */
-void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
-{
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  
-  GPIOx->ODR = PortVal;
-}
-
-/**
-  * @brief  Locks GPIO Pins configuration registers.
-  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
-  * @param  GPIO_Pin: specifies the port bit to be written.
-  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
-  * @retval None
-  */
-void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
-{
-  uint32_t tmp = 0x00010000;
-  
-  /* Check the parameters */
-  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
-  assert_param(IS_GPIO_PIN(GPIO_Pin));
-  
-  tmp |= GPIO_Pin;
-  /* Set LCKK bit */
-  GPIOx->LCKR = tmp;
-  /* Reset LCKK bit */
-  GPIOx->LCKR =  GPIO_Pin;
-  /* Set LCKK bit */
-  GPIOx->LCKR = tmp;
-  /* Read LCKK bit*/
-  tmp = GPIOx->LCKR;
-  /* Read LCKK bit*/
-  tmp = GPIOx->LCKR;
-}
-
-/**
-  * @brief  Selects the GPIO pin used as Event output.
-  * @param  GPIO_PortSource: selects the GPIO port to be used as source
-  *   for Event output.
-  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..E).
-  * @param  GPIO_PinSource: specifies the pin for the Event output.
-  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
-  * @retval None
-  */
-void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
-{
-  uint32_t tmpreg = 0x00;
-  /* Check the parameters */
-  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
-  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
-    
-  tmpreg = AFIO->EVCR;
-  /* Clear the PORT[6:4] and PIN[3:0] bits */
-  tmpreg &= EVCR_PORTPINCONFIG_MASK;
-  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
-  tmpreg |= GPIO_PinSource;
-  AFIO->EVCR = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the Event Output.
-  * @param  NewState: new state of the Event output.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void GPIO_EventOutputCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Changes the mapping of the specified pin.
-  * @param  GPIO_Remap: selects the pin to remap.
-  *   This parameter can be one of the following values:
-  *     @arg GPIO_Remap_SPI1             : SPI1 Alternate Function mapping
-  *     @arg GPIO_Remap_I2C1             : I2C1 Alternate Function mapping
-  *     @arg GPIO_Remap_USART1           : USART1 Alternate Function mapping
-  *     @arg GPIO_Remap_USART2           : USART2 Alternate Function mapping
-  *     @arg GPIO_PartialRemap_USART3    : USART3 Partial Alternate Function mapping
-  *     @arg GPIO_FullRemap_USART3       : USART3 Full Alternate Function mapping
-  *     @arg GPIO_PartialRemap_TIM1      : TIM1 Partial Alternate Function mapping
-  *     @arg GPIO_FullRemap_TIM1         : TIM1 Full Alternate Function mapping
-  *     @arg GPIO_PartialRemap1_TIM2     : TIM2 Partial1 Alternate Function mapping
-  *     @arg GPIO_PartialRemap2_TIM2     : TIM2 Partial2 Alternate Function mapping
-  *     @arg GPIO_FullRemap_TIM2         : TIM2 Full Alternate Function mapping
-  *     @arg GPIO_PartialRemap_TIM3      : TIM3 Partial Alternate Function mapping
-  *     @arg GPIO_FullRemap_TIM3         : TIM3 Full Alternate Function mapping
-  *     @arg GPIO_Remap_TIM4             : TIM4 Alternate Function mapping
-  *     @arg GPIO_Remap1_CAN1            : CAN1 Alternate Function mapping
-  *     @arg GPIO_Remap2_CAN1            : CAN1 Alternate Function mapping
-  *     @arg GPIO_Remap_PD01             : PD01 Alternate Function mapping
-  *     @arg GPIO_Remap_TIM5CH4_LSI      : LSI connected to TIM5 Channel4 input capture for calibration
-  *     @arg GPIO_Remap_ADC1_ETRGINJ     : ADC1 External Trigger Injected Conversion remapping
-  *     @arg GPIO_Remap_ADC1_ETRGREG     : ADC1 External Trigger Regular Conversion remapping
-  *     @arg GPIO_Remap_ADC2_ETRGINJ     : ADC2 External Trigger Injected Conversion remapping
-  *     @arg GPIO_Remap_ADC2_ETRGREG     : ADC2 External Trigger Regular Conversion remapping
-  *     @arg GPIO_Remap_ETH              : Ethernet remapping (only for Connectivity line devices)
-  *     @arg GPIO_Remap_CAN2             : CAN2 remapping (only for Connectivity line devices)
-  *     @arg GPIO_Remap_SWJ_NoJTRST      : Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST
-  *     @arg GPIO_Remap_SWJ_JTAGDisable  : JTAG-DP Disabled and SW-DP Enabled
-  *     @arg GPIO_Remap_SWJ_Disable      : Full SWJ Disabled (JTAG-DP + SW-DP)
-  *     @arg GPIO_Remap_SPI3             : SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices)
-  *                                        When the SPI3/I2S3 is remapped using this function, the SWJ is configured
-  *                                        to Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST.   
-  *     @arg GPIO_Remap_TIM2ITR1_PTP_SOF : Ethernet PTP output or USB OTG SOF (Start of Frame) connected
-  *                                        to TIM2 Internal Trigger 1 for calibration (only for Connectivity line devices)
-  *                                        If the GPIO_Remap_TIM2ITR1_PTP_SOF is enabled the TIM2 ITR1 is connected to 
-  *                                        Ethernet PTP output. When Reset TIM2 ITR1 is connected to USB OTG SOF output.    
-  *     @arg GPIO_Remap_PTP_PPS          : Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices)
-  *     @arg GPIO_Remap_TIM15            : TIM15 Alternate Function mapping (only for Value line devices)
-  *     @arg GPIO_Remap_TIM16            : TIM16 Alternate Function mapping (only for Value line devices)
-  *     @arg GPIO_Remap_TIM17            : TIM17 Alternate Function mapping (only for Value line devices)
-  *     @arg GPIO_Remap_CEC              : CEC Alternate Function mapping (only for Value line devices)
-  *     @arg GPIO_Remap_TIM1_DMA         : TIM1 DMA requests mapping (only for Value line devices)
-  *     @arg GPIO_Remap_TIM9             : TIM9 Alternate Function mapping (only for XL-density devices)
-  *     @arg GPIO_Remap_TIM10            : TIM10 Alternate Function mapping (only for XL-density devices)
-  *     @arg GPIO_Remap_TIM11            : TIM11 Alternate Function mapping (only for XL-density devices)
-  *     @arg GPIO_Remap_TIM13            : TIM13 Alternate Function mapping (only for High density Value line and XL-density devices)
-  *     @arg GPIO_Remap_TIM14            : TIM14 Alternate Function mapping (only for High density Value line and XL-density devices)
-  *     @arg GPIO_Remap_FSMC_NADV        : FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices)
-  *     @arg GPIO_Remap_TIM67_DAC_DMA    : TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices)
-  *     @arg GPIO_Remap_TIM12            : TIM12 Alternate Function mapping (only for High density Value line devices)
-  *     @arg GPIO_Remap_MISC             : Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping, 
-  *                                        only for High density Value line devices)     
-  * @param  NewState: new state of the port pin remapping.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
-{
-  uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
-
-  /* Check the parameters */
-  assert_param(IS_GPIO_REMAP(GPIO_Remap));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));  
-  
-  if((GPIO_Remap & 0x80000000) == 0x80000000)
-  {
-    tmpreg = AFIO->MAPR2;
-  }
-  else
-  {
-    tmpreg = AFIO->MAPR;
-  }
-
-  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
-  tmp = GPIO_Remap & LSB_MASK;
-
-  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
-  {
-    tmpreg &= DBGAFR_SWJCFG_MASK;
-    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
-  }
-  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
-  {
-    tmp1 = ((uint32_t)0x03) << tmpmask;
-    tmpreg &= ~tmp1;
-    tmpreg |= ~DBGAFR_SWJCFG_MASK;
-  }
-  else
-  {
-    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
-    tmpreg |= ~DBGAFR_SWJCFG_MASK;
-  }
-
-  if (NewState != DISABLE)
-  {
-    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
-  }
-
-  if((GPIO_Remap & 0x80000000) == 0x80000000)
-  {
-    AFIO->MAPR2 = tmpreg;
-  }
-  else
-  {
-    AFIO->MAPR = tmpreg;
-  }  
-}
-
-/**
-  * @brief  Selects the GPIO pin used as EXTI Line.
-  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.
-  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).
-  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
-  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
-  * @retval None
-  */
-void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
-{
-  uint32_t tmp = 0x00;
-  /* Check the parameters */
-  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
-  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
-  
-  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
-  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
-  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
-}
-
-/**
-  * @brief  Selects the Ethernet media interface.
-  * @note   This function applies only to STM32 Connectivity line devices.  
-  * @param  GPIO_ETH_MediaInterface: specifies the Media Interface mode.
-  *   This parameter can be one of the following values:
-  *     @arg GPIO_ETH_MediaInterface_MII: MII mode
-  *     @arg GPIO_ETH_MediaInterface_RMII: RMII mode    
-  * @retval None
-  */
-void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
-{ 
-  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 
-
-  /* Configure MII_RMII selection bit */ 
-  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
-}
-  
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_gpio.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_gpio.h
deleted file mode 100644
index dd28da89c..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_gpio.h
+++ /dev/null
@@ -1,385 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_gpio.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the GPIO 
-  *          firmware library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_GPIO_H
-#define __STM32F10x_GPIO_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup GPIO
-  * @{
-  */
-
-/** @defgroup GPIO_Exported_Types
-  * @{
-  */
-
-#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
-                                    ((PERIPH) == GPIOB) || \
-                                    ((PERIPH) == GPIOC) || \
-                                    ((PERIPH) == GPIOD) || \
-                                    ((PERIPH) == GPIOE) || \
-                                    ((PERIPH) == GPIOF) || \
-                                    ((PERIPH) == GPIOG))
-                                     
-/** 
-  * @brief  Output Maximum frequency selection  
-  */
-
-typedef enum
-{ 
-  GPIO_Speed_10MHz = 1,
-  GPIO_Speed_2MHz, 
-  GPIO_Speed_50MHz
-}GPIOSpeed_TypeDef;
-#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \
-                              ((SPEED) == GPIO_Speed_50MHz))
-
-/** 
-  * @brief  Configuration Mode enumeration  
-  */
-
-typedef enum
-{ GPIO_Mode_AIN = 0x0,
-  GPIO_Mode_IN_FLOATING = 0x04,
-  GPIO_Mode_IPD = 0x28,
-  GPIO_Mode_IPU = 0x48,
-  GPIO_Mode_Out_OD = 0x14,
-  GPIO_Mode_Out_PP = 0x10,
-  GPIO_Mode_AF_OD = 0x1C,
-  GPIO_Mode_AF_PP = 0x18
-}GPIOMode_TypeDef;
-
-#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \
-                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \
-                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \
-                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
-
-/** 
-  * @brief  GPIO Init structure definition  
-  */
-
-typedef struct
-{
-  uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
-                                      This parameter can be any value of @ref GPIO_pins_define */
-
-  GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
-                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */
-
-  GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
-                                      This parameter can be a value of @ref GPIOMode_TypeDef */
-}GPIO_InitTypeDef;
-
-
-/** 
-  * @brief  Bit_SET and Bit_RESET enumeration  
-  */
-
-typedef enum
-{ Bit_RESET = 0,
-  Bit_SET
-}BitAction;
-
-#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Exported_Constants
-  * @{
-  */
-
-/** @defgroup GPIO_pins_define 
-  * @{
-  */
-
-#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected */
-#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */
-#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected */
-#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected */
-#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected */
-#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected */
-#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected */
-#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected */
-#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected */
-#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
-#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
-#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected */
-#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected */
-#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected */
-#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected */
-#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected */
-#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
-
-#define IS_GPIO_PIN(PIN) ((((PIN) & (uint16_t)0x00) == 0x00) && ((PIN) != (uint16_t)0x00))
-
-#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
-                              ((PIN) == GPIO_Pin_1) || \
-                              ((PIN) == GPIO_Pin_2) || \
-                              ((PIN) == GPIO_Pin_3) || \
-                              ((PIN) == GPIO_Pin_4) || \
-                              ((PIN) == GPIO_Pin_5) || \
-                              ((PIN) == GPIO_Pin_6) || \
-                              ((PIN) == GPIO_Pin_7) || \
-                              ((PIN) == GPIO_Pin_8) || \
-                              ((PIN) == GPIO_Pin_9) || \
-                              ((PIN) == GPIO_Pin_10) || \
-                              ((PIN) == GPIO_Pin_11) || \
-                              ((PIN) == GPIO_Pin_12) || \
-                              ((PIN) == GPIO_Pin_13) || \
-                              ((PIN) == GPIO_Pin_14) || \
-                              ((PIN) == GPIO_Pin_15))
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Remap_define 
-  * @{
-  */
-
-#define GPIO_Remap_SPI1             ((uint32_t)0x00000001)  /*!< SPI1 Alternate Function mapping */
-#define GPIO_Remap_I2C1             ((uint32_t)0x00000002)  /*!< I2C1 Alternate Function mapping */
-#define GPIO_Remap_USART1           ((uint32_t)0x00000004)  /*!< USART1 Alternate Function mapping */
-#define GPIO_Remap_USART2           ((uint32_t)0x00000008)  /*!< USART2 Alternate Function mapping */
-#define GPIO_PartialRemap_USART3    ((uint32_t)0x00140010)  /*!< USART3 Partial Alternate Function mapping */
-#define GPIO_FullRemap_USART3       ((uint32_t)0x00140030)  /*!< USART3 Full Alternate Function mapping */
-#define GPIO_PartialRemap_TIM1      ((uint32_t)0x00160040)  /*!< TIM1 Partial Alternate Function mapping */
-#define GPIO_FullRemap_TIM1         ((uint32_t)0x001600C0)  /*!< TIM1 Full Alternate Function mapping */
-#define GPIO_PartialRemap1_TIM2     ((uint32_t)0x00180100)  /*!< TIM2 Partial1 Alternate Function mapping */
-#define GPIO_PartialRemap2_TIM2     ((uint32_t)0x00180200)  /*!< TIM2 Partial2 Alternate Function mapping */
-#define GPIO_FullRemap_TIM2         ((uint32_t)0x00180300)  /*!< TIM2 Full Alternate Function mapping */
-#define GPIO_PartialRemap_TIM3      ((uint32_t)0x001A0800)  /*!< TIM3 Partial Alternate Function mapping */
-#define GPIO_FullRemap_TIM3         ((uint32_t)0x001A0C00)  /*!< TIM3 Full Alternate Function mapping */
-#define GPIO_Remap_TIM4             ((uint32_t)0x00001000)  /*!< TIM4 Alternate Function mapping */
-#define GPIO_Remap1_CAN1            ((uint32_t)0x001D4000)  /*!< CAN1 Alternate Function mapping */
-#define GPIO_Remap2_CAN1            ((uint32_t)0x001D6000)  /*!< CAN1 Alternate Function mapping */
-#define GPIO_Remap_PD01             ((uint32_t)0x00008000)  /*!< PD01 Alternate Function mapping */
-#define GPIO_Remap_TIM5CH4_LSI      ((uint32_t)0x00200001)  /*!< LSI connected to TIM5 Channel4 input capture for calibration */
-#define GPIO_Remap_ADC1_ETRGINJ     ((uint32_t)0x00200002)  /*!< ADC1 External Trigger Injected Conversion remapping */
-#define GPIO_Remap_ADC1_ETRGREG     ((uint32_t)0x00200004)  /*!< ADC1 External Trigger Regular Conversion remapping */
-#define GPIO_Remap_ADC2_ETRGINJ     ((uint32_t)0x00200008)  /*!< ADC2 External Trigger Injected Conversion remapping */
-#define GPIO_Remap_ADC2_ETRGREG     ((uint32_t)0x00200010)  /*!< ADC2 External Trigger Regular Conversion remapping */
-#define GPIO_Remap_ETH              ((uint32_t)0x00200020)  /*!< Ethernet remapping (only for Connectivity line devices) */
-#define GPIO_Remap_CAN2             ((uint32_t)0x00200040)  /*!< CAN2 remapping (only for Connectivity line devices) */
-#define GPIO_Remap_SWJ_NoJTRST      ((uint32_t)0x00300100)  /*!< Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
-#define GPIO_Remap_SWJ_JTAGDisable  ((uint32_t)0x00300200)  /*!< JTAG-DP Disabled and SW-DP Enabled */
-#define GPIO_Remap_SWJ_Disable      ((uint32_t)0x00300400)  /*!< Full SWJ Disabled (JTAG-DP + SW-DP) */
-#define GPIO_Remap_SPI3             ((uint32_t)0x00201100)  /*!< SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices) */
-#define GPIO_Remap_TIM2ITR1_PTP_SOF ((uint32_t)0x00202000)  /*!< Ethernet PTP output or USB OTG SOF (Start of Frame) connected
-                                                                 to TIM2 Internal Trigger 1 for calibration
-                                                                 (only for Connectivity line devices) */
-#define GPIO_Remap_PTP_PPS          ((uint32_t)0x00204000)  /*!< Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices) */
-
-#define GPIO_Remap_TIM15            ((uint32_t)0x80000001)  /*!< TIM15 Alternate Function mapping (only for Value line devices) */
-#define GPIO_Remap_TIM16            ((uint32_t)0x80000002)  /*!< TIM16 Alternate Function mapping (only for Value line devices) */
-#define GPIO_Remap_TIM17            ((uint32_t)0x80000004)  /*!< TIM17 Alternate Function mapping (only for Value line devices) */
-#define GPIO_Remap_CEC              ((uint32_t)0x80000008)  /*!< CEC Alternate Function mapping (only for Value line devices) */
-#define GPIO_Remap_TIM1_DMA         ((uint32_t)0x80000010)  /*!< TIM1 DMA requests mapping (only for Value line devices) */
-
-#define GPIO_Remap_TIM9             ((uint32_t)0x80000020)  /*!< TIM9 Alternate Function mapping (only for XL-density devices) */
-#define GPIO_Remap_TIM10            ((uint32_t)0x80000040)  /*!< TIM10 Alternate Function mapping (only for XL-density devices) */
-#define GPIO_Remap_TIM11            ((uint32_t)0x80000080)  /*!< TIM11 Alternate Function mapping (only for XL-density devices) */
-#define GPIO_Remap_TIM13            ((uint32_t)0x80000100)  /*!< TIM13 Alternate Function mapping (only for High density Value line and XL-density devices) */
-#define GPIO_Remap_TIM14            ((uint32_t)0x80000200)  /*!< TIM14 Alternate Function mapping (only for High density Value line and XL-density devices) */
-#define GPIO_Remap_FSMC_NADV        ((uint32_t)0x80000400)  /*!< FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices) */
-
-#define GPIO_Remap_TIM67_DAC_DMA    ((uint32_t)0x80000800)  /*!< TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices) */
-#define GPIO_Remap_TIM12            ((uint32_t)0x80001000)  /*!< TIM12 Alternate Function mapping (only for High density Value line devices) */
-#define GPIO_Remap_MISC             ((uint32_t)0x80002000)  /*!< Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping, 
-                                                                 only for High density Value line devices) */                                                       
-
-#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \
-                              ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \
-                              ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \
-                              ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) || \
-                              ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \
-                              ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \
-                              ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \
-                              ((REMAP) == GPIO_Remap1_CAN1) || ((REMAP) == GPIO_Remap2_CAN1) || \
-                              ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \
-                              ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \
-                              ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \
-                              ((REMAP) == GPIO_Remap_ETH) ||((REMAP) == GPIO_Remap_CAN2) || \
-                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable) || \
-                              ((REMAP) == GPIO_Remap_SWJ_Disable)|| ((REMAP) == GPIO_Remap_SPI3) || \
-                              ((REMAP) == GPIO_Remap_TIM2ITR1_PTP_SOF) || ((REMAP) == GPIO_Remap_PTP_PPS) || \
-                              ((REMAP) == GPIO_Remap_TIM15) || ((REMAP) == GPIO_Remap_TIM16) || \
-                              ((REMAP) == GPIO_Remap_TIM17) || ((REMAP) == GPIO_Remap_CEC) || \
-                              ((REMAP) == GPIO_Remap_TIM1_DMA) || ((REMAP) == GPIO_Remap_TIM9) || \
-                              ((REMAP) == GPIO_Remap_TIM10) || ((REMAP) == GPIO_Remap_TIM11) || \
-                              ((REMAP) == GPIO_Remap_TIM13) || ((REMAP) == GPIO_Remap_TIM14) || \
-                              ((REMAP) == GPIO_Remap_FSMC_NADV) || ((REMAP) == GPIO_Remap_TIM67_DAC_DMA) || \
-                              ((REMAP) == GPIO_Remap_TIM12) || ((REMAP) == GPIO_Remap_MISC))
-                              
-/**
-  * @}
-  */ 
-
-/** @defgroup GPIO_Port_Sources 
-  * @{
-  */
-
-#define GPIO_PortSourceGPIOA       ((uint8_t)0x00)
-#define GPIO_PortSourceGPIOB       ((uint8_t)0x01)
-#define GPIO_PortSourceGPIOC       ((uint8_t)0x02)
-#define GPIO_PortSourceGPIOD       ((uint8_t)0x03)
-#define GPIO_PortSourceGPIOE       ((uint8_t)0x04)
-#define GPIO_PortSourceGPIOF       ((uint8_t)0x05)
-#define GPIO_PortSourceGPIOG       ((uint8_t)0x06)
-#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
-                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
-                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
-                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
-                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOE))
-
-#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
-                                              ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
-                                              ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
-                                              ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
-                                              ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \
-                                              ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \
-                                              ((PORTSOURCE) == GPIO_PortSourceGPIOG))
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Pin_sources 
-  * @{
-  */
-
-#define GPIO_PinSource0            ((uint8_t)0x00)
-#define GPIO_PinSource1            ((uint8_t)0x01)
-#define GPIO_PinSource2            ((uint8_t)0x02)
-#define GPIO_PinSource3            ((uint8_t)0x03)
-#define GPIO_PinSource4            ((uint8_t)0x04)
-#define GPIO_PinSource5            ((uint8_t)0x05)
-#define GPIO_PinSource6            ((uint8_t)0x06)
-#define GPIO_PinSource7            ((uint8_t)0x07)
-#define GPIO_PinSource8            ((uint8_t)0x08)
-#define GPIO_PinSource9            ((uint8_t)0x09)
-#define GPIO_PinSource10           ((uint8_t)0x0A)
-#define GPIO_PinSource11           ((uint8_t)0x0B)
-#define GPIO_PinSource12           ((uint8_t)0x0C)
-#define GPIO_PinSource13           ((uint8_t)0x0D)
-#define GPIO_PinSource14           ((uint8_t)0x0E)
-#define GPIO_PinSource15           ((uint8_t)0x0F)
-
-#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
-                                       ((PINSOURCE) == GPIO_PinSource1) || \
-                                       ((PINSOURCE) == GPIO_PinSource2) || \
-                                       ((PINSOURCE) == GPIO_PinSource3) || \
-                                       ((PINSOURCE) == GPIO_PinSource4) || \
-                                       ((PINSOURCE) == GPIO_PinSource5) || \
-                                       ((PINSOURCE) == GPIO_PinSource6) || \
-                                       ((PINSOURCE) == GPIO_PinSource7) || \
-                                       ((PINSOURCE) == GPIO_PinSource8) || \
-                                       ((PINSOURCE) == GPIO_PinSource9) || \
-                                       ((PINSOURCE) == GPIO_PinSource10) || \
-                                       ((PINSOURCE) == GPIO_PinSource11) || \
-                                       ((PINSOURCE) == GPIO_PinSource12) || \
-                                       ((PINSOURCE) == GPIO_PinSource13) || \
-                                       ((PINSOURCE) == GPIO_PinSource14) || \
-                                       ((PINSOURCE) == GPIO_PinSource15))
-
-/**
-  * @}
-  */
-
-/** @defgroup Ethernet_Media_Interface 
-  * @{
-  */ 
-#define GPIO_ETH_MediaInterface_MII    ((u32)0x00000000) 
-#define GPIO_ETH_MediaInterface_RMII   ((u32)0x00000001)                                       
-
-#define IS_GPIO_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == GPIO_ETH_MediaInterface_MII) || \
-                                                ((INTERFACE) == GPIO_ETH_MediaInterface_RMII))
-
-/**
-  * @}
-  */                                                
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup GPIO_Exported_Functions
-  * @{
-  */
-
-void GPIO_DeInit(GPIO_TypeDef* GPIOx);
-void GPIO_AFIODeInit(void);
-void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
-void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
-uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
-uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
-void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
-void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
-void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
-void GPIO_EventOutputCmd(FunctionalState NewState);
-void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);
-void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);
-void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_GPIO_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_i2c.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_i2c.c
deleted file mode 100644
index 621fd59a3..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_i2c.c
+++ /dev/null
@@ -1,1331 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_i2c.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the I2C firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_i2c.h"
-#include "stm32f10x_rcc.h"
-
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup I2C 
-  * @brief I2C driver modules
-  * @{
-  */ 
-
-/** @defgroup I2C_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Private_Defines
-  * @{
-  */
-
-/* I2C SPE mask */
-#define CR1_PE_Set              ((uint16_t)0x0001)
-#define CR1_PE_Reset            ((uint16_t)0xFFFE)
-
-/* I2C START mask */
-#define CR1_START_Set           ((uint16_t)0x0100)
-#define CR1_START_Reset         ((uint16_t)0xFEFF)
-
-/* I2C STOP mask */
-#define CR1_STOP_Set            ((uint16_t)0x0200)
-#define CR1_STOP_Reset          ((uint16_t)0xFDFF)
-
-/* I2C ACK mask */
-#define CR1_ACK_Set             ((uint16_t)0x0400)
-#define CR1_ACK_Reset           ((uint16_t)0xFBFF)
-
-/* I2C ENGC mask */
-#define CR1_ENGC_Set            ((uint16_t)0x0040)
-#define CR1_ENGC_Reset          ((uint16_t)0xFFBF)
-
-/* I2C SWRST mask */
-#define CR1_SWRST_Set           ((uint16_t)0x8000)
-#define CR1_SWRST_Reset         ((uint16_t)0x7FFF)
-
-/* I2C PEC mask */
-#define CR1_PEC_Set             ((uint16_t)0x1000)
-#define CR1_PEC_Reset           ((uint16_t)0xEFFF)
-
-/* I2C ENPEC mask */
-#define CR1_ENPEC_Set           ((uint16_t)0x0020)
-#define CR1_ENPEC_Reset         ((uint16_t)0xFFDF)
-
-/* I2C ENARP mask */
-#define CR1_ENARP_Set           ((uint16_t)0x0010)
-#define CR1_ENARP_Reset         ((uint16_t)0xFFEF)
-
-/* I2C NOSTRETCH mask */
-#define CR1_NOSTRETCH_Set       ((uint16_t)0x0080)
-#define CR1_NOSTRETCH_Reset     ((uint16_t)0xFF7F)
-
-/* I2C registers Masks */
-#define CR1_CLEAR_Mask          ((uint16_t)0xFBF5)
-
-/* I2C DMAEN mask */
-#define CR2_DMAEN_Set           ((uint16_t)0x0800)
-#define CR2_DMAEN_Reset         ((uint16_t)0xF7FF)
-
-/* I2C LAST mask */
-#define CR2_LAST_Set            ((uint16_t)0x1000)
-#define CR2_LAST_Reset          ((uint16_t)0xEFFF)
-
-/* I2C FREQ mask */
-#define CR2_FREQ_Reset          ((uint16_t)0xFFC0)
-
-/* I2C ADD0 mask */
-#define OAR1_ADD0_Set           ((uint16_t)0x0001)
-#define OAR1_ADD0_Reset         ((uint16_t)0xFFFE)
-
-/* I2C ENDUAL mask */
-#define OAR2_ENDUAL_Set         ((uint16_t)0x0001)
-#define OAR2_ENDUAL_Reset       ((uint16_t)0xFFFE)
-
-/* I2C ADD2 mask */
-#define OAR2_ADD2_Reset         ((uint16_t)0xFF01)
-
-/* I2C F/S mask */
-#define CCR_FS_Set              ((uint16_t)0x8000)
-
-/* I2C CCR mask */
-#define CCR_CCR_Set             ((uint16_t)0x0FFF)
-
-/* I2C FLAG mask */
-#define FLAG_Mask               ((uint32_t)0x00FFFFFF)
-
-/* I2C Interrupt Enable mask */
-#define ITEN_Mask               ((uint32_t)0x07000000)
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @retval None
-  */
-void I2C_DeInit(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  if (I2Cx == I2C1)
-  {
-    /* Enable I2C1 reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
-    /* Release I2C1 from reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
-  }
-  else
-  {
-    /* Enable I2C2 reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
-    /* Release I2C2 from reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
-  }
-}
-
-/**
-  * @brief  Initializes the I2Cx peripheral according to the specified 
-  *   parameters in the I2C_InitStruct.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
-  *   contains the configuration information for the specified I2C peripheral.
-  * @retval None
-  */
-void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
-{
-  uint16_t tmpreg = 0, freqrange = 0;
-  uint16_t result = 0x04;
-  uint32_t pclk1 = 8000000;
-  RCC_ClocksTypeDef  rcc_clocks;
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
-  assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
-  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
-  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
-  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
-  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
-
-/*---------------------------- I2Cx CR2 Configuration ------------------------*/
-  /* Get the I2Cx CR2 value */
-  tmpreg = I2Cx->CR2;
-  /* Clear frequency FREQ[5:0] bits */
-  tmpreg &= CR2_FREQ_Reset;
-  /* Get pclk1 frequency value */
-  RCC_GetClocksFreq(&rcc_clocks);
-  pclk1 = rcc_clocks.PCLK1_Frequency;
-  /* Set frequency bits depending on pclk1 value */
-  freqrange = (uint16_t)(pclk1 / 1000000);
-  tmpreg |= freqrange;
-  /* Write to I2Cx CR2 */
-  I2Cx->CR2 = tmpreg;
-
-/*---------------------------- I2Cx CCR Configuration ------------------------*/
-  /* Disable the selected I2C peripheral to configure TRISE */
-  I2Cx->CR1 &= CR1_PE_Reset;
-  /* Reset tmpreg value */
-  /* Clear F/S, DUTY and CCR[11:0] bits */
-  tmpreg = 0;
-
-  /* Configure speed in standard mode */
-  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
-  {
-    /* Standard mode speed calculate */
-    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
-    /* Test if CCR value is under 0x4*/
-    if (result < 0x04)
-    {
-      /* Set minimum allowed value */
-      result = 0x04;  
-    }
-    /* Set speed value for standard mode */
-    tmpreg |= result;	  
-    /* Set Maximum Rise Time for standard mode */
-    I2Cx->TRISE = freqrange + 1; 
-  }
-  /* Configure speed in fast mode */
-  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
-  {
-    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
-    {
-      /* Fast mode speed calculate: Tlow/Thigh = 2 */
-      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
-    }
-    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
-    {
-      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
-      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
-      /* Set DUTY bit */
-      result |= I2C_DutyCycle_16_9;
-    }
-
-    /* Test if CCR value is under 0x1*/
-    if ((result & CCR_CCR_Set) == 0)
-    {
-      /* Set minimum allowed value */
-      result |= (uint16_t)0x0001;  
-    }
-    /* Set speed value and set F/S bit for fast mode */
-    tmpreg |= (uint16_t)(result | CCR_FS_Set);
-    /* Set Maximum Rise Time for fast mode */
-    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
-  }
-
-  /* Write to I2Cx CCR */
-  I2Cx->CCR = tmpreg;
-  /* Enable the selected I2C peripheral */
-  I2Cx->CR1 |= CR1_PE_Set;
-
-/*---------------------------- I2Cx CR1 Configuration ------------------------*/
-  /* Get the I2Cx CR1 value */
-  tmpreg = I2Cx->CR1;
-  /* Clear ACK, SMBTYPE and  SMBUS bits */
-  tmpreg &= CR1_CLEAR_Mask;
-  /* Configure I2Cx: mode and acknowledgement */
-  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
-  /* Set ACK bit according to I2C_Ack value */
-  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
-  /* Write to I2Cx CR1 */
-  I2Cx->CR1 = tmpreg;
-
-/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
-  /* Set I2Cx Own Address1 and acknowledged address */
-  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
-}
-
-/**
-  * @brief  Fills each I2C_InitStruct member with its default value.
-  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
-  * @retval None
-  */
-void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
-{
-/*---------------- Reset I2C init structure parameters values ----------------*/
-  /* initialize the I2C_ClockSpeed member */
-  I2C_InitStruct->I2C_ClockSpeed = 5000;
-  /* Initialize the I2C_Mode member */
-  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
-  /* Initialize the I2C_DutyCycle member */
-  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
-  /* Initialize the I2C_OwnAddress1 member */
-  I2C_InitStruct->I2C_OwnAddress1 = 0;
-  /* Initialize the I2C_Ack member */
-  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
-  /* Initialize the I2C_AcknowledgedAddress member */
-  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
-}
-
-/**
-  * @brief  Enables or disables the specified I2C peripheral.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2Cx peripheral. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C peripheral */
-    I2Cx->CR1 |= CR1_PE_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C peripheral */
-    I2Cx->CR1 &= CR1_PE_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified I2C DMA requests.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C DMA transfer.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C DMA requests */
-    I2Cx->CR2 |= CR2_DMAEN_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C DMA requests */
-    I2Cx->CR2 &= CR2_DMAEN_Reset;
-  }
-}
-
-/**
-  * @brief  Specifies if the next DMA transfer will be the last one.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C DMA last transfer.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Next DMA transfer is the last transfer */
-    I2Cx->CR2 |= CR2_LAST_Set;
-  }
-  else
-  {
-    /* Next DMA transfer is not the last transfer */
-    I2Cx->CR2 &= CR2_LAST_Reset;
-  }
-}
-
-/**
-  * @brief  Generates I2Cx communication START condition.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C START condition generation.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None.
-  */
-void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Generate a START condition */
-    I2Cx->CR1 |= CR1_START_Set;
-  }
-  else
-  {
-    /* Disable the START condition generation */
-    I2Cx->CR1 &= CR1_START_Reset;
-  }
-}
-
-/**
-  * @brief  Generates I2Cx communication STOP condition.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C STOP condition generation.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None.
-  */
-void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Generate a STOP condition */
-    I2Cx->CR1 |= CR1_STOP_Set;
-  }
-  else
-  {
-    /* Disable the STOP condition generation */
-    I2Cx->CR1 &= CR1_STOP_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified I2C acknowledge feature.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C Acknowledgement.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None.
-  */
-void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the acknowledgement */
-    I2Cx->CR1 |= CR1_ACK_Set;
-  }
-  else
-  {
-    /* Disable the acknowledgement */
-    I2Cx->CR1 &= CR1_ACK_Reset;
-  }
-}
-
-/**
-  * @brief  Configures the specified I2C own address2.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  Address: specifies the 7bit I2C own address2.
-  * @retval None.
-  */
-void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
-{
-  uint16_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Get the old register value */
-  tmpreg = I2Cx->OAR2;
-
-  /* Reset I2Cx Own address2 bit [7:1] */
-  tmpreg &= OAR2_ADD2_Reset;
-
-  /* Set I2Cx Own address2 */
-  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
-
-  /* Store the new register value */
-  I2Cx->OAR2 = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the specified I2C dual addressing mode.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C dual addressing mode.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable dual addressing mode */
-    I2Cx->OAR2 |= OAR2_ENDUAL_Set;
-  }
-  else
-  {
-    /* Disable dual addressing mode */
-    I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified I2C general call feature.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C General call.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable generall call */
-    I2Cx->CR1 |= CR1_ENGC_Set;
-  }
-  else
-  {
-    /* Disable generall call */
-    I2Cx->CR1 &= CR1_ENGC_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified I2C interrupts.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
-  *   This parameter can be any combination of the following values:
-  *     @arg I2C_IT_BUF: Buffer interrupt mask
-  *     @arg I2C_IT_EVT: Event interrupt mask
-  *     @arg I2C_IT_ERR: Error interrupt mask
-  * @param  NewState: new state of the specified I2C interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C interrupts */
-    I2Cx->CR2 |= I2C_IT;
-  }
-  else
-  {
-    /* Disable the selected I2C interrupts */
-    I2Cx->CR2 &= (uint16_t)~I2C_IT;
-  }
-}
-
-/**
-  * @brief  Sends a data byte through the I2Cx peripheral.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  Data: Byte to be transmitted..
-  * @retval None
-  */
-void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  /* Write in the DR register the data to be sent */
-  I2Cx->DR = Data;
-}
-
-/**
-  * @brief  Returns the most recent received data by the I2Cx peripheral.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @retval The value of the received data.
-  */
-uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  /* Return the data in the DR register */
-  return (uint8_t)I2Cx->DR;
-}
-
-/**
-  * @brief  Transmits the address byte to select the slave device.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  Address: specifies the slave address which will be transmitted
-  * @param  I2C_Direction: specifies whether the I2C device will be a
-  *   Transmitter or a Receiver. This parameter can be one of the following values
-  *     @arg I2C_Direction_Transmitter: Transmitter mode
-  *     @arg I2C_Direction_Receiver: Receiver mode
-  * @retval None.
-  */
-void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_DIRECTION(I2C_Direction));
-  /* Test on the direction to set/reset the read/write bit */
-  if (I2C_Direction != I2C_Direction_Transmitter)
-  {
-    /* Set the address bit0 for read */
-    Address |= OAR1_ADD0_Set;
-  }
-  else
-  {
-    /* Reset the address bit0 for write */
-    Address &= OAR1_ADD0_Reset;
-  }
-  /* Send the address */
-  I2Cx->DR = Address;
-}
-
-/**
-  * @brief  Reads the specified I2C register and returns its value.
-  * @param  I2C_Register: specifies the register to read.
-  *   This parameter can be one of the following values:
-  *     @arg I2C_Register_CR1:  CR1 register.
-  *     @arg I2C_Register_CR2:   CR2 register.
-  *     @arg I2C_Register_OAR1:  OAR1 register.
-  *     @arg I2C_Register_OAR2:  OAR2 register.
-  *     @arg I2C_Register_DR:    DR register.
-  *     @arg I2C_Register_SR1:   SR1 register.
-  *     @arg I2C_Register_SR2:   SR2 register.
-  *     @arg I2C_Register_CCR:   CCR register.
-  *     @arg I2C_Register_TRISE: TRISE register.
-  * @retval The value of the read register.
-  */
-uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
-{
-  __IO uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_REGISTER(I2C_Register));
-
-  tmp = (uint32_t) I2Cx;
-  tmp += I2C_Register;
-
-  /* Return the selected register value */
-  return (*(__IO uint16_t *) tmp);
-}
-
-/**
-  * @brief  Enables or disables the specified I2C software reset.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C software reset.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Peripheral under reset */
-    I2Cx->CR1 |= CR1_SWRST_Set;
-  }
-  else
-  {
-    /* Peripheral not under reset */
-    I2Cx->CR1 &= CR1_SWRST_Reset;
-  }
-}
-
-/**
-  * @brief  Selects the specified I2C NACK position in master receiver mode.
-  *         This function is useful in I2C Master Receiver mode when the number
-  *         of data to be received is equal to 2. In this case, this function 
-  *         should be called (with parameter I2C_NACKPosition_Next) before data 
-  *         reception starts,as described in the 2-byte reception procedure 
-  *         recommended in Reference Manual in Section: Master receiver.                
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_NACKPosition: specifies the NACK position. 
-  *   This parameter can be one of the following values:
-  *     @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
-  *          received byte.  
-  *     @arg I2C_NACKPosition_Current: indicates that current byte is the last 
-  *          received byte.
-  *            
-  * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
-  *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
-  *          is intended to used in SMBUS mode. 
-  *            
-  * @retval None
-  */
-void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
-  
-  /* Check the input parameter */
-  if (I2C_NACKPosition == I2C_NACKPosition_Next)
-  {
-    /* Next byte in shift register is the last received byte */
-    I2Cx->CR1 |= I2C_NACKPosition_Next;
-  }
-  else
-  {
-    /* Current byte in shift register is the last received byte */
-    I2Cx->CR1 &= I2C_NACKPosition_Current;
-  }
-}
-
-/**
-  * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
-  *   This parameter can be one of the following values:
-  *     @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
-  *     @arg I2C_SMBusAlert_High: SMBAlert pin driven high
-  * @retval None
-  */
-void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
-  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
-  {
-    /* Drive the SMBusAlert pin Low */
-    I2Cx->CR1 |= I2C_SMBusAlert_Low;
-  }
-  else
-  {
-    /* Drive the SMBusAlert pin High  */
-    I2Cx->CR1 &= I2C_SMBusAlert_High;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified I2C PEC transfer.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2C PEC transmission.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C PEC transmission */
-    I2Cx->CR1 |= CR1_PEC_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C PEC transmission */
-    I2Cx->CR1 &= CR1_PEC_Reset;
-  }
-}
-
-/**
-  * @brief  Selects the specified I2C PEC position.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_PECPosition: specifies the PEC position. 
-  *   This parameter can be one of the following values:
-  *     @arg I2C_PECPosition_Next: indicates that the next byte is PEC
-  *     @arg I2C_PECPosition_Current: indicates that current byte is PEC
-  *       
-  * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
-  *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
-  *          is intended to used in I2C mode.
-  *               
-  * @retval None
-  */
-void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
-  if (I2C_PECPosition == I2C_PECPosition_Next)
-  {
-    /* Next byte in shift register is PEC */
-    I2Cx->CR1 |= I2C_PECPosition_Next;
-  }
-  else
-  {
-    /* Current byte in shift register is PEC */
-    I2Cx->CR1 &= I2C_PECPosition_Current;
-  }
-}
-
-/**
-  * @brief  Enables or disables the PEC value calculation of the transferred bytes.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2Cx PEC value calculation.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C PEC calculation */
-    I2Cx->CR1 |= CR1_ENPEC_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C PEC calculation */
-    I2Cx->CR1 &= CR1_ENPEC_Reset;
-  }
-}
-
-/**
-  * @brief  Returns the PEC value for the specified I2C.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @retval The PEC value.
-  */
-uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  /* Return the selected I2C PEC value */
-  return ((I2Cx->SR2) >> 8);
-}
-
-/**
-  * @brief  Enables or disables the specified I2C ARP.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2Cx ARP. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected I2C ARP */
-    I2Cx->CR1 |= CR1_ENARP_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C ARP */
-    I2Cx->CR1 &= CR1_ENARP_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified I2C Clock stretching.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  NewState: new state of the I2Cx Clock stretching.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState == DISABLE)
-  {
-    /* Enable the selected I2C Clock stretching */
-    I2Cx->CR1 |= CR1_NOSTRETCH_Set;
-  }
-  else
-  {
-    /* Disable the selected I2C Clock stretching */
-    I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
-  }
-}
-
-/**
-  * @brief  Selects the specified I2C fast mode duty cycle.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
-  *   This parameter can be one of the following values:
-  *     @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
-  *     @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
-  * @retval None
-  */
-void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
-{
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
-  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
-  {
-    /* I2C fast mode Tlow/Thigh=2 */
-    I2Cx->CCR &= I2C_DutyCycle_2;
-  }
-  else
-  {
-    /* I2C fast mode Tlow/Thigh=16/9 */
-    I2Cx->CCR |= I2C_DutyCycle_16_9;
-  }
-}
-
-
-
-/**
- * @brief
- ****************************************************************************************
- *
- *                         I2C State Monitoring Functions
- *                       
- ****************************************************************************************   
- * This I2C driver provides three different ways for I2C state monitoring
- *  depending on the application requirements and constraints:
- *        
- *  
- * 1) Basic state monitoring:
- *    Using I2C_CheckEvent() function:
- *    It compares the status registers (SR1 and SR2) content to a given event
- *    (can be the combination of one or more flags).
- *    It returns SUCCESS if the current status includes the given flags 
- *    and returns ERROR if one or more flags are missing in the current status.
- *    - When to use:
- *      - This function is suitable for most applications as well as for startup 
- *      activity since the events are fully described in the product reference manual 
- *      (RM0008).
- *      - It is also suitable for users who need to define their own events.
- *    - Limitations:
- *      - If an error occurs (ie. error flags are set besides to the monitored flags),
- *        the I2C_CheckEvent() function may return SUCCESS despite the communication
- *        hold or corrupted real state. 
- *        In this case, it is advised to use error interrupts to monitor the error
- *        events and handle them in the interrupt IRQ handler.
- *        
- *        @note 
- *        For error management, it is advised to use the following functions:
- *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
- *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
- *            Where x is the peripheral instance (I2C1, I2C2 ...)
- *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler() 
- *            in order to determine which error occured.
- *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
- *            and/or I2C_GenerateStop() in order to clear the error flag and source,
- *            and return to correct communication status.
- *            
- *
- *  2) Advanced state monitoring:
- *     Using the function I2C_GetLastEvent() which returns the image of both status 
- *     registers in a single word (uint32_t) (Status Register 2 value is shifted left 
- *     by 16 bits and concatenated to Status Register 1).
- *     - When to use:
- *       - This function is suitable for the same applications above but it allows to
- *         overcome the mentioned limitation of I2C_GetFlagStatus() function.
- *         The returned value could be compared to events already defined in the 
- *         library (stm32f10x_i2c.h) or to custom values defined by user.
- *       - This function is suitable when multiple flags are monitored at the same time.
- *       - At the opposite of I2C_CheckEvent() function, this function allows user to
- *         choose when an event is accepted (when all events flags are set and no 
- *         other flags are set or just when the needed flags are set like 
- *         I2C_CheckEvent() function).
- *     - Limitations:
- *       - User may need to define his own events.
- *       - Same remark concerning the error management is applicable for this 
- *         function if user decides to check only regular communication flags (and 
- *         ignores error flags).
- *     
- *
- *  3) Flag-based state monitoring:
- *     Using the function I2C_GetFlagStatus() which simply returns the status of 
- *     one single flag (ie. I2C_FLAG_RXNE ...). 
- *     - When to use:
- *        - This function could be used for specific applications or in debug phase.
- *        - It is suitable when only one flag checking is needed (most I2C events 
- *          are monitored through multiple flags).
- *     - Limitations: 
- *        - When calling this function, the Status register is accessed. Some flags are
- *          cleared when the status register is accessed. So checking the status
- *          of one Flag, may clear other ones.
- *        - Function may need to be called twice or more in order to monitor one 
- *          single event.
- *
- *  For detailed description of Events, please refer to section I2C_Events in 
- *  stm32f10x_i2c.h file.
- *  
- */
-
-/**
- * 
- *  1) Basic state monitoring
- *******************************************************************************
- */
-
-/**
-  * @brief  Checks whether the last I2Cx Event is equal to the one passed
-  *   as parameter.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_EVENT: specifies the event to be checked. 
-  *   This parameter can be one of the following values:
-  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
-  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
-  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1
-  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1
-  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
-  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
-  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2
-  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
-  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
-  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3
-  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
-  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
-  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
-  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
-  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     
-  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
-  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
-  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
-  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
-  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
-  *     
-  * @note: For detailed description of Events, please refer to section 
-  *    I2C_Events in stm32f10x_i2c.h file.
-  *    
-  * @retval An ErrorStatus enumeration value:
-  * - SUCCESS: Last event is equal to the I2C_EVENT
-  * - ERROR: Last event is different from the I2C_EVENT
-  */
-ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
-{
-  uint32_t lastevent = 0;
-  uint32_t flag1 = 0, flag2 = 0;
-  ErrorStatus status = ERROR_STATUS;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_EVENT(I2C_EVENT));
-
-  /* Read the I2Cx status register */
-  flag1 = I2Cx->SR1;
-  flag2 = I2Cx->SR2;
-  flag2 = flag2 << 16;
-
-  /* Get the last event value from I2C status register */
-  lastevent = (flag1 | flag2) & FLAG_Mask;
-
-  /* Check whether the last event contains the I2C_EVENT */
-  if ((lastevent & I2C_EVENT) == I2C_EVENT)
-  {
-    /* SUCCESS: last event is equal to I2C_EVENT */
-    status = SUCCESS_STATUS;
-  }
-  else
-  {
-    /* ERROR: last event is different from I2C_EVENT */
-    status = ERROR_STATUS;
-  }
-  /* Return status */
-  return status;
-}
-
-/**
- * 
- *  2) Advanced state monitoring
- *******************************************************************************
- */
-
-/**
-  * @brief  Returns the last I2Cx Event.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  *     
-  * @note: For detailed description of Events, please refer to section 
-  *    I2C_Events in stm32f10x_i2c.h file.
-  *    
-  * @retval The last event
-  */
-uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
-{
-  uint32_t lastevent = 0;
-  uint32_t flag1 = 0, flag2 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-
-  /* Read the I2Cx status register */
-  flag1 = I2Cx->SR1;
-  flag2 = I2Cx->SR2;
-  flag2 = flag2 << 16;
-
-  /* Get the last event value from I2C status register */
-  lastevent = (flag1 | flag2) & FLAG_Mask;
-
-  /* Return status */
-  return lastevent;
-}
-
-/**
- * 
- *  3) Flag-based state monitoring
- *******************************************************************************
- */
-
-/**
-  * @brief  Checks whether the specified I2C flag is set or not.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_FLAG: specifies the flag to check. 
-  *   This parameter can be one of the following values:
-  *     @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
-  *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
-  *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
-  *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
-  *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag
-  *     @arg I2C_FLAG_BUSY: Bus busy flag
-  *     @arg I2C_FLAG_MSL: Master/Slave flag
-  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
-  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
-  *     @arg I2C_FLAG_PECERR: PEC error in reception flag
-  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
-  *     @arg I2C_FLAG_AF: Acknowledge failure flag
-  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
-  *     @arg I2C_FLAG_BERR: Bus error flag
-  *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
-  *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
-  *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
-  *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
-  *     @arg I2C_FLAG_BTF: Byte transfer finished flag
-  *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
-  *   Address matched flag (Slave mode)"ENDA"
-  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
-  * @retval The new state of I2C_FLAG (SET or RESET).
-  */
-FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  __IO uint32_t i2creg = 0, i2cxbase = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
-
-  /* Get the I2Cx peripheral base address */
-  i2cxbase = (uint32_t)I2Cx;
-  
-  /* Read flag register index */
-  i2creg = I2C_FLAG >> 28;
-  
-  /* Get bit[23:0] of the flag */
-  I2C_FLAG &= FLAG_Mask;
-  
-  if(i2creg != 0)
-  {
-    /* Get the I2Cx SR1 register address */
-    i2cxbase += 0x14;
-  }
-  else
-  {
-    /* Flag in I2Cx SR2 Register */
-    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
-    /* Get the I2Cx SR2 register address */
-    i2cxbase += 0x18;
-  }
-  
-  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
-  {
-    /* I2C_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* I2C_FLAG is reset */
-    bitstatus = RESET;
-  }
-  
-  /* Return the I2C_FLAG status */
-  return  bitstatus;
-}
-
-
-
-/**
-  * @brief  Clears the I2Cx's pending flags.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_FLAG: specifies the flag to clear. 
-  *   This parameter can be any combination of the following values:
-  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
-  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
-  *     @arg I2C_FLAG_PECERR: PEC error in reception flag
-  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
-  *     @arg I2C_FLAG_AF: Acknowledge failure flag
-  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
-  *     @arg I2C_FLAG_BERR: Bus error flag
-  *   
-  * @note
-  *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
-  *     to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
-  *     to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
-  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
-  *     operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
-  *     second byte of the address in DR register.
-  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
-  *     operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
-  *     read/write to I2C_DR register (I2C_SendData()).
-  *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
-  *     I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
-  *     I2C_SR2 register ((void)(I2Cx->SR2)).
-  *   - SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
-  *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
-  *     register  (I2C_SendData()).
-  * @retval None
-  */
-void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
-{
-  uint32_t flagpos = 0;
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
-  /* Get the I2C flag position */
-  flagpos = I2C_FLAG & FLAG_Mask;
-  /* Clear the selected I2C flag */
-  I2Cx->SR1 = (uint16_t)~flagpos;
-}
-
-/**
-  * @brief  Checks whether the specified I2C interrupt has occurred or not.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_IT: specifies the interrupt source to check. 
-  *   This parameter can be one of the following values:
-  *     @arg I2C_IT_SMBALERT: SMBus Alert flag
-  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
-  *     @arg I2C_IT_PECERR: PEC error in reception flag
-  *     @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
-  *     @arg I2C_IT_AF: Acknowledge failure flag
-  *     @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
-  *     @arg I2C_IT_BERR: Bus error flag
-  *     @arg I2C_IT_TXE: Data register empty flag (Transmitter)
-  *     @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
-  *     @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
-  *     @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
-  *     @arg I2C_IT_BTF: Byte transfer finished flag
-  *     @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
-  *                       Address matched flag (Slave mode)"ENDAD"
-  *     @arg I2C_IT_SB: Start bit flag (Master mode)
-  * @retval The new state of I2C_IT (SET or RESET).
-  */
-ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint32_t enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_GET_IT(I2C_IT));
-
-  /* Check if the interrupt source is enabled or not */
-  enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
-  
-  /* Get bit[23:0] of the flag */
-  I2C_IT &= FLAG_Mask;
-
-  /* Check the status of the specified I2C flag */
-  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
-  {
-    /* I2C_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* I2C_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the I2C_IT status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the I2Cxs interrupt pending bits.
-  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
-  * @param  I2C_IT: specifies the interrupt pending bit to clear. 
-  *   This parameter can be any combination of the following values:
-  *     @arg I2C_IT_SMBALERT: SMBus Alert interrupt
-  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
-  *     @arg I2C_IT_PECERR: PEC error in reception  interrupt
-  *     @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
-  *     @arg I2C_IT_AF: Acknowledge failure interrupt
-  *     @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
-  *     @arg I2C_IT_BERR: Bus error interrupt
-  *   
-  * @note
-  *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
-  *     to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
-  *     I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
-  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
-  *     operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
-  *     byte of the address in I2C_DR register.
-  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
-  *     operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
-  *     read/write to I2C_DR register (I2C_SendData()).
-  *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
-  *     I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
-  *     I2C_SR2 register ((void)(I2Cx->SR2)).
-  *   - SB (Start Bit) is cleared by software sequence: a read operation to 
-  *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
-  *     I2C_DR register (I2C_SendData()).
-  * @retval None
-  */
-void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
-{
-  uint32_t flagpos = 0;
-  /* Check the parameters */
-  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
-  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
-  /* Get the I2C flag position */
-  flagpos = I2C_IT & FLAG_Mask;
-  /* Clear the selected I2C flag */
-  I2Cx->SR1 = (uint16_t)~flagpos;
-}
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_i2c.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_i2c.h
deleted file mode 100644
index 60e4b14f4..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_i2c.h
+++ /dev/null
@@ -1,684 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_i2c.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the I2C firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_I2C_H
-#define __STM32F10x_I2C_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup I2C
-  * @{
-  */
-
-/** @defgroup I2C_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  I2C Init structure definition  
-  */
-
-typedef struct
-{
-  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
-                                         This parameter must be set to a value lower than 400kHz */
-
-  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
-                                         This parameter can be a value of @ref I2C_mode */
-
-  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
-                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
-
-  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
-                                         This parameter can be a 7-bit or 10-bit address. */
-
-  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
-                                         This parameter can be a value of @ref I2C_acknowledgement */
-
-  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
-                                         This parameter can be a value of @ref I2C_acknowledged_address */
-}I2C_InitTypeDef;
-
-/**
-  * @}
-  */ 
-
-
-/** @defgroup I2C_Exported_Constants
-  * @{
-  */
-
-#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
-                                   ((PERIPH) == I2C2))
-/** @defgroup I2C_mode 
-  * @{
-  */
-
-#define I2C_Mode_I2C                    ((uint16_t)0x0000)
-#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
-#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
-#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
-                           ((MODE) == I2C_Mode_SMBusDevice) || \
-                           ((MODE) == I2C_Mode_SMBusHost))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_duty_cycle_in_fast_mode 
-  * @{
-  */
-
-#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
-#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
-#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
-                                  ((CYCLE) == I2C_DutyCycle_2))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2C_acknowledgement
-  * @{
-  */
-
-#define I2C_Ack_Enable                  ((uint16_t)0x0400)
-#define I2C_Ack_Disable                 ((uint16_t)0x0000)
-#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
-                                 ((STATE) == I2C_Ack_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_transfer_direction 
-  * @{
-  */
-
-#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
-#define  I2C_Direction_Receiver         ((uint8_t)0x01)
-#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
-                                     ((DIRECTION) == I2C_Direction_Receiver))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_acknowledged_address 
-  * @{
-  */
-
-#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
-#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
-#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
-                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2C_registers 
-  * @{
-  */
-
-#define I2C_Register_CR1                ((uint8_t)0x00)
-#define I2C_Register_CR2                ((uint8_t)0x04)
-#define I2C_Register_OAR1               ((uint8_t)0x08)
-#define I2C_Register_OAR2               ((uint8_t)0x0C)
-#define I2C_Register_DR                 ((uint8_t)0x10)
-#define I2C_Register_SR1                ((uint8_t)0x14)
-#define I2C_Register_SR2                ((uint8_t)0x18)
-#define I2C_Register_CCR                ((uint8_t)0x1C)
-#define I2C_Register_TRISE              ((uint8_t)0x20)
-#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
-                                   ((REGISTER) == I2C_Register_CR2) || \
-                                   ((REGISTER) == I2C_Register_OAR1) || \
-                                   ((REGISTER) == I2C_Register_OAR2) || \
-                                   ((REGISTER) == I2C_Register_DR) || \
-                                   ((REGISTER) == I2C_Register_SR1) || \
-                                   ((REGISTER) == I2C_Register_SR2) || \
-                                   ((REGISTER) == I2C_Register_CCR) || \
-                                   ((REGISTER) == I2C_Register_TRISE))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_SMBus_alert_pin_level 
-  * @{
-  */
-
-#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
-#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
-#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
-                                   ((ALERT) == I2C_SMBusAlert_High))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_PEC_position 
-  * @{
-  */
-
-#define I2C_PECPosition_Next            ((uint16_t)0x0800)
-#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
-#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
-                                       ((POSITION) == I2C_PECPosition_Current))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2C_NCAK_position 
-  * @{
-  */
-
-#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
-#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
-#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
-                                         ((POSITION) == I2C_NACKPosition_Current))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2C_interrupts_definition 
-  * @{
-  */
-
-#define I2C_IT_BUF                      ((uint16_t)0x0400)
-#define I2C_IT_EVT                      ((uint16_t)0x0200)
-#define I2C_IT_ERR                      ((uint16_t)0x0100)
-#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2C_interrupts_definition 
-  * @{
-  */
-
-#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
-#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
-#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
-#define I2C_IT_OVR                      ((uint32_t)0x01000800)
-#define I2C_IT_AF                       ((uint32_t)0x01000400)
-#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
-#define I2C_IT_BERR                     ((uint32_t)0x01000100)
-#define I2C_IT_TXE                      ((uint32_t)0x06000080)
-#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
-#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
-#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
-#define I2C_IT_BTF                      ((uint32_t)0x02000004)
-#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
-#define I2C_IT_SB                       ((uint32_t)0x02000001)
-
-#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))
-
-#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
-                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
-                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
-                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
-                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
-                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
-                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_flags_definition 
-  * @{
-  */
-
-/** 
-  * @brief  SR2 register flags  
-  */
-
-#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
-#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
-#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
-#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
-#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
-#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
-#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
-
-/** 
-  * @brief  SR1 register flags  
-  */
-
-#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
-#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
-#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
-#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
-#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
-#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
-#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
-#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
-#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
-#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
-#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
-#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
-#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
-#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
-
-#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))
-
-#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
-                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
-                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
-                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
-                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
-                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
-                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
-                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
-                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
-                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
-                               ((FLAG) == I2C_FLAG_SB))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Events 
-  * @{
-  */
-
-/*========================================
-     
-                     I2C Master Events (Events grouped in order of communication)
-                                                        ==========================================*/
-/** 
-  * @brief  Communication start
-  * 
-  * After sending the START condition (I2C_GenerateSTART() function) the master 
-  * has to wait for this event. It means that the Start condition has been correctly 
-  * released on the I2C bus (the bus is free, no other devices is communicating).
-  * 
-  */
-/* --EV5 */
-#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
-
-/** 
-  * @brief  Address Acknowledge
-  * 
-  * After checking on EV5 (start condition correctly released on the bus), the 
-  * master sends the address of the slave(s) with which it will communicate 
-  * (I2C_Send7bitAddress() function, it also determines the direction of the communication: 
-  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges 
-  * his address. If an acknowledge is sent on the bus, one of the following events will 
-  * be set:
-  * 
-  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
-  *     event is set.
-  *  
-  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED 
-  *     is set
-  *  
-  *  3) In case of 10-Bit addressing mode, the master (just after generating the START 
-  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() 
-  *  function). Then master should wait on EV9. It means that the 10-bit addressing 
-  *  header has been correctly sent on the bus. Then master should send the second part of 
-  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master 
-  *  should wait for event EV6. 
-  *     
-  */
-
-/* --EV6 */
-#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
-#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
-/* --EV9 */
-#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
-
-/** 
-  * @brief Communication events
-  * 
-  * If a communication is established (START condition generated and slave address 
-  * acknowledged) then the master has to check on one of the following events for 
-  * communication procedures:
-  *  
-  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
-  *    the data received from the slave (I2C_ReceiveData() function).
-  * 
-  * 2) Master Transmitter mode: The master has to send data (I2C_SendData() 
-  *    function) then to wait on event EV8 or EV8_2.
-  *    These two events are similar: 
-  *     - EV8 means that the data has been written in the data register and is 
-  *       being shifted out.
-  *     - EV8_2 means that the data has been physically shifted out and output 
-  *       on the bus.
-  *     In most cases, using EV8 is sufficient for the application.
-  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
-  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission 
-  *     (before Stop condition generation).
-  *     
-  *  @note In case the  user software does not guarantee that this event EV7 is 
-  *  managed before the current byte end of transfer, then user may check on EV7 
-  *  and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
-  *  In this case the communication may be slower.
-  * 
-  */
-
-/* Master RECEIVER mode -----------------------------*/ 
-/* --EV7 */
-#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
-
-/* Master TRANSMITTER mode --------------------------*/
-/* --EV8 */
-#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
-/* --EV8_2 */
-#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
-
-
-/*========================================
-     
-                     I2C Slave Events (Events grouped in order of communication)
-                                                        ==========================================*/
-
-/** 
-  * @brief  Communication start events
-  * 
-  * Wait on one of these events at the start of the communication. It means that 
-  * the I2C peripheral detected a Start condition on the bus (generated by master 
-  * device) followed by the peripheral address. The peripheral generates an ACK 
-  * condition on the bus (if the acknowledge feature is enabled through function 
-  * I2C_AcknowledgeConfig()) and the events listed above are set :
-  *  
-  * 1) In normal case (only one address managed by the slave), when the address 
-  *   sent by the master matches the own address of the peripheral (configured by 
-  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set 
-  *   (where XXX could be TRANSMITTER or RECEIVER).
-  *    
-  * 2) In case the address sent by the master matches the second address of the 
-  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled 
-  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED 
-  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
-  *   
-  * 3) In case the address sent by the master is General Call (address 0x00) and 
-  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
-  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.   
-  * 
-  */
-
-/* --EV1  (all the events below are variants of EV1) */   
-/* 1) Case of One Single Address managed by the slave */
-#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
-#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
-
-/* 2) Case of Dual address managed by the slave */
-#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
-#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
-
-/* 3) Case of General Call enabled for the slave */
-#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
-
-/** 
-  * @brief  Communication events
-  * 
-  * Wait on one of these events when EV1 has already been checked and: 
-  * 
-  * - Slave RECEIVER mode:
-  *     - EV2: When the application is expecting a data byte to be received. 
-  *     - EV4: When the application is expecting the end of the communication: master 
-  *       sends a stop condition and data transmission is stopped.
-  *    
-  * - Slave Transmitter mode:
-  *    - EV3: When a byte has been transmitted by the slave and the application is expecting 
-  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
-  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be 
-  *      used when the user software doesn't guarantee the EV3 is managed before the
-  *      current byte end of transfer.
-  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission 
-  *      shall end (before sending the STOP condition). In this case slave has to stop sending 
-  *      data bytes and expect a Stop condition on the bus.
-  *      
-  *  @note In case the  user software does not guarantee that the event EV2 is 
-  *  managed before the current byte end of transfer, then user may check on EV2 
-  *  and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
-  * In this case the communication may be slower.
-  *
-  */
-
-/* Slave RECEIVER mode --------------------------*/ 
-/* --EV2 */
-#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
-/* --EV4  */
-#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
-
-/* Slave TRANSMITTER mode -----------------------*/
-/* --EV3 */
-#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
-#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
-/* --EV3_2 */
-#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
-
-/*===========================      End of Events Description           ==========================================*/
-
-#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
-                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
-                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
-                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
-                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
-                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
-                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
-                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
-                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
-                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
-                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
-                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
-                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
-/**
-  * @}
-  */
-
-/** @defgroup I2C_own_address1 
-  * @{
-  */
-
-#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
-/**
-  * @}
-  */
-
-/** @defgroup I2C_clock_speed 
-  * @{
-  */
-
-#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup I2C_Exported_Functions
-  * @{
-  */
-
-void I2C_DeInit(I2C_TypeDef* I2Cx);
-void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
-void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
-void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
-void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
-void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
-uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
-void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
-uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
-void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
-void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
-void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
-void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
-uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
-void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
-void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
-
-/**
- * @brief
- ****************************************************************************************
- *
- *                         I2C State Monitoring Functions
- *                       
- ****************************************************************************************   
- * This I2C driver provides three different ways for I2C state monitoring
- *  depending on the application requirements and constraints:
- *        
- *  
- * 1) Basic state monitoring:
- *    Using I2C_CheckEvent() function:
- *    It compares the status registers (SR1 and SR2) content to a given event
- *    (can be the combination of one or more flags).
- *    It returns SUCCESS if the current status includes the given flags 
- *    and returns ERROR if one or more flags are missing in the current status.
- *    - When to use:
- *      - This function is suitable for most applications as well as for startup 
- *      activity since the events are fully described in the product reference manual 
- *      (RM0008).
- *      - It is also suitable for users who need to define their own events.
- *    - Limitations:
- *      - If an error occurs (ie. error flags are set besides to the monitored flags),
- *        the I2C_CheckEvent() function may return SUCCESS despite the communication
- *        hold or corrupted real state. 
- *        In this case, it is advised to use error interrupts to monitor the error
- *        events and handle them in the interrupt IRQ handler.
- *        
- *        @note 
- *        For error management, it is advised to use the following functions:
- *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
- *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
- *            Where x is the peripheral instance (I2C1, I2C2 ...)
- *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()
- *            in order to determine which error occurred.
- *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
- *            and/or I2C_GenerateStop() in order to clear the error flag and source,
- *            and return to correct communication status.
- *            
- *
- *  2) Advanced state monitoring:
- *     Using the function I2C_GetLastEvent() which returns the image of both status 
- *     registers in a single word (uint32_t) (Status Register 2 value is shifted left 
- *     by 16 bits and concatenated to Status Register 1).
- *     - When to use:
- *       - This function is suitable for the same applications above but it allows to
- *         overcome the limitations of I2C_GetFlagStatus() function (see below).
- *         The returned value could be compared to events already defined in the 
- *         library (stm32f10x_i2c.h) or to custom values defined by user.
- *       - This function is suitable when multiple flags are monitored at the same time.
- *       - At the opposite of I2C_CheckEvent() function, this function allows user to
- *         choose when an event is accepted (when all events flags are set and no 
- *         other flags are set or just when the needed flags are set like 
- *         I2C_CheckEvent() function).
- *     - Limitations:
- *       - User may need to define his own events.
- *       - Same remark concerning the error management is applicable for this 
- *         function if user decides to check only regular communication flags (and 
- *         ignores error flags).
- *     
- *
- *  3) Flag-based state monitoring:
- *     Using the function I2C_GetFlagStatus() which simply returns the status of 
- *     one single flag (ie. I2C_FLAG_RXNE ...). 
- *     - When to use:
- *        - This function could be used for specific applications or in debug phase.
- *        - It is suitable when only one flag checking is needed (most I2C events 
- *          are monitored through multiple flags).
- *     - Limitations: 
- *        - When calling this function, the Status register is accessed. Some flags are
- *          cleared when the status register is accessed. So checking the status
- *          of one Flag, may clear other ones.
- *        - Function may need to be called twice or more in order to monitor one 
- *          single event.
- *            
- */
-
-/**
- * 
- *  1) Basic state monitoring
- *******************************************************************************
- */
-ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
-/**
- * 
- *  2) Advanced state monitoring
- *******************************************************************************
- */
-uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
-/**
- * 
- *  3) Flag-based state monitoring
- *******************************************************************************
- */
-FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
-/**
- *
- *******************************************************************************
- */
-
-void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
-ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
-void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_I2C_H */
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_iwdg.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_iwdg.c
deleted file mode 100644
index c7cbf7ec5..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_iwdg.c
+++ /dev/null
@@ -1,190 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_iwdg.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the IWDG firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_iwdg.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup IWDG 
-  * @brief IWDG driver modules
-  * @{
-  */ 
-
-/** @defgroup IWDG_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Private_Defines
-  * @{
-  */ 
-
-/* ---------------------- IWDG registers bit mask ----------------------------*/
-
-/* KR register bit mask */
-#define KR_KEY_Reload    ((uint16_t)0xAAAA)
-#define KR_KEY_Enable    ((uint16_t)0xCCCC)
-
-/**
-  * @}
-  */ 
-
-/** @defgroup IWDG_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Enables or disables write access to IWDG_PR and IWDG_RLR registers.
-  * @param  IWDG_WriteAccess: new state of write access to IWDG_PR and IWDG_RLR registers.
-  *   This parameter can be one of the following values:
-  *     @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
-  *     @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
-  * @retval None
-  */
-void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
-  IWDG->KR = IWDG_WriteAccess;
-}
-
-/**
-  * @brief  Sets IWDG Prescaler value.
-  * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.
-  *   This parameter can be one of the following values:
-  *     @arg IWDG_Prescaler_4: IWDG prescaler set to 4
-  *     @arg IWDG_Prescaler_8: IWDG prescaler set to 8
-  *     @arg IWDG_Prescaler_16: IWDG prescaler set to 16
-  *     @arg IWDG_Prescaler_32: IWDG prescaler set to 32
-  *     @arg IWDG_Prescaler_64: IWDG prescaler set to 64
-  *     @arg IWDG_Prescaler_128: IWDG prescaler set to 128
-  *     @arg IWDG_Prescaler_256: IWDG prescaler set to 256
-  * @retval None
-  */
-void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
-  IWDG->PR = IWDG_Prescaler;
-}
-
-/**
-  * @brief  Sets IWDG Reload value.
-  * @param  Reload: specifies the IWDG Reload value.
-  *   This parameter must be a number between 0 and 0x0FFF.
-  * @retval None
-  */
-void IWDG_SetReload(uint16_t Reload)
-{
-  /* Check the parameters */
-  assert_param(IS_IWDG_RELOAD(Reload));
-  IWDG->RLR = Reload;
-}
-
-/**
-  * @brief  Reloads IWDG counter with value defined in the reload register
-  *   (write access to IWDG_PR and IWDG_RLR registers disabled).
-  * @param  None
-  * @retval None
-  */
-void IWDG_ReloadCounter(void)
-{
-  IWDG->KR = KR_KEY_Reload;
-}
-
-/**
-  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
-  * @param  None
-  * @retval None
-  */
-void IWDG_Enable(void)
-{
-  IWDG->KR = KR_KEY_Enable;
-}
-
-/**
-  * @brief  Checks whether the specified IWDG flag is set or not.
-  * @param  IWDG_FLAG: specifies the flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg IWDG_FLAG_PVU: Prescaler Value Update on going
-  *     @arg IWDG_FLAG_RVU: Reload Value Update on going
-  * @retval The new state of IWDG_FLAG (SET or RESET).
-  */
-FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
-  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_iwdg.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_iwdg.h
deleted file mode 100644
index 25b0bb520..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_iwdg.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_iwdg.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the IWDG 
-  *          firmware library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_IWDG_H
-#define __STM32F10x_IWDG_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup IWDG
-  * @{
-  */
-
-/** @defgroup IWDG_Exported_Types
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Exported_Constants
-  * @{
-  */
-
-/** @defgroup IWDG_WriteAccess
-  * @{
-  */
-
-#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
-#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
-#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
-                                      ((ACCESS) == IWDG_WriteAccess_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_prescaler 
-  * @{
-  */
-
-#define IWDG_Prescaler_4            ((uint8_t)0x00)
-#define IWDG_Prescaler_8            ((uint8_t)0x01)
-#define IWDG_Prescaler_16           ((uint8_t)0x02)
-#define IWDG_Prescaler_32           ((uint8_t)0x03)
-#define IWDG_Prescaler_64           ((uint8_t)0x04)
-#define IWDG_Prescaler_128          ((uint8_t)0x05)
-#define IWDG_Prescaler_256          ((uint8_t)0x06)
-#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
-                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
-                                      ((PRESCALER) == IWDG_Prescaler_16) || \
-                                      ((PRESCALER) == IWDG_Prescaler_32) || \
-                                      ((PRESCALER) == IWDG_Prescaler_64) || \
-                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
-                                      ((PRESCALER) == IWDG_Prescaler_256))
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Flag 
-  * @{
-  */
-
-#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
-#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
-#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
-#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup IWDG_Exported_Functions
-  * @{
-  */
-
-void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
-void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
-void IWDG_SetReload(uint16_t Reload);
-void IWDG_ReloadCounter(void);
-void IWDG_Enable(void);
-FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_IWDG_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_pwr.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_pwr.c
deleted file mode 100644
index a5a5c5726..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_pwr.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_pwr.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the PWR firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_pwr.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup PWR 
-  * @brief PWR driver modules
-  * @{
-  */ 
-
-/** @defgroup PWR_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Private_Defines
-  * @{
-  */
-
-/* --------- PWR registers bit address in the alias region ---------- */
-#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-
-/* Alias word address of DBP bit */
-#define CR_OFFSET                (PWR_OFFSET + 0x00)
-#define DBP_BitNumber            0x08
-#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
-
-/* Alias word address of PVDE bit */
-#define PVDE_BitNumber           0x04
-#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
-
-/* --- CSR Register ---*/
-
-/* Alias word address of EWUP bit */
-#define CSR_OFFSET               (PWR_OFFSET + 0x04)
-#define EWUP_BitNumber           0x08
-#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
-
-/* ------------------ PWR registers bit mask ------------------------ */
-
-/* CR register bit mask */
-#define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
-#define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
-
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the PWR peripheral registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void PWR_DeInit(void)
-{
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
-}
-
-/**
-  * @brief  Enables or disables access to the RTC and backup registers.
-  * @param  NewState: new state of the access to the RTC and backup registers.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void PWR_BackupAccessCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enables or disables the Power Voltage Detector(PVD).
-  * @param  NewState: new state of the PVD.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void PWR_PVDCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
-  * @param  PWR_PVDLevel: specifies the PVD detection level
-  *   This parameter can be one of the following values:
-  *     @arg PWR_PVDLevel_2V2: PVD detection level set to 2.2V
-  *     @arg PWR_PVDLevel_2V3: PVD detection level set to 2.3V
-  *     @arg PWR_PVDLevel_2V4: PVD detection level set to 2.4V
-  *     @arg PWR_PVDLevel_2V5: PVD detection level set to 2.5V
-  *     @arg PWR_PVDLevel_2V6: PVD detection level set to 2.6V
-  *     @arg PWR_PVDLevel_2V7: PVD detection level set to 2.7V
-  *     @arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V
-  *     @arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V
-  * @retval None
-  */
-void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
-  tmpreg = PWR->CR;
-  /* Clear PLS[7:5] bits */
-  tmpreg &= CR_PLS_MASK;
-  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
-  tmpreg |= PWR_PVDLevel;
-  /* Store the new value */
-  PWR->CR = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the WakeUp Pin functionality.
-  * @param  NewState: new state of the WakeUp Pin functionality.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void PWR_WakeUpPinCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enters STOP mode.
-  * @param  PWR_Regulator: specifies the regulator state in STOP mode.
-  *   This parameter can be one of the following values:
-  *     @arg PWR_Regulator_ON: STOP mode with regulator ON
-  *     @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
-  * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
-  *   This parameter can be one of the following values:
-  *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
-  *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
-  * @retval None
-  */
-void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
-  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
-  
-  /* Select the regulator state in STOP mode ---------------------------------*/
-  tmpreg = PWR->CR;
-  /* Clear PDDS and LPDS bits */
-  tmpreg &= CR_DS_MASK;
-  /* Set LPDS bit according to PWR_Regulator value */
-  tmpreg |= PWR_Regulator;
-  /* Store the new value */
-  PWR->CR = tmpreg;
-  /* Set SLEEPDEEP bit of Cortex System Control Register */
-  SCB->SCR |= SCB_SCR_SLEEPDEEP;
-  
-  /* Select STOP mode entry --------------------------------------------------*/
-  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
-  {   
-    /* Request Wait For Interrupt */
-    __WFI();
-  }
-  else
-  {
-    /* Request Wait For Event */
-    __WFE();
-  }
-  
-  /* Reset SLEEPDEEP bit of Cortex System Control Register */
-  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);  
-}
-
-/**
-  * @brief  Enters STANDBY mode.
-  * @param  None
-  * @retval None
-  */
-void PWR_EnterSTANDBYMode(void)
-{
-  /* Clear Wake-up flag */
-  PWR->CR |= PWR_CR_CWUF;
-  /* Select STANDBY mode */
-  PWR->CR |= PWR_CR_PDDS;
-  /* Set SLEEPDEEP bit of Cortex System Control Register */
-  SCB->SCR |= SCB_SCR_SLEEPDEEP;
-/* This option is used to ensure that store operations are completed */
-#if defined ( __CC_ARM   )
-  __force_stores();
-#endif
-  /* Request Wait For Interrupt */
-  __WFI();
-}
-
-/**
-  * @brief  Checks whether the specified PWR flag is set or not.
-  * @param  PWR_FLAG: specifies the flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg PWR_FLAG_WU: Wake Up flag
-  *     @arg PWR_FLAG_SB: StandBy flag
-  *     @arg PWR_FLAG_PVDO: PVD Output
-  * @retval The new state of PWR_FLAG (SET or RESET).
-  */
-FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
-  
-  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the PWR's pending flags.
-  * @param  PWR_FLAG: specifies the flag to clear.
-  *   This parameter can be one of the following values:
-  *     @arg PWR_FLAG_WU: Wake Up flag
-  *     @arg PWR_FLAG_SB: StandBy flag
-  * @retval None
-  */
-void PWR_ClearFlag(uint32_t PWR_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
-         
-  PWR->CR |=  PWR_FLAG << 2;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_pwr.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_pwr.h
deleted file mode 100644
index 1c025e2ff..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_pwr.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_pwr.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the PWR firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_PWR_H
-#define __STM32F10x_PWR_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup PWR
-  * @{
-  */ 
-
-/** @defgroup PWR_Exported_Types
-  * @{
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup PWR_Exported_Constants
-  * @{
-  */ 
-
-/** @defgroup PVD_detection_level 
-  * @{
-  */ 
-
-#define PWR_PVDLevel_2V2          ((uint32_t)0x00000000)
-#define PWR_PVDLevel_2V3          ((uint32_t)0x00000020)
-#define PWR_PVDLevel_2V4          ((uint32_t)0x00000040)
-#define PWR_PVDLevel_2V5          ((uint32_t)0x00000060)
-#define PWR_PVDLevel_2V6          ((uint32_t)0x00000080)
-#define PWR_PVDLevel_2V7          ((uint32_t)0x000000A0)
-#define PWR_PVDLevel_2V8          ((uint32_t)0x000000C0)
-#define PWR_PVDLevel_2V9          ((uint32_t)0x000000E0)
-#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \
-                                 ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \
-                                 ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \
-                                 ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
-/**
-  * @}
-  */
-
-/** @defgroup Regulator_state_is_STOP_mode 
-  * @{
-  */
-
-#define PWR_Regulator_ON          ((uint32_t)0x00000000)
-#define PWR_Regulator_LowPower    ((uint32_t)0x00000001)
-#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
-                                     ((REGULATOR) == PWR_Regulator_LowPower))
-/**
-  * @}
-  */
-
-/** @defgroup STOP_mode_entry 
-  * @{
-  */
-
-#define PWR_STOPEntry_WFI         ((uint8_t)0x01)
-#define PWR_STOPEntry_WFE         ((uint8_t)0x02)
-#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
- 
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Flag 
-  * @{
-  */
-
-#define PWR_FLAG_WU               ((uint32_t)0x00000001)
-#define PWR_FLAG_SB               ((uint32_t)0x00000002)
-#define PWR_FLAG_PVDO             ((uint32_t)0x00000004)
-#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
-                               ((FLAG) == PWR_FLAG_PVDO))
-
-#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup PWR_Exported_Functions
-  * @{
-  */
-
-void PWR_DeInit(void);
-void PWR_BackupAccessCmd(FunctionalState NewState);
-void PWR_PVDCmd(FunctionalState NewState);
-void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
-void PWR_WakeUpPinCmd(FunctionalState NewState);
-void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
-void PWR_EnterSTANDBYMode(void);
-FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
-void PWR_ClearFlag(uint32_t PWR_FLAG);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_PWR_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rcc.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rcc.c
deleted file mode 100644
index 0a8576c35..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rcc.c
+++ /dev/null
@@ -1,1472 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_rcc.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the RCC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup RCC 
-  * @brief RCC driver modules
-  * @{
-  */ 
-
-/** @defgroup RCC_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Private_Defines
-  * @{
-  */
-
-/* ------------ RCC registers bit address in the alias region ----------- */
-#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
-
-/* --- CR Register ---*/
-
-/* Alias word address of HSION bit */
-#define CR_OFFSET                 (RCC_OFFSET + 0x00)
-#define HSION_BitNumber           0x00
-#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
-
-/* Alias word address of PLLON bit */
-#define PLLON_BitNumber           0x18
-#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
-
-#ifdef STM32F10X_CL
- /* Alias word address of PLL2ON bit */
- #define PLL2ON_BitNumber          0x1A
- #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))
-
- /* Alias word address of PLL3ON bit */
- #define PLL3ON_BitNumber          0x1C
- #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))
-#endif /* STM32F10X_CL */ 
-
-/* Alias word address of CSSON bit */
-#define CSSON_BitNumber           0x13
-#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
-
-/* --- CFGR Register ---*/
-
-/* Alias word address of USBPRE bit */
-#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
-
-#ifndef STM32F10X_CL
- #define USBPRE_BitNumber          0x16
- #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
-#else
- #define OTGFSPRE_BitNumber        0x16
- #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))
-#endif /* STM32F10X_CL */ 
-
-/* --- BDCR Register ---*/
-
-/* Alias word address of RTCEN bit */
-#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
-#define RTCEN_BitNumber           0x0F
-#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
-
-/* Alias word address of BDRST bit */
-#define BDRST_BitNumber           0x10
-#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
-
-/* --- CSR Register ---*/
-
-/* Alias word address of LSION bit */
-#define CSR_OFFSET                (RCC_OFFSET + 0x24)
-#define LSION_BitNumber           0x00
-#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
-
-#ifdef STM32F10X_CL
-/* --- CFGR2 Register ---*/
-
- /* Alias word address of I2S2SRC bit */
- #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)
- #define I2S2SRC_BitNumber         0x11
- #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))
-
- /* Alias word address of I2S3SRC bit */
- #define I2S3SRC_BitNumber         0x12
- #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))
-#endif /* STM32F10X_CL */
-
-/* ---------------------- RCC registers bit mask ------------------------ */
-
-/* CR register bit mask */
-#define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)
-#define CR_HSEBYP_Set             ((uint32_t)0x00040000)
-#define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)
-#define CR_HSEON_Set              ((uint32_t)0x00010000)
-#define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)
-
-/* CFGR register bit mask */
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL) 
- #define CFGR_PLL_Mask            ((uint32_t)0xFFC2FFFF)
-#else
- #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)
-#endif /* STM32F10X_CL */ 
-
-#define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)
-#define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)
-#define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)
-#define CFGR_SWS_Mask             ((uint32_t)0x0000000C)
-#define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)
-#define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)
-#define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)
-#define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)
-#define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)
-#define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)
-#define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)
-#define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)
-#define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)
-
-/* CSR register bit mask */
-#define CSR_RMVF_Set              ((uint32_t)0x01000000)
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL) 
-/* CFGR2 register bit mask */
- #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)
- #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)
-#endif
-#ifdef STM32F10X_CL
- #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)
- #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)
- #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)
-#endif /* STM32F10X_CL */ 
-
-/* RCC Flag Mask */
-#define FLAG_Mask                 ((uint8_t)0x1F)
-
-/* CIR register byte 2 (Bits[15:8]) base address */
-#define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
-
-/* CIR register byte 3 (Bits[23:16]) base address */
-#define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
-
-/* CFGR register byte 4 (Bits[31:24]) base address */
-#define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)
-
-/* BDCR register base address */
-#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
-
-/**
-  * @}
-  */ 
-
-/** @defgroup RCC_Private_Macros
-  * @{
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup RCC_Private_Variables
-  * @{
-  */ 
-
-//static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
-//static __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
-static const uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
-static const uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Resets the RCC clock configuration to the default reset state.
-  * @param  None
-  * @retval None
-  */
-void RCC_DeInit(void)
-{
-  /* Set HSION bit */
-  RCC->CR |= (uint32_t)0x00000001;
-
-  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
-#ifndef STM32F10X_CL
-  RCC->CFGR &= (uint32_t)0xF8FF0000;
-#else
-  RCC->CFGR &= (uint32_t)0xF0FF0000;
-#endif /* STM32F10X_CL */   
-  
-  /* Reset HSEON, CSSON and PLLON bits */
-  RCC->CR &= (uint32_t)0xFEF6FFFF;
-
-  /* Reset HSEBYP bit */
-  RCC->CR &= (uint32_t)0xFFFBFFFF;
-
-  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
-  RCC->CFGR &= (uint32_t)0xFF80FFFF;
-
-#ifdef STM32F10X_CL
-  /* Reset PLL2ON and PLL3ON bits */
-  RCC->CR &= (uint32_t)0xEBFFFFFF;
-
-  /* Disable all interrupts and clear pending bits  */
-  RCC->CIR = 0x00FF0000;
-
-  /* Reset CFGR2 register */
-  RCC->CFGR2 = 0x00000000;
-#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-  /* Disable all interrupts and clear pending bits  */
-  RCC->CIR = 0x009F0000;
-
-  /* Reset CFGR2 register */
-  RCC->CFGR2 = 0x00000000;      
-#else
-  /* Disable all interrupts and clear pending bits  */
-  RCC->CIR = 0x009F0000;
-#endif /* STM32F10X_CL */
-
-}
-
-/**
-  * @brief  Configures the External High Speed oscillator (HSE).
-  * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.
-  * @param  RCC_HSE: specifies the new state of the HSE.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_HSE_OFF: HSE oscillator OFF
-  *     @arg RCC_HSE_ON: HSE oscillator ON
-  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
-  * @retval None
-  */
-void RCC_HSEConfig(uint32_t RCC_HSE)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_HSE(RCC_HSE));
-  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
-  /* Reset HSEON bit */
-  RCC->CR &= CR_HSEON_Reset;
-  /* Reset HSEBYP bit */
-  RCC->CR &= CR_HSEBYP_Reset;
-  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
-  switch(RCC_HSE)
-  {
-    case RCC_HSE_ON:
-      /* Set HSEON bit */
-      RCC->CR |= CR_HSEON_Set;
-      break;
-      
-    case RCC_HSE_Bypass:
-      /* Set HSEBYP and HSEON bits */
-      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
-      break;
-      
-    default:
-      break;
-  }
-}
-
-/**
-  * @brief  Waits for HSE start-up.
-  * @param  None
-  * @retval An ErrorStatus enumuration value:
-  * - SUCCESS: HSE oscillator is stable and ready to use
-  * - ERROR: HSE oscillator not yet ready
-  */
-ErrorStatus RCC_WaitForHSEStartUp(void)
-{
-  __IO uint32_t StartUpCounter = 0;
-  ErrorStatus status = ERROR_STATUS;
-  FlagStatus HSEStatus = RESET;
-  
-  /* Wait till HSE is ready and if Time out is reached exit */
-  do
-  {
-    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
-    StartUpCounter++;  
-  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
-  
-  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
-  {
-    status = SUCCESS_STATUS;
-  }
-  else
-  {
-    status = ERROR_STATUS;
-  }  
-  return (status);
-}
-
-/**
-  * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
-  * @param  HSICalibrationValue: specifies the calibration trimming value.
-  *   This parameter must be a number between 0 and 0x1F.
-  * @retval None
-  */
-void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
-  tmpreg = RCC->CR;
-  /* Clear HSITRIM[4:0] bits */
-  tmpreg &= CR_HSITRIM_Mask;
-  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
-  tmpreg |= (uint32_t)HSICalibrationValue << 3;
-  /* Store the new value */
-  RCC->CR = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the Internal High Speed oscillator (HSI).
-  * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
-  * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_HSICmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Configures the PLL clock source and multiplication factor.
-  * @note   This function must be used only when the PLL is disabled.
-  * @param  RCC_PLLSource: specifies the PLL entry clock source.
-  *   For @b STM32_Connectivity_line_devices or @b STM32_Value_line_devices, 
-  *   this parameter can be one of the following values:
-  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
-  *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
-  *   For @b other_STM32_devices, this parameter can be one of the following values:
-  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
-  *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry
-  *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry 
-  * @param  RCC_PLLMul: specifies the PLL multiplication factor.
-  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
-  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
-  * @retval None
-  */
-void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
-{
-  uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
-  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
-
-  tmpreg = RCC->CFGR;
-  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
-  tmpreg &= CFGR_PLL_Mask;
-  /* Set the PLL configuration bits */
-  tmpreg |= RCC_PLLSource | RCC_PLLMul;
-  /* Store the new value */
-  RCC->CFGR = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the PLL.
-  * @note   The PLL can not be disabled if it is used as system clock.
-  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_PLLCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
-}
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
-/**
-  * @brief  Configures the PREDIV1 division factor.
-  * @note 
-  *   - This function must be used only when the PLL is disabled.
-  *   - This function applies only to STM32 Connectivity line and Value line 
-  *     devices.
-  * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock
-  *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock
-  * @note 
-  *   For @b STM32_Value_line_devices this parameter is always RCC_PREDIV1_Source_HSE  
-  * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
-  *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
-  * @retval None
-  */
-void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
-{
-  uint32_t tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
-  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
-
-  tmpreg = RCC->CFGR2;
-  /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
-  tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
-  /* Set the PREDIV1 clock source and division factor */
-  tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
-  /* Store the new value */
-  RCC->CFGR2 = tmpreg;
-}
-#endif
-
-#ifdef STM32F10X_CL
-/**
-  * @brief  Configures the PREDIV2 division factor.
-  * @note 
-  *   - This function must be used only when both PLL2 and PLL3 are disabled.
-  *   - This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
-  *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
-  * @retval None
-  */
-void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)
-{
-  uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));
-
-  tmpreg = RCC->CFGR2;
-  /* Clear PREDIV2[3:0] bits */
-  tmpreg &= ~CFGR2_PREDIV2;
-  /* Set the PREDIV2 division factor */
-  tmpreg |= RCC_PREDIV2_Div;
-  /* Store the new value */
-  RCC->CFGR2 = tmpreg;
-}
-
-/**
-  * @brief  Configures the PLL2 multiplication factor.
-  * @note
-  *   - This function must be used only when the PLL2 is disabled.
-  *   - This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
-  *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
-  * @retval None
-  */
-void RCC_PLL2Config(uint32_t RCC_PLL2Mul)
-{
-  uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));
-
-  tmpreg = RCC->CFGR2;
-  /* Clear PLL2Mul[3:0] bits */
-  tmpreg &= ~CFGR2_PLL2MUL;
-  /* Set the PLL2 configuration bits */
-  tmpreg |= RCC_PLL2Mul;
-  /* Store the new value */
-  RCC->CFGR2 = tmpreg;
-}
-
-
-/**
-  * @brief  Enables or disables the PLL2.
-  * @note 
-  *   - The PLL2 can not be disabled if it is used indirectly as system clock
-  *     (i.e. it is used as PLL clock entry that is used as System clock).
-  *   - This function applies only to STM32 Connectivity line devices.
-  * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_PLL2Cmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
-}
-
-
-/**
-  * @brief  Configures the PLL3 multiplication factor.
-  * @note 
-  *   - This function must be used only when the PLL3 is disabled.
-  *   - This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
-  *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
-  * @retval None
-  */
-void RCC_PLL3Config(uint32_t RCC_PLL3Mul)
-{
-  uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));
-
-  tmpreg = RCC->CFGR2;
-  /* Clear PLL3Mul[3:0] bits */
-  tmpreg &= ~CFGR2_PLL3MUL;
-  /* Set the PLL3 configuration bits */
-  tmpreg |= RCC_PLL3Mul;
-  /* Store the new value */
-  RCC->CFGR2 = tmpreg;
-}
-
-
-/**
-  * @brief  Enables or disables the PLL3.
-  * @note   This function applies only to STM32 Connectivity line devices.
-  * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_PLL3Cmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
-}
-#endif /* STM32F10X_CL */
-
-/**
-  * @brief  Configures the system clock (SYSCLK).
-  * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
-  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
-  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
-  * @retval None
-  */
-void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
-  tmpreg = RCC->CFGR;
-  /* Clear SW[1:0] bits */
-  tmpreg &= CFGR_SW_Mask;
-  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
-  tmpreg |= RCC_SYSCLKSource;
-  /* Store the new value */
-  RCC->CFGR = tmpreg;
-}
-
-/**
-  * @brief  Returns the clock source used as system clock.
-  * @param  None
-  * @retval The clock source used as system clock. The returned value can
-  *   be one of the following:
-  *     - 0x00: HSI used as system clock
-  *     - 0x04: HSE used as system clock
-  *     - 0x08: PLL used as system clock
-  */
-uint8_t RCC_GetSYSCLKSource(void)
-{
-  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
-}
-
-/**
-  * @brief  Configures the AHB clock (HCLK).
-  * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
-  *   the system clock (SYSCLK).
-  *   This parameter can be one of the following values:
-  *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
-  *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
-  *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
-  *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
-  *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
-  *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
-  *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
-  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
-  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
-  * @retval None
-  */
-void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
-  tmpreg = RCC->CFGR;
-  /* Clear HPRE[3:0] bits */
-  tmpreg &= CFGR_HPRE_Reset_Mask;
-  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
-  tmpreg |= RCC_SYSCLK;
-  /* Store the new value */
-  RCC->CFGR = tmpreg;
-}
-
-/**
-  * @brief  Configures the Low Speed APB clock (PCLK1).
-  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
-  *   the AHB clock (HCLK).
-  *   This parameter can be one of the following values:
-  *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
-  *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
-  *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
-  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
-  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
-  * @retval None
-  */
-void RCC_PCLK1Config(uint32_t RCC_HCLK)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_RCC_PCLK(RCC_HCLK));
-  tmpreg = RCC->CFGR;
-  /* Clear PPRE1[2:0] bits */
-  tmpreg &= CFGR_PPRE1_Reset_Mask;
-  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
-  tmpreg |= RCC_HCLK;
-  /* Store the new value */
-  RCC->CFGR = tmpreg;
-}
-
-/**
-  * @brief  Configures the High Speed APB clock (PCLK2).
-  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
-  *   the AHB clock (HCLK).
-  *   This parameter can be one of the following values:
-  *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
-  *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
-  *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
-  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
-  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
-  * @retval None
-  */
-void RCC_PCLK2Config(uint32_t RCC_HCLK)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_RCC_PCLK(RCC_HCLK));
-  tmpreg = RCC->CFGR;
-  /* Clear PPRE2[2:0] bits */
-  tmpreg &= CFGR_PPRE2_Reset_Mask;
-  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
-  tmpreg |= RCC_HCLK << 3;
-  /* Store the new value */
-  RCC->CFGR = tmpreg;
-}
-
-/**
-  * @brief  Enables or disables the specified RCC interrupts.
-  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
-  * 
-  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
-  *   of the following values        
-  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
-  *     @arg RCC_IT_LSERDY: LSE ready interrupt
-  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
-  *     @arg RCC_IT_HSERDY: HSE ready interrupt
-  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
-  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
-  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
-  * 
-  *   For @b other_STM32_devices, this parameter can be any combination of the 
-  *   following values        
-  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
-  *     @arg RCC_IT_LSERDY: LSE ready interrupt
-  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
-  *     @arg RCC_IT_HSERDY: HSE ready interrupt
-  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
-  *       
-  * @param  NewState: new state of the specified RCC interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_IT(RCC_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
-    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
-  }
-  else
-  {
-    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
-    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
-  }
-}
-
-#ifndef STM32F10X_CL
-/**
-  * @brief  Configures the USB clock (USBCLK).
-  * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
-  *   derived from the PLL output.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
-  *                                     clock source
-  *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
-  * @retval None
-  */
-void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
-
-  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
-}
-#else
-/**
-  * @brief  Configures the USB OTG FS clock (OTGFSCLK).
-  *   This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.
-  *   This clock is derived from the PLL output.
-  *   This parameter can be one of the following values:
-  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
-  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
-  * @retval None
-  */
-void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));
-
-  *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
-}
-#endif /* STM32F10X_CL */ 
-
-/**
-  * @brief  Configures the ADC clock (ADCCLK).
-  * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
-  *   the APB2 clock (PCLK2).
-  *   This parameter can be one of the following values:
-  *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
-  *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
-  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
-  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
-  * @retval None
-  */
-void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
-  tmpreg = RCC->CFGR;
-  /* Clear ADCPRE[1:0] bits */
-  tmpreg &= CFGR_ADCPRE_Reset_Mask;
-  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
-  tmpreg |= RCC_PCLK2;
-  /* Store the new value */
-  RCC->CFGR = tmpreg;
-}
-
-#ifdef STM32F10X_CL
-/**
-  * @brief  Configures the I2S2 clock source(I2S2CLK).
-  * @note
-  *   - This function must be called before enabling I2S2 APB clock.
-  *   - This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
-  *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
-  * @retval None
-  */
-void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));
-
-  *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
-}
-
-/**
-  * @brief  Configures the I2S3 clock source(I2S2CLK).
-  * @note
-  *   - This function must be called before enabling I2S3 APB clock.
-  *   - This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
-  *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
-  * @retval None
-  */
-void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));
-
-  *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
-}
-#endif /* STM32F10X_CL */
-
-/**
-  * @brief  Configures the External Low Speed oscillator (LSE).
-  * @param  RCC_LSE: specifies the new state of the LSE.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_LSE_OFF: LSE oscillator OFF
-  *     @arg RCC_LSE_ON: LSE oscillator ON
-  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
-  * @retval None
-  */
-void RCC_LSEConfig(uint8_t RCC_LSE)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_LSE(RCC_LSE));
-  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
-  /* Reset LSEON bit */
-  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
-  /* Reset LSEBYP bit */
-  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
-  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
-  switch(RCC_LSE)
-  {
-    case RCC_LSE_ON:
-      /* Set LSEON bit */
-      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
-      break;
-      
-    case RCC_LSE_Bypass:
-      /* Set LSEBYP and LSEON bits */
-      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
-      break;            
-      
-    default:
-      break;      
-  }
-}
-
-/**
-  * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
-  * @note   LSI can not be disabled if the IWDG is running.
-  * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_LSICmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Configures the RTC clock (RTCCLK).
-  * @note   Once the RTC clock is selected it can't be changed unless the Backup domain is reset.
-  * @param  RCC_RTCCLKSource: specifies the RTC clock source.
-  *   This parameter can be one of the following values:
-  *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
-  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
-  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
-  * @retval None
-  */
-void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
-  /* Select the RTC clock source */
-  RCC->BDCR |= RCC_RTCCLKSource;
-}
-
-/**
-  * @brief  Enables or disables the RTC clock.
-  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
-  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_RTCCLKCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Returns the frequencies of different on chip clocks.
-  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
-  *         the clocks frequencies.
-  * @note   The result of this function could be not correct when using 
-  *         fractional value for HSE crystal.  
-  * @retval None
-  */
-void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
-{
-  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
-
-#ifdef  STM32F10X_CL
-  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
-#endif /* STM32F10X_CL */
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-  uint32_t prediv1factor = 0;
-#endif
-    
-  /* Get SYSCLK source -------------------------------------------------------*/
-  tmp = RCC->CFGR & CFGR_SWS_Mask;
-  
-  switch (tmp)
-  {
-    case 0x00:  /* HSI used as system clock */
-      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
-      break;
-    case 0x04:  /* HSE used as system clock */
-      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
-      break;
-    case 0x08:  /* PLL used as system clock */
-
-      /* Get PLL clock source and multiplication factor ----------------------*/
-      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
-      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
-      
-#ifndef STM32F10X_CL      
-      pllmull = ( pllmull >> 18) + 2;
-      
-      if (pllsource == 0x00)
-      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
-        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
-      }
-      else
-      {
- #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
-       /* HSE oscillator clock selected as PREDIV1 clock entry */
-       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
- #else
-        /* HSE selected as PLL clock entry */
-        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
-        {/* HSE oscillator clock divided by 2 */
-          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
-        }
-        else
-        {
-          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
-        }
- #endif
-      }
-#else
-      pllmull = pllmull >> 18;
-      
-      if (pllmull != 0x0D)
-      {
-         pllmull += 2;
-      }
-      else
-      { /* PLL multiplication factor = PLL input clock * 6.5 */
-        pllmull = 13 / 2; 
-      }
-            
-      if (pllsource == 0x00)
-      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
-        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
-      }
-      else
-      {/* PREDIV1 selected as PLL clock entry */
-        
-        /* Get PREDIV1 clock source and division factor */
-        prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
-        prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
-        
-        if (prediv1source == 0)
-        { /* HSE oscillator clock selected as PREDIV1 clock entry */
-          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
-        }
-        else
-        {/* PLL2 clock selected as PREDIV1 clock entry */
-          
-          /* Get PREDIV2 division factor and PLL2 multiplication factor */
-          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
-          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
-          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
-        }
-      }
-#endif /* STM32F10X_CL */ 
-      break;
-
-    default:
-      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
-      break;
-  }
-
-  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
-  /* Get HCLK prescaler */
-  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
-  tmp = tmp >> 4;
-  presc = APBAHBPrescTable[tmp];
-  /* HCLK clock frequency */
-  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
-  /* Get PCLK1 prescaler */
-  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
-  tmp = tmp >> 8;
-  presc = APBAHBPrescTable[tmp];
-  /* PCLK1 clock frequency */
-  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
-  /* Get PCLK2 prescaler */
-  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
-  tmp = tmp >> 11;
-  presc = APBAHBPrescTable[tmp];
-  /* PCLK2 clock frequency */
-  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
-  /* Get ADCCLK prescaler */
-  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
-  tmp = tmp >> 14;
-  presc = ADCPrescTable[tmp];
-  /* ADCCLK clock frequency */
-  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
-}
-
-/**
-  * @brief  Enables or disables the AHB peripheral clock.
-  * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
-  *   
-  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
-  *   of the following values:        
-  *     @arg RCC_AHBPeriph_DMA1
-  *     @arg RCC_AHBPeriph_DMA2
-  *     @arg RCC_AHBPeriph_SRAM
-  *     @arg RCC_AHBPeriph_FLITF
-  *     @arg RCC_AHBPeriph_CRC
-  *     @arg RCC_AHBPeriph_OTG_FS    
-  *     @arg RCC_AHBPeriph_ETH_MAC   
-  *     @arg RCC_AHBPeriph_ETH_MAC_Tx
-  *     @arg RCC_AHBPeriph_ETH_MAC_Rx
-  * 
-  *   For @b other_STM32_devices, this parameter can be any combination of the 
-  *   following values:        
-  *     @arg RCC_AHBPeriph_DMA1
-  *     @arg RCC_AHBPeriph_DMA2
-  *     @arg RCC_AHBPeriph_SRAM
-  *     @arg RCC_AHBPeriph_FLITF
-  *     @arg RCC_AHBPeriph_CRC
-  *     @arg RCC_AHBPeriph_FSMC
-  *     @arg RCC_AHBPeriph_SDIO
-  *   
-  * @note SRAM and FLITF clock can be disabled only during sleep mode.
-  * @param  NewState: new state of the specified peripheral clock.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC->AHBENR |= RCC_AHBPeriph;
-  }
-  else
-  {
-    RCC->AHBENR &= ~RCC_AHBPeriph;
-  }
-}
-
-/**
-  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
-  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
-  *   This parameter can be any combination of the following values:
-  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
-  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
-  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
-  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
-  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
-  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
-  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11     
-  * @param  NewState: new state of the specified peripheral clock.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    RCC->APB2ENR |= RCC_APB2Periph;
-  }
-  else
-  {
-    RCC->APB2ENR &= ~RCC_APB2Periph;
-  }
-}
-
-/**
-  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
-  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
-  *   This parameter can be any combination of the following values:
-  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
-  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
-  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
-  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
-  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
-  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
-  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
-  *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14
-  * @param  NewState: new state of the specified peripheral clock.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    RCC->APB1ENR |= RCC_APB1Periph;
-  }
-  else
-  {
-    RCC->APB1ENR &= ~RCC_APB1Periph;
-  }
-}
-
-#ifdef STM32F10X_CL
-/**
-  * @brief  Forces or releases AHB peripheral reset.
-  * @note   This function applies only to STM32 Connectivity line devices.
-  * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
-  *   This parameter can be any combination of the following values:
-  *     @arg RCC_AHBPeriph_OTG_FS 
-  *     @arg RCC_AHBPeriph_ETH_MAC
-  * @param  NewState: new state of the specified peripheral reset.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-
-  if (NewState != DISABLE)
-  {
-    RCC->AHBRSTR |= RCC_AHBPeriph;
-  }
-  else
-  {
-    RCC->AHBRSTR &= ~RCC_AHBPeriph;
-  }
-}
-#endif /* STM32F10X_CL */ 
-
-/**
-  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
-  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
-  *   This parameter can be any combination of the following values:
-  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
-  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
-  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
-  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
-  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,
-  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,
-  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11  
-  * @param  NewState: new state of the specified peripheral reset.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    RCC->APB2RSTR |= RCC_APB2Periph;
-  }
-  else
-  {
-    RCC->APB2RSTR &= ~RCC_APB2Periph;
-  }
-}
-
-/**
-  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
-  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
-  *   This parameter can be any combination of the following values:
-  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
-  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
-  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
-  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
-  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
-  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
-  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,
-  *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14  
-  * @param  NewState: new state of the specified peripheral clock.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    RCC->APB1RSTR |= RCC_APB1Periph;
-  }
-  else
-  {
-    RCC->APB1RSTR &= ~RCC_APB1Periph;
-  }
-}
-
-/**
-  * @brief  Forces or releases the Backup domain reset.
-  * @param  NewState: new state of the Backup domain reset.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_BackupResetCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enables or disables the Clock Security System.
-  * @param  NewState: new state of the Clock Security System..
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Selects the clock source to output on MCO pin.
-  * @param  RCC_MCO: specifies the clock source to output.
-  *   
-  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
-  *   following values:       
-  *     @arg RCC_MCO_NoClock: No clock selected
-  *     @arg RCC_MCO_SYSCLK: System clock selected
-  *     @arg RCC_MCO_HSI: HSI oscillator clock selected
-  *     @arg RCC_MCO_HSE: HSE oscillator clock selected
-  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
-  *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected                     
-  *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected   
-  *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected  
-  *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected 
-  * 
-  *   For  @b other_STM32_devices, this parameter can be one of the following values:        
-  *     @arg RCC_MCO_NoClock: No clock selected
-  *     @arg RCC_MCO_SYSCLK: System clock selected
-  *     @arg RCC_MCO_HSI: HSI oscillator clock selected
-  *     @arg RCC_MCO_HSE: HSE oscillator clock selected
-  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
-  *   
-  * @retval None
-  */
-void RCC_MCOConfig(uint8_t RCC_MCO)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_MCO(RCC_MCO));
-
-  /* Perform Byte access to MCO bits to select the MCO source */
-  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
-}
-
-/**
-  * @brief  Checks whether the specified RCC flag is set or not.
-  * @param  RCC_FLAG: specifies the flag to check.
-  *   
-  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
-  *   following values:
-  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
-  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
-  *     @arg RCC_FLAG_PLLRDY: PLL clock ready
-  *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready      
-  *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready                           
-  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
-  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
-  *     @arg RCC_FLAG_PINRST: Pin reset
-  *     @arg RCC_FLAG_PORRST: POR/PDR reset
-  *     @arg RCC_FLAG_SFTRST: Software reset
-  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
-  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
-  *     @arg RCC_FLAG_LPWRRST: Low Power reset
-  * 
-  *   For @b other_STM32_devices, this parameter can be one of the following values:        
-  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
-  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
-  *     @arg RCC_FLAG_PLLRDY: PLL clock ready
-  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
-  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
-  *     @arg RCC_FLAG_PINRST: Pin reset
-  *     @arg RCC_FLAG_PORRST: POR/PDR reset
-  *     @arg RCC_FLAG_SFTRST: Software reset
-  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
-  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
-  *     @arg RCC_FLAG_LPWRRST: Low Power reset
-  *   
-  * @retval The new state of RCC_FLAG (SET or RESET).
-  */
-FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
-{
-  uint32_t tmp = 0;
-  uint32_t statusreg = 0;
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_RCC_FLAG(RCC_FLAG));
-
-  /* Get the RCC register index */
-  tmp = RCC_FLAG >> 5;
-  if (tmp == 1)               /* The flag to check is in CR register */
-  {
-    statusreg = RCC->CR;
-  }
-  else if (tmp == 2)          /* The flag to check is in BDCR register */
-  {
-    statusreg = RCC->BDCR;
-  }
-  else                       /* The flag to check is in CSR register */
-  {
-    statusreg = RCC->CSR;
-  }
-
-  /* Get the flag position */
-  tmp = RCC_FLAG & FLAG_Mask;
-  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the flag status */
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the RCC reset flags.
-  * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
-  *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
-  * @param  None
-  * @retval None
-  */
-void RCC_ClearFlag(void)
-{
-  /* Set RMVF bit to clear the reset flags */
-  RCC->CSR |= CSR_RMVF_Set;
-}
-
-/**
-  * @brief  Checks whether the specified RCC interrupt has occurred or not.
-  * @param  RCC_IT: specifies the RCC interrupt source to check.
-  *   
-  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
-  *   following values:
-  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
-  *     @arg RCC_IT_LSERDY: LSE ready interrupt
-  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
-  *     @arg RCC_IT_HSERDY: HSE ready interrupt
-  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
-  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
-  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
-  *     @arg RCC_IT_CSS: Clock Security System interrupt
-  * 
-  *   For @b other_STM32_devices, this parameter can be one of the following values:        
-  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
-  *     @arg RCC_IT_LSERDY: LSE ready interrupt
-  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
-  *     @arg RCC_IT_HSERDY: HSE ready interrupt
-  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
-  *     @arg RCC_IT_CSS: Clock Security System interrupt
-  *   
-  * @retval The new state of RCC_IT (SET or RESET).
-  */
-ITStatus RCC_GetITStatus(uint8_t RCC_IT)
-{
-  ITStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_RCC_GET_IT(RCC_IT));
-
-  /* Check the status of the specified RCC interrupt */
-  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-
-  /* Return the RCC_IT status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the RCC's interrupt pending bits.
-  * @param  RCC_IT: specifies the interrupt pending bit to clear.
-  *   
-  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
-  *   of the following values:
-  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
-  *     @arg RCC_IT_LSERDY: LSE ready interrupt
-  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
-  *     @arg RCC_IT_HSERDY: HSE ready interrupt
-  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
-  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
-  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
-  *     @arg RCC_IT_CSS: Clock Security System interrupt
-  * 
-  *   For @b other_STM32_devices, this parameter can be any combination of the
-  *   following values:        
-  *     @arg RCC_IT_LSIRDY: LSI ready interrupt
-  *     @arg RCC_IT_LSERDY: LSE ready interrupt
-  *     @arg RCC_IT_HSIRDY: HSI ready interrupt
-  *     @arg RCC_IT_HSERDY: HSE ready interrupt
-  *     @arg RCC_IT_PLLRDY: PLL ready interrupt
-  *   
-  *     @arg RCC_IT_CSS: Clock Security System interrupt
-  * @retval None
-  */
-void RCC_ClearITPendingBit(uint8_t RCC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
-
-  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
-     pending bits */
-  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rcc.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rcc.h
deleted file mode 100644
index 1149c3477..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rcc.h
+++ /dev/null
@@ -1,727 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_rcc.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the RCC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_RCC_H
-#define __STM32F10x_RCC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup RCC
-  * @{
-  */
-
-/** @defgroup RCC_Exported_Types
-  * @{
-  */
-
-typedef struct
-{
-  uint32_t SYSCLK_Frequency;  /*!< returns SYSCLK clock frequency expressed in Hz */
-  uint32_t HCLK_Frequency;    /*!< returns HCLK clock frequency expressed in Hz */
-  uint32_t PCLK1_Frequency;   /*!< returns PCLK1 clock frequency expressed in Hz */
-  uint32_t PCLK2_Frequency;   /*!< returns PCLK2 clock frequency expressed in Hz */
-  uint32_t ADCCLK_Frequency;  /*!< returns ADCCLK clock frequency expressed in Hz */
-}RCC_ClocksTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Exported_Constants
-  * @{
-  */
-
-/** @defgroup HSE_configuration 
-  * @{
-  */
-
-#define RCC_HSE_OFF                      ((uint32_t)0x00000000)
-#define RCC_HSE_ON                       ((uint32_t)0x00010000)
-#define RCC_HSE_Bypass                   ((uint32_t)0x00040000)
-#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
-                         ((HSE) == RCC_HSE_Bypass))
-
-/**
-  * @}
-  */ 
-
-/** @defgroup PLL_entry_clock_source 
-  * @{
-  */
-
-#define RCC_PLLSource_HSI_Div2           ((uint32_t)0x00000000)
-
-#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_CL)
- #define RCC_PLLSource_HSE_Div1           ((uint32_t)0x00010000)
- #define RCC_PLLSource_HSE_Div2           ((uint32_t)0x00030000)
- #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
-                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
-                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
-#else
- #define RCC_PLLSource_PREDIV1            ((uint32_t)0x00010000)
- #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
-                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
-#endif /* STM32F10X_CL */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup PLL_multiplication_factor 
-  * @{
-  */
-#ifndef STM32F10X_CL
- #define RCC_PLLMul_2                    ((uint32_t)0x00000000)
- #define RCC_PLLMul_3                    ((uint32_t)0x00040000)
- #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
- #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
- #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
- #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
- #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
- #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
- #define RCC_PLLMul_10                   ((uint32_t)0x00200000)
- #define RCC_PLLMul_11                   ((uint32_t)0x00240000)
- #define RCC_PLLMul_12                   ((uint32_t)0x00280000)
- #define RCC_PLLMul_13                   ((uint32_t)0x002C0000)
- #define RCC_PLLMul_14                   ((uint32_t)0x00300000)
- #define RCC_PLLMul_15                   ((uint32_t)0x00340000)
- #define RCC_PLLMul_16                   ((uint32_t)0x00380000)
- #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
-                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
-                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
-                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
-                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
-                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
-                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
-                              ((MUL) == RCC_PLLMul_16))
-
-#else
- #define RCC_PLLMul_4                    ((uint32_t)0x00080000)
- #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)
- #define RCC_PLLMul_6                    ((uint32_t)0x00100000)
- #define RCC_PLLMul_7                    ((uint32_t)0x00140000)
- #define RCC_PLLMul_8                    ((uint32_t)0x00180000)
- #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)
- #define RCC_PLLMul_6_5                  ((uint32_t)0x00340000)
-
- #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5) || \
-                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7) || \
-                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9) || \
-                              ((MUL) == RCC_PLLMul_6_5))
-#endif /* STM32F10X_CL */                              
-/**
-  * @}
-  */
-
-/** @defgroup PREDIV1_division_factor
-  * @{
-  */
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
- #define  RCC_PREDIV1_Div1               ((uint32_t)0x00000000)
- #define  RCC_PREDIV1_Div2               ((uint32_t)0x00000001)
- #define  RCC_PREDIV1_Div3               ((uint32_t)0x00000002)
- #define  RCC_PREDIV1_Div4               ((uint32_t)0x00000003)
- #define  RCC_PREDIV1_Div5               ((uint32_t)0x00000004)
- #define  RCC_PREDIV1_Div6               ((uint32_t)0x00000005)
- #define  RCC_PREDIV1_Div7               ((uint32_t)0x00000006)
- #define  RCC_PREDIV1_Div8               ((uint32_t)0x00000007)
- #define  RCC_PREDIV1_Div9               ((uint32_t)0x00000008)
- #define  RCC_PREDIV1_Div10              ((uint32_t)0x00000009)
- #define  RCC_PREDIV1_Div11              ((uint32_t)0x0000000A)
- #define  RCC_PREDIV1_Div12              ((uint32_t)0x0000000B)
- #define  RCC_PREDIV1_Div13              ((uint32_t)0x0000000C)
- #define  RCC_PREDIV1_Div14              ((uint32_t)0x0000000D)
- #define  RCC_PREDIV1_Div15              ((uint32_t)0x0000000E)
- #define  RCC_PREDIV1_Div16              ((uint32_t)0x0000000F)
-
- #define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
-                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
-#endif
-/**
-  * @}
-  */
-
-
-/** @defgroup PREDIV1_clock_source
-  * @{
-  */
-#ifdef STM32F10X_CL
-/* PREDIV1 clock source (for STM32 connectivity line devices) */
- #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000) 
- #define  RCC_PREDIV1_Source_PLL2        ((uint32_t)0x00010000) 
-
- #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE) || \
-                                        ((SOURCE) == RCC_PREDIV1_Source_PLL2)) 
-#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
-/* PREDIV1 clock source (for STM32 Value line devices) */
- #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000) 
-
- #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE)) 
-#endif
-/**
-  * @}
-  */
-
-#ifdef STM32F10X_CL
-/** @defgroup PREDIV2_division_factor
-  * @{
-  */
-  
- #define  RCC_PREDIV2_Div1               ((uint32_t)0x00000000)
- #define  RCC_PREDIV2_Div2               ((uint32_t)0x00000010)
- #define  RCC_PREDIV2_Div3               ((uint32_t)0x00000020)
- #define  RCC_PREDIV2_Div4               ((uint32_t)0x00000030)
- #define  RCC_PREDIV2_Div5               ((uint32_t)0x00000040)
- #define  RCC_PREDIV2_Div6               ((uint32_t)0x00000050)
- #define  RCC_PREDIV2_Div7               ((uint32_t)0x00000060)
- #define  RCC_PREDIV2_Div8               ((uint32_t)0x00000070)
- #define  RCC_PREDIV2_Div9               ((uint32_t)0x00000080)
- #define  RCC_PREDIV2_Div10              ((uint32_t)0x00000090)
- #define  RCC_PREDIV2_Div11              ((uint32_t)0x000000A0)
- #define  RCC_PREDIV2_Div12              ((uint32_t)0x000000B0)
- #define  RCC_PREDIV2_Div13              ((uint32_t)0x000000C0)
- #define  RCC_PREDIV2_Div14              ((uint32_t)0x000000D0)
- #define  RCC_PREDIV2_Div15              ((uint32_t)0x000000E0)
- #define  RCC_PREDIV2_Div16              ((uint32_t)0x000000F0)
-
- #define IS_RCC_PREDIV2(PREDIV2) (((PREDIV2) == RCC_PREDIV2_Div1) || ((PREDIV2) == RCC_PREDIV2_Div2) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div3) || ((PREDIV2) == RCC_PREDIV2_Div4) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div5) || ((PREDIV2) == RCC_PREDIV2_Div6) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div7) || ((PREDIV2) == RCC_PREDIV2_Div8) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div9) || ((PREDIV2) == RCC_PREDIV2_Div10) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div11) || ((PREDIV2) == RCC_PREDIV2_Div12) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div13) || ((PREDIV2) == RCC_PREDIV2_Div14) || \
-                                  ((PREDIV2) == RCC_PREDIV2_Div15) || ((PREDIV2) == RCC_PREDIV2_Div16))
-/**
-  * @}
-  */
-
-
-/** @defgroup PLL2_multiplication_factor
-  * @{
-  */
-  
- #define  RCC_PLL2Mul_8                  ((uint32_t)0x00000600)
- #define  RCC_PLL2Mul_9                  ((uint32_t)0x00000700)
- #define  RCC_PLL2Mul_10                 ((uint32_t)0x00000800)
- #define  RCC_PLL2Mul_11                 ((uint32_t)0x00000900)
- #define  RCC_PLL2Mul_12                 ((uint32_t)0x00000A00)
- #define  RCC_PLL2Mul_13                 ((uint32_t)0x00000B00)
- #define  RCC_PLL2Mul_14                 ((uint32_t)0x00000C00)
- #define  RCC_PLL2Mul_16                 ((uint32_t)0x00000E00)
- #define  RCC_PLL2Mul_20                 ((uint32_t)0x00000F00)
-
- #define IS_RCC_PLL2_MUL(MUL) (((MUL) == RCC_PLL2Mul_8) || ((MUL) == RCC_PLL2Mul_9)  || \
-                               ((MUL) == RCC_PLL2Mul_10) || ((MUL) == RCC_PLL2Mul_11) || \
-                               ((MUL) == RCC_PLL2Mul_12) || ((MUL) == RCC_PLL2Mul_13) || \
-                               ((MUL) == RCC_PLL2Mul_14) || ((MUL) == RCC_PLL2Mul_16) || \
-                               ((MUL) == RCC_PLL2Mul_20))
-/**
-  * @}
-  */
-
-
-/** @defgroup PLL3_multiplication_factor
-  * @{
-  */
-
- #define  RCC_PLL3Mul_8                  ((uint32_t)0x00006000)
- #define  RCC_PLL3Mul_9                  ((uint32_t)0x00007000)
- #define  RCC_PLL3Mul_10                 ((uint32_t)0x00008000)
- #define  RCC_PLL3Mul_11                 ((uint32_t)0x00009000)
- #define  RCC_PLL3Mul_12                 ((uint32_t)0x0000A000)
- #define  RCC_PLL3Mul_13                 ((uint32_t)0x0000B000)
- #define  RCC_PLL3Mul_14                 ((uint32_t)0x0000C000)
- #define  RCC_PLL3Mul_16                 ((uint32_t)0x0000E000)
- #define  RCC_PLL3Mul_20                 ((uint32_t)0x0000F000)
-
- #define IS_RCC_PLL3_MUL(MUL) (((MUL) == RCC_PLL3Mul_8) || ((MUL) == RCC_PLL3Mul_9)  || \
-                               ((MUL) == RCC_PLL3Mul_10) || ((MUL) == RCC_PLL3Mul_11) || \
-                               ((MUL) == RCC_PLL3Mul_12) || ((MUL) == RCC_PLL3Mul_13) || \
-                               ((MUL) == RCC_PLL3Mul_14) || ((MUL) == RCC_PLL3Mul_16) || \
-                               ((MUL) == RCC_PLL3Mul_20))
-/**
-  * @}
-  */
-
-#endif /* STM32F10X_CL */
-
-
-/** @defgroup System_clock_source 
-  * @{
-  */
-
-#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
-#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
-#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
-#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
-                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
-                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
-/**
-  * @}
-  */
-
-/** @defgroup AHB_clock_source 
-  * @{
-  */
-
-#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
-#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
-#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
-#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
-#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
-#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
-#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
-#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
-#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
-#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
-                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
-                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
-                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
-                           ((HCLK) == RCC_SYSCLK_Div512))
-/**
-  * @}
-  */ 
-
-/** @defgroup APB1_APB2_clock_source 
-  * @{
-  */
-
-#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
-#define RCC_HCLK_Div2                    ((uint32_t)0x00000400)
-#define RCC_HCLK_Div4                    ((uint32_t)0x00000500)
-#define RCC_HCLK_Div8                    ((uint32_t)0x00000600)
-#define RCC_HCLK_Div16                   ((uint32_t)0x00000700)
-#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
-                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
-                           ((PCLK) == RCC_HCLK_Div16))
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Interrupt_source 
-  * @{
-  */
-
-#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
-#define RCC_IT_LSERDY                    ((uint8_t)0x02)
-#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
-#define RCC_IT_HSERDY                    ((uint8_t)0x08)
-#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
-#define RCC_IT_CSS                       ((uint8_t)0x80)
-
-#ifndef STM32F10X_CL
- #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0xE0) == 0x00) && ((IT) != 0x00))
- #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
-                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
-                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
- #define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x60) == 0x00) && ((IT) != 0x00))
-#else
- #define RCC_IT_PLL2RDY                  ((uint8_t)0x20)
- #define RCC_IT_PLL3RDY                  ((uint8_t)0x40)
- #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
- #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
-                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
-                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
-                            ((IT) == RCC_IT_PLL2RDY) || ((IT) == RCC_IT_PLL3RDY))
- #define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)
-#endif /* STM32F10X_CL */ 
-
-
-/**
-  * @}
-  */
-
-#ifndef STM32F10X_CL
-/** @defgroup USB_Device_clock_source 
-  * @{
-  */
-
- #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)
- #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)
-
- #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
-                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
-/**
-  * @}
-  */
-#else
-/** @defgroup USB_OTG_FS_clock_source 
-  * @{
-  */
- #define RCC_OTGFSCLKSource_PLLVCO_Div3    ((uint8_t)0x00)
- #define RCC_OTGFSCLKSource_PLLVCO_Div2    ((uint8_t)0x01)
-
- #define IS_RCC_OTGFSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div3) || \
-                                         ((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div2))
-/**
-  * @}
-  */
-#endif /* STM32F10X_CL */ 
-
-
-#ifdef STM32F10X_CL
-/** @defgroup I2S2_clock_source 
-  * @{
-  */
- #define RCC_I2S2CLKSource_SYSCLK        ((uint8_t)0x00)
- #define RCC_I2S2CLKSource_PLL3_VCO      ((uint8_t)0x01)
-
- #define IS_RCC_I2S2CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_SYSCLK) || \
-                                        ((SOURCE) == RCC_I2S2CLKSource_PLL3_VCO))
-/**
-  * @}
-  */
-
-/** @defgroup I2S3_clock_source 
-  * @{
-  */
- #define RCC_I2S3CLKSource_SYSCLK        ((uint8_t)0x00)
- #define RCC_I2S3CLKSource_PLL3_VCO      ((uint8_t)0x01)
-
- #define IS_RCC_I2S3CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S3CLKSource_SYSCLK) || \
-                                        ((SOURCE) == RCC_I2S3CLKSource_PLL3_VCO))    
-/**
-  * @}
-  */
-#endif /* STM32F10X_CL */  
-  
-
-/** @defgroup ADC_clock_source 
-  * @{
-  */
-
-#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)
-#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)
-#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)
-#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)
-#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
-                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
-/**
-  * @}
-  */
-
-/** @defgroup LSE_configuration 
-  * @{
-  */
-
-#define RCC_LSE_OFF                      ((uint8_t)0x00)
-#define RCC_LSE_ON                       ((uint8_t)0x01)
-#define RCC_LSE_Bypass                   ((uint8_t)0x04)
-#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
-                         ((LSE) == RCC_LSE_Bypass))
-/**
-  * @}
-  */
-
-/** @defgroup RTC_clock_source 
-  * @{
-  */
-
-#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
-#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
-#define RCC_RTCCLKSource_HSE_Div128      ((uint32_t)0x00000300)
-#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
-                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
-                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
-/**
-  * @}
-  */
-
-/** @defgroup AHB_peripheral 
-  * @{
-  */
-
-#define RCC_AHBPeriph_DMA1               ((uint32_t)0x00000001)
-#define RCC_AHBPeriph_DMA2               ((uint32_t)0x00000002)
-#define RCC_AHBPeriph_SRAM               ((uint32_t)0x00000004)
-#define RCC_AHBPeriph_FLITF              ((uint32_t)0x00000010)
-#define RCC_AHBPeriph_CRC                ((uint32_t)0x00000040)
-
-#ifndef STM32F10X_CL
- #define RCC_AHBPeriph_FSMC              ((uint32_t)0x00000100)
- #define RCC_AHBPeriph_SDIO              ((uint32_t)0x00000400)
- #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
-#else
- #define RCC_AHBPeriph_OTG_FS            ((uint32_t)0x00001000)
- #define RCC_AHBPeriph_ETH_MAC           ((uint32_t)0x00004000)
- #define RCC_AHBPeriph_ETH_MAC_Tx        ((uint32_t)0x00008000)
- #define RCC_AHBPeriph_ETH_MAC_Rx        ((uint32_t)0x00010000)
-
- #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFE2FA8) == 0x00) && ((PERIPH) != 0x00))
- #define IS_RCC_AHB_PERIPH_RESET(PERIPH) ((((PERIPH) & 0xFFFFAFFF) == 0x00) && ((PERIPH) != 0x00))
-#endif /* STM32F10X_CL */
-/**
-  * @}
-  */
-
-/** @defgroup APB2_peripheral 
-  * @{
-  */
-
-#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
-#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
-#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)
-#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)
-#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)
-#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)
-#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)
-#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)
-#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)
-#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)
-#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)
-#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
-#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)
-#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
-#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)
-#define RCC_APB2Periph_TIM15             ((uint32_t)0x00010000)
-#define RCC_APB2Periph_TIM16             ((uint32_t)0x00020000)
-#define RCC_APB2Periph_TIM17             ((uint32_t)0x00040000)
-#define RCC_APB2Periph_TIM9              ((uint32_t)0x00080000)
-#define RCC_APB2Periph_TIM10             ((uint32_t)0x00100000)
-#define RCC_APB2Periph_TIM11             ((uint32_t)0x00200000)
-
-#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFC00002) == 0x00) && ((PERIPH) != 0x00))
-/**
-  * @}
-  */ 
-
-/** @defgroup APB1_peripheral 
-  * @{
-  */
-
-#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
-#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
-#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
-#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
-#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
-#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
-#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)
-#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)
-#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)
-#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
-#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
-#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
-#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
-#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
-#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
-#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
-#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
-#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
-#define RCC_APB1Periph_USB               ((uint32_t)0x00800000)
-#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
-#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)
-#define RCC_APB1Periph_BKP               ((uint32_t)0x08000000)
-#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
-#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
-#define RCC_APB1Periph_CEC               ((uint32_t)0x40000000)
- 
-#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x81013600) == 0x00) && ((PERIPH) != 0x00))
-
-/**
-  * @}
-  */
-
-/** @defgroup Clock_source_to_output_on_MCO_pin 
-  * @{
-  */
-
-#define RCC_MCO_NoClock                  ((uint8_t)0x00)
-#define RCC_MCO_SYSCLK                   ((uint8_t)0x04)
-#define RCC_MCO_HSI                      ((uint8_t)0x05)
-#define RCC_MCO_HSE                      ((uint8_t)0x06)
-#define RCC_MCO_PLLCLK_Div2              ((uint8_t)0x07)
-
-#ifndef STM32F10X_CL
- #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
-                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
-                          ((MCO) == RCC_MCO_PLLCLK_Div2))
-#else
- #define RCC_MCO_PLL2CLK                 ((uint8_t)0x08)
- #define RCC_MCO_PLL3CLK_Div2            ((uint8_t)0x09)
- #define RCC_MCO_XT1                     ((uint8_t)0x0A)
- #define RCC_MCO_PLL3CLK                 ((uint8_t)0x0B)
-
- #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
-                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
-                          ((MCO) == RCC_MCO_PLLCLK_Div2) || ((MCO) == RCC_MCO_PLL2CLK) || \
-                          ((MCO) == RCC_MCO_PLL3CLK_Div2) || ((MCO) == RCC_MCO_XT1) || \
-                          ((MCO) == RCC_MCO_PLL3CLK))
-#endif /* STM32F10X_CL */ 
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Flag 
-  * @{
-  */
-
-#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
-#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
-#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
-#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
-#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
-#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
-#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
-#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
-#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
-#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
-#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
-
-#ifndef STM32F10X_CL
- #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
-                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
-                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
-                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
-                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
-                            ((FLAG) == RCC_FLAG_LPWRRST))
-#else
- #define RCC_FLAG_PLL2RDY                ((uint8_t)0x3B) 
- #define RCC_FLAG_PLL3RDY                ((uint8_t)0x3D) 
- #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
-                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
-                            ((FLAG) == RCC_FLAG_PLL2RDY) || ((FLAG) == RCC_FLAG_PLL3RDY) || \
-                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
-                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
-                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
-                            ((FLAG) == RCC_FLAG_LPWRRST))
-#endif /* STM32F10X_CL */ 
-
-#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RCC_Exported_Functions
-  * @{
-  */
-
-void RCC_DeInit(void);
-void RCC_HSEConfig(uint32_t RCC_HSE);
-ErrorStatus RCC_WaitForHSEStartUp(void);
-void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
-void RCC_HSICmd(FunctionalState NewState);
-void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
-void RCC_PLLCmd(FunctionalState NewState);
-
-#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)
- void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div);
-#endif
-
-#ifdef  STM32F10X_CL
- void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div);
- void RCC_PLL2Config(uint32_t RCC_PLL2Mul);
- void RCC_PLL2Cmd(FunctionalState NewState);
- void RCC_PLL3Config(uint32_t RCC_PLL3Mul);
- void RCC_PLL3Cmd(FunctionalState NewState);
-#endif /* STM32F10X_CL */ 
-
-void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
-uint8_t RCC_GetSYSCLKSource(void);
-void RCC_HCLKConfig(uint32_t RCC_SYSCLK);
-void RCC_PCLK1Config(uint32_t RCC_HCLK);
-void RCC_PCLK2Config(uint32_t RCC_HCLK);
-void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
-
-#ifndef STM32F10X_CL
- void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);
-#else
- void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource);
-#endif /* STM32F10X_CL */ 
-
-void RCC_ADCCLKConfig(uint32_t RCC_PCLK2);
-
-#ifdef STM32F10X_CL
- void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource);                                  
- void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource);
-#endif /* STM32F10X_CL */ 
-
-void RCC_LSEConfig(uint8_t RCC_LSE);
-void RCC_LSICmd(FunctionalState NewState);
-void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
-void RCC_RTCCLKCmd(FunctionalState NewState);
-void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
-void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
-void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
-void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
-
-#ifdef STM32F10X_CL
-void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
-#endif /* STM32F10X_CL */ 
-
-void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
-void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
-void RCC_BackupResetCmd(FunctionalState NewState);
-void RCC_ClockSecuritySystemCmd(FunctionalState NewState);
-void RCC_MCOConfig(uint8_t RCC_MCO);
-FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
-void RCC_ClearFlag(void);
-ITStatus RCC_GetITStatus(uint8_t RCC_IT);
-void RCC_ClearITPendingBit(uint8_t RCC_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_RCC_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rtc.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rtc.c
deleted file mode 100644
index f05aef572..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rtc.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_rtc.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the RTC firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_rtc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup RTC 
-  * @brief RTC driver modules
-  * @{
-  */
-
-/** @defgroup RTC_Private_TypesDefinitions
-  * @{
-  */ 
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Private_Defines
-  * @{
-  */
-#define RTC_LSB_MASK     ((uint32_t)0x0000FFFF)  /*!< RTC LSB Mask */
-#define PRLH_MSB_MASK    ((uint32_t)0x000F0000)  /*!< RTC Prescaler MSB Mask */
-
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Enables or disables the specified RTC interrupts.
-  * @param  RTC_IT: specifies the RTC interrupts sources to be enabled or disabled.
-  *   This parameter can be any combination of the following values:
-  *     @arg RTC_IT_OW: Overflow interrupt
-  *     @arg RTC_IT_ALR: Alarm interrupt
-  *     @arg RTC_IT_SEC: Second interrupt
-  * @param  NewState: new state of the specified RTC interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_IT(RTC_IT));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    RTC->CRH |= RTC_IT;
-  }
-  else
-  {
-    RTC->CRH &= (uint16_t)~RTC_IT;
-  }
-}
-
-/**
-  * @brief  Enters the RTC configuration mode.
-  * @param  None
-  * @retval None
-  */
-void RTC_EnterConfigMode(void)
-{
-  /* Set the CNF flag to enter in the Configuration Mode */
-  RTC->CRL |= RTC_CRL_CNF;
-}
-
-/**
-  * @brief  Exits from the RTC configuration mode.
-  * @param  None
-  * @retval None
-  */
-void RTC_ExitConfigMode(void)
-{
-  /* Reset the CNF flag to exit from the Configuration Mode */
-  RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
-}
-
-/**
-  * @brief  Gets the RTC counter value.
-  * @param  None
-  * @retval RTC counter value.
-  */
-uint32_t RTC_GetCounter(void)
-{
-  uint16_t tmp = 0;
-  tmp = RTC->CNTL;
-  return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;
-}
-
-/**
-  * @brief  Sets the RTC counter value.
-  * @param  CounterValue: RTC counter new value.
-  * @retval None
-  */
-void RTC_SetCounter(uint32_t CounterValue)
-{ 
-  RTC_EnterConfigMode();
-  /* Set RTC COUNTER MSB word */
-  RTC->CNTH = CounterValue >> 16;
-  /* Set RTC COUNTER LSB word */
-  RTC->CNTL = (CounterValue & RTC_LSB_MASK);
-  RTC_ExitConfigMode();
-}
-
-/**
-  * @brief  Sets the RTC prescaler value.
-  * @param  PrescalerValue: RTC prescaler new value.
-  * @retval None
-  */
-void RTC_SetPrescaler(uint32_t PrescalerValue)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_PRESCALER(PrescalerValue));
-  
-  RTC_EnterConfigMode();
-  /* Set RTC PRESCALER MSB word */
-  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
-  /* Set RTC PRESCALER LSB word */
-  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
-  RTC_ExitConfigMode();
-}
-
-/**
-  * @brief  Sets the RTC alarm value.
-  * @param  AlarmValue: RTC alarm new value.
-  * @retval None
-  */
-void RTC_SetAlarm(uint32_t AlarmValue)
-{  
-  RTC_EnterConfigMode();
-  /* Set the ALARM MSB word */
-  RTC->ALRH = AlarmValue >> 16;
-  /* Set the ALARM LSB word */
-  RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
-  RTC_ExitConfigMode();
-}
-
-/**
-  * @brief  Gets the RTC divider value.
-  * @param  None
-  * @retval RTC Divider value.
-  */
-uint32_t RTC_GetDivider(void)
-{
-  uint32_t tmp = 0x00;
-  tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
-  tmp |= RTC->DIVL;
-  return tmp;
-}
-
-/**
-  * @brief  Waits until last write operation on RTC registers has finished.
-  * @note   This function must be called before any write to RTC registers.
-  * @param  None
-  * @retval None
-  */
-void RTC_WaitForLastTask(void)
-{
-  /* Loop until RTOFF flag is set */
-  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
-  {
-  }
-}
-
-/**
-  * @brief  Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)
-  *   are synchronized with RTC APB clock.
-  * @note   This function must be called before any read operation after an APB reset
-  *   or an APB clock stop.
-  * @param  None
-  * @retval None
-  */
-void RTC_WaitForSynchro(void)
-{
-  /* Clear RSF flag */
-  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
-  /* Loop until RSF flag is set */
-  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
-  {
-  }
-}
-
-/**
-  * @brief  Checks whether the specified RTC flag is set or not.
-  * @param  RTC_FLAG: specifies the flag to check.
-  *   This parameter can be one the following values:
-  *     @arg RTC_FLAG_RTOFF: RTC Operation OFF flag
-  *     @arg RTC_FLAG_RSF: Registers Synchronized flag
-  *     @arg RTC_FLAG_OW: Overflow flag
-  *     @arg RTC_FLAG_ALR: Alarm flag
-  *     @arg RTC_FLAG_SEC: Second flag
-  * @retval The new state of RTC_FLAG (SET or RESET).
-  */
-FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
-  
-  if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the RTC's pending flags.
-  * @param  RTC_FLAG: specifies the flag to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg RTC_FLAG_RSF: Registers Synchronized flag. This flag is cleared only after
-  *                        an APB reset or an APB Clock stop.
-  *     @arg RTC_FLAG_OW: Overflow flag
-  *     @arg RTC_FLAG_ALR: Alarm flag
-  *     @arg RTC_FLAG_SEC: Second flag
-  * @retval None
-  */
-void RTC_ClearFlag(uint16_t RTC_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
-    
-  /* Clear the corresponding RTC flag */
-  RTC->CRL &= (uint16_t)~RTC_FLAG;
-}
-
-/**
-  * @brief  Checks whether the specified RTC interrupt has occurred or not.
-  * @param  RTC_IT: specifies the RTC interrupts sources to check.
-  *   This parameter can be one of the following values:
-  *     @arg RTC_IT_OW: Overflow interrupt
-  *     @arg RTC_IT_ALR: Alarm interrupt
-  *     @arg RTC_IT_SEC: Second interrupt
-  * @retval The new state of the RTC_IT (SET or RESET).
-  */
-ITStatus RTC_GetITStatus(uint16_t RTC_IT)
-{
-  ITStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_RTC_GET_IT(RTC_IT)); 
-  
-  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
-  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the RTC's interrupt pending bits.
-  * @param  RTC_IT: specifies the interrupt pending bit to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg RTC_IT_OW: Overflow interrupt
-  *     @arg RTC_IT_ALR: Alarm interrupt
-  *     @arg RTC_IT_SEC: Second interrupt
-  * @retval None
-  */
-void RTC_ClearITPendingBit(uint16_t RTC_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_RTC_IT(RTC_IT));  
-  
-  /* Clear the corresponding RTC pending bit */
-  RTC->CRL &= (uint16_t)~RTC_IT;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rtc.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rtc.h
deleted file mode 100644
index fd8beb5bc..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_rtc.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_rtc.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the RTC firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_RTC_H
-#define __STM32F10x_RTC_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup RTC
-  * @{
-  */ 
-
-/** @defgroup RTC_Exported_Types
-  * @{
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup RTC_Exported_Constants
-  * @{
-  */
-
-/** @defgroup RTC_interrupts_define 
-  * @{
-  */
-
-#define RTC_IT_OW            ((uint16_t)0x0004)  /*!< Overflow interrupt */
-#define RTC_IT_ALR           ((uint16_t)0x0002)  /*!< Alarm interrupt */
-#define RTC_IT_SEC           ((uint16_t)0x0001)  /*!< Second interrupt */
-#define IS_RTC_IT(IT) ((((IT) & (uint16_t)0xFFF8) == 0x00) && ((IT) != 0x00))
-#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \
-                           ((IT) == RTC_IT_SEC))
-/**
-  * @}
-  */ 
-
-/** @defgroup RTC_interrupts_flags 
-  * @{
-  */
-
-#define RTC_FLAG_RTOFF       ((uint16_t)0x0020)  /*!< RTC Operation OFF flag */
-#define RTC_FLAG_RSF         ((uint16_t)0x0008)  /*!< Registers Synchronized flag */
-#define RTC_FLAG_OW          ((uint16_t)0x0004)  /*!< Overflow flag */
-#define RTC_FLAG_ALR         ((uint16_t)0x0002)  /*!< Alarm flag */
-#define RTC_FLAG_SEC         ((uint16_t)0x0001)  /*!< Second flag */
-#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFF0) == 0x00) && ((FLAG) != 0x00))
-#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \
-                               ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \
-                               ((FLAG) == RTC_FLAG_SEC))
-#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) <= 0xFFFFF)
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup RTC_Exported_Functions
-  * @{
-  */
-
-void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState);
-void RTC_EnterConfigMode(void);
-void RTC_ExitConfigMode(void);
-uint32_t  RTC_GetCounter(void);
-void RTC_SetCounter(uint32_t CounterValue);
-void RTC_SetPrescaler(uint32_t PrescalerValue);
-void RTC_SetAlarm(uint32_t AlarmValue);
-uint32_t  RTC_GetDivider(void);
-void RTC_WaitForLastTask(void);
-void RTC_WaitForSynchro(void);
-FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG);
-void RTC_ClearFlag(uint16_t RTC_FLAG);
-ITStatus RTC_GetITStatus(uint16_t RTC_IT);
-void RTC_ClearITPendingBit(uint16_t RTC_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_RTC_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_sdio.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_sdio.c
deleted file mode 100644
index bc1719d76..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_sdio.c
+++ /dev/null
@@ -1,799 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_sdio.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the SDIO firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_sdio.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup SDIO 
-  * @brief SDIO driver modules
-  * @{
-  */ 
-
-/** @defgroup SDIO_Private_TypesDefinitions
-  * @{
-  */ 
-
-/* ------------ SDIO registers bit address in the alias region ----------- */
-#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
-
-/* --- CLKCR Register ---*/
-
-/* Alias word address of CLKEN bit */
-#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
-#define CLKEN_BitNumber           0x08
-#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
-
-/* --- CMD Register ---*/
-
-/* Alias word address of SDIOSUSPEND bit */
-#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
-#define SDIOSUSPEND_BitNumber     0x0B
-#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
-
-/* Alias word address of ENCMDCOMPL bit */
-#define ENCMDCOMPL_BitNumber      0x0C
-#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
-
-/* Alias word address of NIEN bit */
-#define NIEN_BitNumber            0x0D
-#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
-
-/* Alias word address of ATACMD bit */
-#define ATACMD_BitNumber          0x0E
-#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
-
-/* --- DCTRL Register ---*/
-
-/* Alias word address of DMAEN bit */
-#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
-#define DMAEN_BitNumber           0x03
-#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
-
-/* Alias word address of RWSTART bit */
-#define RWSTART_BitNumber         0x08
-#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
-
-/* Alias word address of RWSTOP bit */
-#define RWSTOP_BitNumber          0x09
-#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
-
-/* Alias word address of RWMOD bit */
-#define RWMOD_BitNumber           0x0A
-#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
-
-/* Alias word address of SDIOEN bit */
-#define SDIOEN_BitNumber          0x0B
-#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
-
-/* ---------------------- SDIO registers bit mask ------------------------ */
-
-/* --- CLKCR Register ---*/
-
-/* CLKCR register clear mask */
-#define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 
-
-/* --- PWRCTRL Register ---*/
-
-/* SDIO PWRCTRL Mask */
-#define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
-
-/* --- DCTRL Register ---*/
-
-/* SDIO DCTRL Clear Mask */
-#define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
-
-/* --- CMD Register ---*/
-
-/* CMD Register clear mask */
-#define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
-
-/* SDIO RESP Registers Address */
-#define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Private_Defines
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void SDIO_DeInit(void)
-{
-  SDIO->POWER = 0x00000000;
-  SDIO->CLKCR = 0x00000000;
-  SDIO->ARG = 0x00000000;
-  SDIO->CMD = 0x00000000;
-  SDIO->DTIMER = 0x00000000;
-  SDIO->DLEN = 0x00000000;
-  SDIO->DCTRL = 0x00000000;
-  SDIO->ICR = 0x00C007FF;
-  SDIO->MASK = 0x00000000;
-}
-
-/**
-  * @brief  Initializes the SDIO peripheral according to the specified 
-  *         parameters in the SDIO_InitStruct.
-  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
-  *         that contains the configuration information for the SDIO peripheral.
-  * @retval None
-  */
-void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
-{
-  uint32_t tmpreg = 0;
-    
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
-  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
-  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
-  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
-  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
-   
-/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
-  /* Get the SDIO CLKCR value */
-  tmpreg = SDIO->CLKCR;
-  
-  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
-  tmpreg &= CLKCR_CLEAR_MASK;
-  
-  /* Set CLKDIV bits according to SDIO_ClockDiv value */
-  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
-  /* Set BYPASS bit according to SDIO_ClockBypass value */
-  /* Set WIDBUS bits according to SDIO_BusWide value */
-  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
-  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
-  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
-             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
-             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
-  
-  /* Write to SDIO CLKCR */
-  SDIO->CLKCR = tmpreg;
-}
-
-/**
-  * @brief  Fills each SDIO_InitStruct member with its default value.
-  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
-  *   will be initialized.
-  * @retval None
-  */
-void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
-{
-  /* SDIO_InitStruct members default value */
-  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
-  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
-  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
-  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
-  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
-  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
-}
-
-/**
-  * @brief  Enables or disables the SDIO Clock.
-  * @param  NewState: new state of the SDIO Clock. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_ClockCmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Sets the power status of the controller.
-  * @param  SDIO_PowerState: new state of the Power state. 
-  *   This parameter can be one of the following values:
-  *     @arg SDIO_PowerState_OFF
-  *     @arg SDIO_PowerState_ON
-  * @retval None
-  */
-void SDIO_SetPowerState(uint32_t SDIO_PowerState)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
-  
-  SDIO->POWER &= PWR_PWRCTRL_MASK;
-  SDIO->POWER |= SDIO_PowerState;
-}
-
-/**
-  * @brief  Gets the power status of the controller.
-  * @param  None
-  * @retval Power status of the controller. The returned value can
-  *   be one of the following:
-  * - 0x00: Power OFF
-  * - 0x02: Power UP
-  * - 0x03: Power ON 
-  */
-uint32_t SDIO_GetPowerState(void)
-{
-  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
-}
-
-/**
-  * @brief  Enables or disables the SDIO interrupts.
-  * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
-  *   This parameter can be one or a combination of the following values:
-  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
-  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
-  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
-  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
-  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
-  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
-  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
-  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
-  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
-  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
-  *                            bus mode interrupt
-  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
-  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
-  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
-  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt
-  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
-  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
-  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
-  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
-  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
-  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
-  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
-  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
-  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
-  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
-  * @param  NewState: new state of the specified SDIO interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None 
-  */
-void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_IT(SDIO_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the SDIO interrupts */
-    SDIO->MASK |= SDIO_IT;
-  }
-  else
-  {
-    /* Disable the SDIO interrupts */
-    SDIO->MASK &= ~SDIO_IT;
-  } 
-}
-
-/**
-  * @brief  Enables or disables the SDIO DMA request.
-  * @param  NewState: new state of the selected SDIO DMA request.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_DMACmd(FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Initializes the SDIO Command according to the specified 
-  *         parameters in the SDIO_CmdInitStruct and send the command.
-  * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
-  *         structure that contains the configuration information for the SDIO command.
-  * @retval None
-  */
-void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
-{
-  uint32_t tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
-  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
-  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
-  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
-  
-/*---------------------------- SDIO ARG Configuration ------------------------*/
-  /* Set the SDIO Argument value */
-  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
-  
-/*---------------------------- SDIO CMD Configuration ------------------------*/  
-  /* Get the SDIO CMD value */
-  tmpreg = SDIO->CMD;
-  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
-  tmpreg &= CMD_CLEAR_MASK;
-  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
-  /* Set WAITRESP bits according to SDIO_Response value */
-  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
-  /* Set CPSMEN bits according to SDIO_CPSM value */
-  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
-           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
-  
-  /* Write to SDIO CMD */
-  SDIO->CMD = tmpreg;
-}
-
-/**
-  * @brief  Fills each SDIO_CmdInitStruct member with its default value.
-  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
-  *         structure which will be initialized.
-  * @retval None
-  */
-void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
-{
-  /* SDIO_CmdInitStruct members default value */
-  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
-  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
-  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
-  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
-  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
-}
-
-/**
-  * @brief  Returns command index of last command for which response received.
-  * @param  None
-  * @retval Returns the command index of the last command response received.
-  */
-uint8_t SDIO_GetCommandResponse(void)
-{
-  return (uint8_t)(SDIO->RESPCMD);
-}
-
-/**
-  * @brief  Returns response received from the card for the last command.
-  * @param  SDIO_RESP: Specifies the SDIO response register. 
-  *   This parameter can be one of the following values:
-  *     @arg SDIO_RESP1: Response Register 1
-  *     @arg SDIO_RESP2: Response Register 2
-  *     @arg SDIO_RESP3: Response Register 3
-  *     @arg SDIO_RESP4: Response Register 4
-  * @retval The Corresponding response register value.
-  */
-uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
-{
-  __IO uint32_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SDIO_RESP(SDIO_RESP));
-
-  tmp = SDIO_RESP_ADDR + SDIO_RESP;
-  
-  return (*(__IO uint32_t *) tmp); 
-}
-
-/**
-  * @brief  Initializes the SDIO data path according to the specified 
-  *   parameters in the SDIO_DataInitStruct.
-  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure that
-  *   contains the configuration information for the SDIO command.
-  * @retval None
-  */
-void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
-{
-  uint32_t tmpreg = 0;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
-  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
-  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
-  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
-  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
-
-/*---------------------------- SDIO DTIMER Configuration ---------------------*/
-  /* Set the SDIO Data TimeOut value */
-  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
-
-/*---------------------------- SDIO DLEN Configuration -----------------------*/
-  /* Set the SDIO DataLength value */
-  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
-
-/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
-  /* Get the SDIO DCTRL value */
-  tmpreg = SDIO->DCTRL;
-  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
-  tmpreg &= DCTRL_CLEAR_MASK;
-  /* Set DEN bit according to SDIO_DPSM value */
-  /* Set DTMODE bit according to SDIO_TransferMode value */
-  /* Set DTDIR bit according to SDIO_TransferDir value */
-  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
-  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
-           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
-
-  /* Write to SDIO DCTRL */
-  SDIO->DCTRL = tmpreg;
-}
-
-/**
-  * @brief  Fills each SDIO_DataInitStruct member with its default value.
-  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure which
-  *         will be initialized.
-  * @retval None
-  */
-void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
-{
-  /* SDIO_DataInitStruct members default value */
-  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
-  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
-  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
-  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
-  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
-  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
-}
-
-/**
-  * @brief  Returns number of remaining data bytes to be transferred.
-  * @param  None
-  * @retval Number of remaining data bytes to be transferred
-  */
-uint32_t SDIO_GetDataCounter(void)
-{ 
-  return SDIO->DCOUNT;
-}
-
-/**
-  * @brief  Read one data word from Rx FIFO.
-  * @param  None
-  * @retval Data received
-  */
-uint32_t SDIO_ReadData(void)
-{ 
-  return SDIO->FIFO;
-}
-
-/**
-  * @brief  Write one data word to Tx FIFO.
-  * @param  Data: 32-bit data word to write.
-  * @retval None
-  */
-void SDIO_WriteData(uint32_t Data)
-{ 
-  SDIO->FIFO = Data;
-}
-
-/**
-  * @brief  Returns the number of words left to be written to or read from FIFO.	
-  * @param  None
-  * @retval Remaining number of words.
-  */
-uint32_t SDIO_GetFIFOCount(void)
-{ 
-  return SDIO->FIFOCNT;
-}
-
-/**
-  * @brief  Starts the SD I/O Read Wait operation.	
-  * @param  NewState: new state of the Start SDIO Read Wait operation. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_StartSDIOReadWait(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
-}
-
-/**
-  * @brief  Stops the SD I/O Read Wait operation.	
-  * @param  NewState: new state of the Stop SDIO Read Wait operation. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_StopSDIOReadWait(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
-}
-
-/**
-  * @brief  Sets one of the two options of inserting read wait interval.
-  * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
-  *   This parameter can be:
-  *     @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
-  *     @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
-  * @retval None
-  */
-void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
-{
-  /* Check the parameters */
-  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
-  
-  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
-}
-
-/**
-  * @brief  Enables or disables the SD I/O Mode Operation.
-  * @param  NewState: new state of SDIO specific operation. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_SetSDIOOperation(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enables or disables the SD I/O Mode suspend command sending.
-  * @param  NewState: new state of the SD I/O Mode suspend command.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enables or disables the command completion signal.
-  * @param  NewState: new state of command completion signal. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_CommandCompletionCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Enables or disables the CE-ATA interrupt.
-  * @param  NewState: new state of CE-ATA interrupt. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_CEATAITCmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
-}
-
-/**
-  * @brief  Sends CE-ATA command (CMD61).
-  * @param  NewState: new state of CE-ATA command. This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SDIO_SendCEATACmd(FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
-}
-
-/**
-  * @brief  Checks whether the specified SDIO flag is set or not.
-  * @param  SDIO_FLAG: specifies the flag to check. 
-  *   This parameter can be one of the following values:
-  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
-  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
-  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout
-  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout
-  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
-  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
-  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
-  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
-  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
-  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide 
-  *                              bus mode.
-  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
-  *     @arg SDIO_FLAG_CMDACT:   Command transfer in progress
-  *     @arg SDIO_FLAG_TXACT:    Data transmit in progress
-  *     @arg SDIO_FLAG_RXACT:    Data receive in progress
-  *     @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
-  *     @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
-  *     @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
-  *     @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
-  *     @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
-  *     @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
-  *     @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
-  *     @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
-  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
-  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
-  * @retval The new state of SDIO_FLAG (SET or RESET).
-  */
-FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
-{ 
-  FlagStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
-  
-  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the SDIO's pending flags.
-  * @param  SDIO_FLAG: specifies the flag to clear.  
-  *   This parameter can be one or a combination of the following values:
-  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
-  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
-  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout
-  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout
-  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
-  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
-  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
-  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
-  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
-  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide 
-  *                              bus mode
-  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
-  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
-  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
-  * @retval None
-  */
-void SDIO_ClearFlag(uint32_t SDIO_FLAG)
-{ 
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
-   
-  SDIO->ICR = SDIO_FLAG;
-}
-
-/**
-  * @brief  Checks whether the specified SDIO interrupt has occurred or not.
-  * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
-  *   This parameter can be one of the following values:
-  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
-  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
-  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
-  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
-  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
-  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
-  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
-  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
-  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
-  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
-  *                            bus mode interrupt
-  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
-  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
-  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
-  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt
-  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
-  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
-  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
-  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
-  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
-  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
-  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
-  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
-  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
-  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
-  * @retval The new state of SDIO_IT (SET or RESET).
-  */
-ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
-{ 
-  ITStatus bitstatus = RESET;
-  
-  /* Check the parameters */
-  assert_param(IS_SDIO_GET_IT(SDIO_IT));
-  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the SDIO's interrupt pending bits.
-  * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
-  *   This parameter can be one or a combination of the following values:
-  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
-  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
-  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
-  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
-  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
-  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
-  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
-  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
-  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
-  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
-  *                            bus mode interrupt
-  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
-  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
-  * @retval None
-  */
-void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
-{ 
-  /* Check the parameters */
-  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
-   
-  SDIO->ICR = SDIO_IT;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_sdio.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_sdio.h
deleted file mode 100644
index 81c058ad4..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_sdio.h
+++ /dev/null
@@ -1,531 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_sdio.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the SDIO firmware
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_SDIO_H
-#define __STM32F10x_SDIO_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup SDIO
-  * @{
-  */
-
-/** @defgroup SDIO_Exported_Types
-  * @{
-  */
-
-typedef struct
-{
-  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
-                                           This parameter can be a value of @ref SDIO_Clock_Edge */
-
-  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
-                                           enabled or disabled.
-                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
-
-  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
-                                           disabled when the bus is idle.
-                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
-
-  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
-                                           This parameter can be a value of @ref SDIO_Bus_Wide */
-
-  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
-                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
-
-  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
-                                           This parameter can be a value between 0x00 and 0xFF. */
-                                           
-} SDIO_InitTypeDef;
-
-typedef struct
-{
-  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
-                                to a card as part of a command message. If a command
-                                contains an argument, it must be loaded into this register
-                                before writing the command to the command register */
-
-  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */
-
-  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
-                                This parameter can be a value of @ref SDIO_Response_Type */
-
-  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait-for-interrupt request is enabled or disabled.
-                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
-
-  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
-                                is enabled or disabled.
-                                This parameter can be a value of @ref SDIO_CPSM_State */
-} SDIO_CmdInitTypeDef;
-
-typedef struct
-{
-  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */
-
-  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
- 
-  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
-                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
- 
-  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
-                                     is a read or write.
-                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
- 
-  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
-                                     This parameter can be a value of @ref SDIO_Transfer_Type */
- 
-  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
-                                     is enabled or disabled.
-                                     This parameter can be a value of @ref SDIO_DPSM_State */
-} SDIO_DataInitTypeDef;
-
-/**
-  * @}
-  */ 
-
-/** @defgroup SDIO_Exported_Constants
-  * @{
-  */
-
-/** @defgroup SDIO_Clock_Edge 
-  * @{
-  */
-
-#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
-#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
-#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
-                                  ((EDGE) == SDIO_ClockEdge_Falling))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Clock_Bypass 
-  * @{
-  */
-
-#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
-#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
-#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
-                                     ((BYPASS) == SDIO_ClockBypass_Enable))
-/**
-  * @}
-  */ 
-
-/** @defgroup SDIO_Clock_Power_Save 
-  * @{
-  */
-
-#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
-#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
-#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
-                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Bus_Wide 
-  * @{
-  */
-
-#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
-#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
-#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
-#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
-                                ((WIDE) == SDIO_BusWide_8b))
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Hardware_Flow_Control 
-  * @{
-  */
-
-#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
-#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
-#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
-                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Power_State 
-  * @{
-  */
-
-#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
-#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
-#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON)) 
-/**
-  * @}
-  */ 
-
-
-/** @defgroup SDIO_Interrupt_sources 
-  * @{
-  */
-
-#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
-#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
-#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
-#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
-#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
-#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
-#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
-#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
-#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
-#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
-#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
-#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
-#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
-#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
-#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
-#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
-#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
-#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
-#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
-#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
-#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
-#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
-#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
-#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
-#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
-/**
-  * @}
-  */ 
-
-/** @defgroup SDIO_Command_Index
-  * @{
-  */
-
-#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Response_Type 
-  * @{
-  */
-
-#define SDIO_Response_No                    ((uint32_t)0x00000000)
-#define SDIO_Response_Short                 ((uint32_t)0x00000040)
-#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
-#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
-                                    ((RESPONSE) == SDIO_Response_Short) || \
-                                    ((RESPONSE) == SDIO_Response_Long))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Wait_Interrupt_State 
-  * @{
-  */
-
-#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
-#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
-#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
-#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
-                            ((WAIT) == SDIO_Wait_Pend))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_CPSM_State 
-  * @{
-  */
-
-#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
-#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
-#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup SDIO_Response_Registers 
-  * @{
-  */
-
-#define SDIO_RESP1                          ((uint32_t)0x00000000)
-#define SDIO_RESP2                          ((uint32_t)0x00000004)
-#define SDIO_RESP3                          ((uint32_t)0x00000008)
-#define SDIO_RESP4                          ((uint32_t)0x0000000C)
-#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
-                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Data_Length 
-  * @{
-  */
-
-#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Data_Block_Size 
-  * @{
-  */
-
-#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
-#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
-#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
-#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
-#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
-#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
-#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
-#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
-#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
-#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
-#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
-#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
-#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
-#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
-#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
-#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
-                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Transfer_Direction 
-  * @{
-  */
-
-#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
-#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
-#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
-                                   ((DIR) == SDIO_TransferDir_ToSDIO))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Transfer_Type 
-  * @{
-  */
-
-#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
-#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
-#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
-                                     ((MODE) == SDIO_TransferMode_Block))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_DPSM_State 
-  * @{
-  */
-
-#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
-#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
-#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Flags 
-  * @{
-  */
-
-#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
-#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
-#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
-#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
-#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
-#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
-#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
-#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
-#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
-#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
-#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
-#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
-#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
-#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
-#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
-#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
-#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
-#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
-#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
-#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
-#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
-#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
-#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
-#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
-#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
-                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
-                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
-                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
-                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
-                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
-                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
-                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
-                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
-                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
-                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
-                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
-                            ((FLAG)  == SDIO_FLAG_TXACT) || \
-                            ((FLAG)  == SDIO_FLAG_RXACT) || \
-                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
-                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
-                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
-                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
-                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
-                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
-                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
-                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
-                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
-                            ((FLAG)  == SDIO_FLAG_CEATAEND))
-
-#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))
-
-#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
-                            ((IT)  == SDIO_IT_DCRCFAIL) || \
-                            ((IT)  == SDIO_IT_CTIMEOUT) || \
-                            ((IT)  == SDIO_IT_DTIMEOUT) || \
-                            ((IT)  == SDIO_IT_TXUNDERR) || \
-                            ((IT)  == SDIO_IT_RXOVERR) || \
-                            ((IT)  == SDIO_IT_CMDREND) || \
-                            ((IT)  == SDIO_IT_CMDSENT) || \
-                            ((IT)  == SDIO_IT_DATAEND) || \
-                            ((IT)  == SDIO_IT_STBITERR) || \
-                            ((IT)  == SDIO_IT_DBCKEND) || \
-                            ((IT)  == SDIO_IT_CMDACT) || \
-                            ((IT)  == SDIO_IT_TXACT) || \
-                            ((IT)  == SDIO_IT_RXACT) || \
-                            ((IT)  == SDIO_IT_TXFIFOHE) || \
-                            ((IT)  == SDIO_IT_RXFIFOHF) || \
-                            ((IT)  == SDIO_IT_TXFIFOF) || \
-                            ((IT)  == SDIO_IT_RXFIFOF) || \
-                            ((IT)  == SDIO_IT_TXFIFOE) || \
-                            ((IT)  == SDIO_IT_RXFIFOE) || \
-                            ((IT)  == SDIO_IT_TXDAVL) || \
-                            ((IT)  == SDIO_IT_RXDAVL) || \
-                            ((IT)  == SDIO_IT_SDIOIT) || \
-                            ((IT)  == SDIO_IT_CEATAEND))
-
-#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Read_Wait_Mode 
-  * @{
-  */
-
-#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
-#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
-#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
-                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SDIO_Exported_Functions
-  * @{
-  */
-
-void SDIO_DeInit(void);
-void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
-void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
-void SDIO_ClockCmd(FunctionalState NewState);
-void SDIO_SetPowerState(uint32_t SDIO_PowerState);
-uint32_t SDIO_GetPowerState(void);
-void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
-void SDIO_DMACmd(FunctionalState NewState);
-void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
-void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
-uint8_t SDIO_GetCommandResponse(void);
-uint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
-void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
-void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
-uint32_t SDIO_GetDataCounter(void);
-uint32_t SDIO_ReadData(void);
-void SDIO_WriteData(uint32_t Data);
-uint32_t SDIO_GetFIFOCount(void);
-void SDIO_StartSDIOReadWait(FunctionalState NewState);
-void SDIO_StopSDIOReadWait(FunctionalState NewState);
-void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
-void SDIO_SetSDIOOperation(FunctionalState NewState);
-void SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
-void SDIO_CommandCompletionCmd(FunctionalState NewState);
-void SDIO_CEATAITCmd(FunctionalState NewState);
-void SDIO_SendCEATACmd(FunctionalState NewState);
-FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
-void SDIO_ClearFlag(uint32_t SDIO_FLAG);
-ITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
-void SDIO_ClearITPendingBit(uint32_t SDIO_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_SDIO_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_spi.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_spi.c
deleted file mode 100644
index 4ec65b2d9..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_spi.c
+++ /dev/null
@@ -1,908 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_spi.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the SPI firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_spi.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup SPI 
-  * @brief SPI driver modules
-  * @{
-  */ 
-
-/** @defgroup SPI_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */ 
-
-
-/** @defgroup SPI_Private_Defines
-  * @{
-  */
-
-/* SPI SPE mask */
-#define CR1_SPE_Set          ((uint16_t)0x0040)
-#define CR1_SPE_Reset        ((uint16_t)0xFFBF)
-
-/* I2S I2SE mask */
-#define I2SCFGR_I2SE_Set     ((uint16_t)0x0400)
-#define I2SCFGR_I2SE_Reset   ((uint16_t)0xFBFF)
-
-/* SPI CRCNext mask */
-#define CR1_CRCNext_Set      ((uint16_t)0x1000)
-
-/* SPI CRCEN mask */
-#define CR1_CRCEN_Set        ((uint16_t)0x2000)
-#define CR1_CRCEN_Reset      ((uint16_t)0xDFFF)
-
-/* SPI SSOE mask */
-#define CR2_SSOE_Set         ((uint16_t)0x0004)
-#define CR2_SSOE_Reset       ((uint16_t)0xFFFB)
-
-/* SPI registers Masks */
-#define CR1_CLEAR_Mask       ((uint16_t)0x3040)
-#define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)
-
-/* SPI or I2S mode selection masks */
-#define SPI_Mode_Select      ((uint16_t)0xF7FF)
-#define I2S_Mode_Select      ((uint16_t)0x0800) 
-
-/* I2S clock source selection masks */
-#define I2S2_CLOCK_SRC       ((uint32_t)(0x00020000))
-#define I2S3_CLOCK_SRC       ((uint32_t)(0x00040000))
-#define I2S_MUL_MASK         ((uint32_t)(0x0000F000))
-#define I2S_DIV_MASK         ((uint32_t)(0x000000F0))
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the SPIx peripheral registers to their default
-  *         reset values (Affects also the I2Ss).
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @retval None
-  */
-void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-
-  if (SPIx == SPI1)
-  {
-    /* Enable SPI1 reset state */
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
-    /* Release SPI1 from reset state */
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
-  }
-  else if (SPIx == SPI2)
-  {
-    /* Enable SPI2 reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
-    /* Release SPI2 from reset state */
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
-  }
-  else
-  {
-    if (SPIx == SPI3)
-    {
-      /* Enable SPI3 reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
-      /* Release SPI3 from reset state */
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
-    }
-  }
-}
-
-/**
-  * @brief  Initializes the SPIx peripheral according to the specified 
-  *         parameters in the SPI_InitStruct.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
-  *         contains the configuration information for the specified SPI peripheral.
-  * @retval None
-  */
-void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
-{
-  uint16_t tmpreg = 0;
-  
-  /* check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));   
-  
-  /* Check the SPI parameters */
-  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
-  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
-  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
-  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
-  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
-  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
-  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
-  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
-  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
-
-/*---------------------------- SPIx CR1 Configuration ------------------------*/
-  /* Get the SPIx CR1 value */
-  tmpreg = SPIx->CR1;
-  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
-  tmpreg &= CR1_CLEAR_Mask;
-  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
-     master/salve mode, CPOL and CPHA */
-  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
-  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
-  /* Set LSBFirst bit according to SPI_FirstBit value */
-  /* Set BR bits according to SPI_BaudRatePrescaler value */
-  /* Set CPOL bit according to SPI_CPOL value */
-  /* Set CPHA bit according to SPI_CPHA value */
-  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
-                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
-                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
-                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
-  /* Write to SPIx CR1 */
-  SPIx->CR1 = tmpreg;
-  
-  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
-  SPIx->I2SCFGR &= SPI_Mode_Select;		
-
-/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
-  /* Write to SPIx CRCPOLY */
-  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
-}
-
-/**
-  * @brief  Initializes the SPIx peripheral according to the specified 
-  *         parameters in the I2S_InitStruct.
-  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral
-  *         (configured in I2S mode).
-  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
-  *         contains the configuration information for the specified SPI peripheral
-  *         configured in I2S mode.
-  * @note
-  *  The function calculates the optimal prescaler needed to obtain the most 
-  *  accurate audio frequency (depending on the I2S clock source, the PLL values 
-  *  and the product configuration). But in case the prescaler value is greater 
-  *  than 511, the default value (0x02) will be configured instead.  *   
-  * @retval None
-  */
-void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
-{
-  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
-  uint32_t tmp = 0;
-  RCC_ClocksTypeDef RCC_Clocks;
-  uint32_t sourceclock = 0;
-  
-  /* Check the I2S parameters */
-  assert_param(IS_SPI_23_PERIPH(SPIx));
-  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
-  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
-  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
-  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
-  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
-  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
-
-/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
-  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
-  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
-  SPIx->I2SPR = 0x0002;
-  
-  /* Get the I2SCFGR register value */
-  tmpreg = SPIx->I2SCFGR;
-  
-  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
-  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
-  {
-    i2sodd = (uint16_t)0;
-    i2sdiv = (uint16_t)2;   
-  }
-  /* If the requested audio frequency is not the default, compute the prescaler */
-  else
-  {
-    /* Check the frame length (For the Prescaler computing) */
-    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
-    {
-      /* Packet length is 16 bits */
-      packetlength = 1;
-    }
-    else
-    {
-      /* Packet length is 32 bits */
-      packetlength = 2;
-    }
-
-    /* Get the I2S clock source mask depending on the peripheral number */
-    if(((uint32_t)SPIx) == SPI2_BASE)
-    {
-      /* The mask is relative to I2S2 */
-      tmp = I2S2_CLOCK_SRC;
-    }
-    else 
-    {
-      /* The mask is relative to I2S3 */      
-      tmp = I2S3_CLOCK_SRC;
-    }
-
-    /* Check the I2S clock source configuration depending on the Device:
-       Only Connectivity line devices have the PLL3 VCO clock */
-#ifdef STM32F10X_CL
-    if((RCC->CFGR2 & tmp) != 0)
-    {
-      /* Get the configuration bits of RCC PLL3 multiplier */
-      tmp = (uint32_t)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);
-
-      /* Get the value of the PLL3 multiplier */      
-      if((tmp > 5) && (tmp < 15))
-      {
-        /* Multiplier is between 8 and 14 (value 15 is forbidden) */
-        tmp += 2;
-      }
-      else
-      {
-        if (tmp == 15)
-        {
-          /* Multiplier is 20 */
-          tmp = 20;
-        }
-      }      
-      /* Get the PREDIV2 value */
-      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);
-      
-      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */
-      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2); 
-    }
-    else
-    {
-      /* I2S Clock source is System clock: Get System Clock frequency */
-      RCC_GetClocksFreq(&RCC_Clocks);      
-      
-      /* Get the source clock value: based on System Clock value */
-      sourceclock = RCC_Clocks.SYSCLK_Frequency;
-    }        
-#else /* STM32F10X_HD */
-    /* I2S Clock source is System clock: Get System Clock frequency */
-    RCC_GetClocksFreq(&RCC_Clocks);      
-      
-    /* Get the source clock value: based on System Clock value */
-    sourceclock = RCC_Clocks.SYSCLK_Frequency;    
-#endif /* STM32F10X_CL */    
-
-    /* Compute the Real divider depending on the MCLK output state with a floating point */
-    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
-    {
-      /* MCLK output is enabled */
-      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
-    }
-    else
-    {
-      /* MCLK output is disabled */
-      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
-    }
-    
-    /* Remove the floating point */
-    tmp = tmp / 10;  
-      
-    /* Check the parity of the divider */
-    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
-   
-    /* Compute the i2sdiv prescaler */
-    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
-   
-    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
-    i2sodd = (uint16_t) (i2sodd << 8);
-  }
-  
-  /* Test if the divider is 1 or 0 or greater than 0xFF */
-  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
-  {
-    /* Set the default values */
-    i2sdiv = 2;
-    i2sodd = 0;
-  }
-
-  /* Write to SPIx I2SPR register the computed value */
-  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));  
- 
-  /* Configure the I2S with the SPI_InitStruct values */
-  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \
-                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
-                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
- 
-  /* Write to SPIx I2SCFGR */  
-  SPIx->I2SCFGR = tmpreg;   
-}
-
-/**
-  * @brief  Fills each SPI_InitStruct member with its default value.
-  * @param  SPI_InitStruct : pointer to a SPI_InitTypeDef structure which will be initialized.
-  * @retval None
-  */
-void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
-{
-/*--------------- Reset SPI init structure parameters values -----------------*/
-  /* Initialize the SPI_Direction member */
-  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
-  /* initialize the SPI_Mode member */
-  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
-  /* initialize the SPI_DataSize member */
-  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
-  /* Initialize the SPI_CPOL member */
-  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
-  /* Initialize the SPI_CPHA member */
-  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
-  /* Initialize the SPI_NSS member */
-  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
-  /* Initialize the SPI_BaudRatePrescaler member */
-  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
-  /* Initialize the SPI_FirstBit member */
-  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
-  /* Initialize the SPI_CRCPolynomial member */
-  SPI_InitStruct->SPI_CRCPolynomial = 7;
-}
-
-/**
-  * @brief  Fills each I2S_InitStruct member with its default value.
-  * @param  I2S_InitStruct : pointer to a I2S_InitTypeDef structure which will be initialized.
-  * @retval None
-  */
-void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
-{
-/*--------------- Reset I2S init structure parameters values -----------------*/
-  /* Initialize the I2S_Mode member */
-  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
-  
-  /* Initialize the I2S_Standard member */
-  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
-  
-  /* Initialize the I2S_DataFormat member */
-  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
-  
-  /* Initialize the I2S_MCLKOutput member */
-  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
-  
-  /* Initialize the I2S_AudioFreq member */
-  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
-  
-  /* Initialize the I2S_CPOL member */
-  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
-}
-
-/**
-  * @brief  Enables or disables the specified SPI peripheral.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  NewState: new state of the SPIx peripheral. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI peripheral */
-    SPIx->CR1 |= CR1_SPE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI peripheral */
-    SPIx->CR1 &= CR1_SPE_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
-  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.
-  * @param  NewState: new state of the SPIx peripheral. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_23_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI peripheral (in I2S mode) */
-    SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI peripheral (in I2S mode) */
-    SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified SPI/I2S interrupts.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  *   - 2 or 3 in I2S mode
-  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to be enabled or disabled. 
-  *   This parameter can be one of the following values:
-  *     @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
-  *     @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
-  *     @arg SPI_I2S_IT_ERR: Error interrupt mask
-  * @param  NewState: new state of the specified SPI/I2S interrupt.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
-{
-  uint16_t itpos = 0, itmask = 0 ;
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
-
-  /* Get the SPI/I2S IT index */
-  itpos = SPI_I2S_IT >> 4;
-
-  /* Set the IT mask */
-  itmask = (uint16_t)1 << (uint16_t)itpos;
-
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI/I2S interrupt */
-    SPIx->CR2 |= itmask;
-  }
-  else
-  {
-    /* Disable the selected SPI/I2S interrupt */
-    SPIx->CR2 &= (uint16_t)~itmask;
-  }
-}
-
-/**
-  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  *   - 2 or 3 in I2S mode
-  * @param  SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request to be enabled or disabled. 
-  *   This parameter can be any combination of the following values:
-  *     @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
-  *     @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
-  * @param  NewState: new state of the selected SPI/I2S DMA transfer request.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI/I2S DMA requests */
-    SPIx->CR2 |= SPI_I2S_DMAReq;
-  }
-  else
-  {
-    /* Disable the selected SPI/I2S DMA requests */
-    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
-  }
-}
-
-/**
-  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  *   - 2 or 3 in I2S mode
-  * @param  Data : Data to be transmitted.
-  * @retval None
-  */
-void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Write in the DR register the data to be sent */
-  SPIx->DR = Data;
-}
-
-/**
-  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  *   - 2 or 3 in I2S mode
-  * @retval The value of the received data.
-  */
-uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Return the data in the DR register */
-  return SPIx->DR;
-}
-
-/**
-  * @brief  Configures internally by software the NSS pin for the selected SPI.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
-  *   This parameter can be one of the following values:
-  *     @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
-  *     @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
-  * @retval None
-  */
-void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
-  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
-  {
-    /* Set NSS pin internally by software */
-    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
-  }
-  else
-  {
-    /* Reset NSS pin internally by software */
-    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the SS output for the selected SPI.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  NewState: new state of the SPIx SS output. 
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI SS output */
-    SPIx->CR2 |= CR2_SSOE_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI SS output */
-    SPIx->CR2 &= CR2_SSOE_Reset;
-  }
-}
-
-/**
-  * @brief  Configures the data size for the selected SPI.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  SPI_DataSize: specifies the SPI data size.
-  *   This parameter can be one of the following values:
-  *     @arg SPI_DataSize_16b: Set data frame format to 16bit
-  *     @arg SPI_DataSize_8b: Set data frame format to 8bit
-  * @retval None
-  */
-void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
-  /* Clear DFF bit */
-  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
-  /* Set new DFF bit value */
-  SPIx->CR1 |= SPI_DataSize;
-}
-
-/**
-  * @brief  Transmit the SPIx CRC value.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @retval None
-  */
-void SPI_TransmitCRC(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Enable the selected SPI CRC transmission */
-  SPIx->CR1 |= CR1_CRCNext_Set;
-}
-
-/**
-  * @brief  Enables or disables the CRC value calculation of the transferred bytes.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  NewState: new state of the SPIx CRC value calculation.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected SPI CRC calculation */
-    SPIx->CR1 |= CR1_CRCEN_Set;
-  }
-  else
-  {
-    /* Disable the selected SPI CRC calculation */
-    SPIx->CR1 &= CR1_CRCEN_Reset;
-  }
-}
-
-/**
-  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  SPI_CRC: specifies the CRC register to be read.
-  *   This parameter can be one of the following values:
-  *     @arg SPI_CRC_Tx: Selects Tx CRC register
-  *     @arg SPI_CRC_Rx: Selects Rx CRC register
-  * @retval The selected CRC register value..
-  */
-uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
-{
-  uint16_t crcreg = 0;
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_CRC(SPI_CRC));
-  if (SPI_CRC != SPI_CRC_Rx)
-  {
-    /* Get the Tx CRC register */
-    crcreg = SPIx->TXCRCR;
-  }
-  else
-  {
-    /* Get the Rx CRC register */
-    crcreg = SPIx->RXCRCR;
-  }
-  /* Return the selected CRC register */
-  return crcreg;
-}
-
-/**
-  * @brief  Returns the CRC Polynomial register value for the specified SPI.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @retval The CRC Polynomial register value.
-  */
-uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  
-  /* Return the CRC polynomial register */
-  return SPIx->CRCPR;
-}
-
-/**
-  * @brief  Selects the data transfer direction in bi-directional mode for the specified SPI.
-  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
-  * @param  SPI_Direction: specifies the data transfer direction in bi-directional mode. 
-  *   This parameter can be one of the following values:
-  *     @arg SPI_Direction_Tx: Selects Tx transmission direction
-  *     @arg SPI_Direction_Rx: Selects Rx receive direction
-  * @retval None
-  */
-void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_DIRECTION(SPI_Direction));
-  if (SPI_Direction == SPI_Direction_Tx)
-  {
-    /* Set the Tx only mode */
-    SPIx->CR1 |= SPI_Direction_Tx;
-  }
-  else
-  {
-    /* Set the Rx only mode */
-    SPIx->CR1 &= SPI_Direction_Rx;
-  }
-}
-
-/**
-  * @brief  Checks whether the specified SPI/I2S flag is set or not.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  *   - 2 or 3 in I2S mode
-  * @param  SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
-  *   This parameter can be one of the following values:
-  *     @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
-  *     @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
-  *     @arg SPI_I2S_FLAG_BSY: Busy flag.
-  *     @arg SPI_I2S_FLAG_OVR: Overrun flag.
-  *     @arg SPI_FLAG_MODF: Mode Fault flag.
-  *     @arg SPI_FLAG_CRCERR: CRC Error flag.
-  *     @arg I2S_FLAG_UDR: Underrun Error flag.
-  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.
-  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
-  */
-FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
-  /* Check the status of the specified SPI/I2S flag */
-  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
-  {
-    /* SPI_I2S_FLAG is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SPI_I2S_FLAG is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SPI_I2S_FLAG status */
-  return  bitstatus;
-}
-
-/**
-  * @brief  Clears the SPIx CRC Error (CRCERR) flag.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
-  *   This function clears only CRCERR flag.
-  * @note
-  *   - OVR (OverRun error) flag is cleared by software sequence: a read 
-  *     operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
-  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
-  *   - UDR (UnderRun error) flag is cleared by a read operation to 
-  *     SPI_SR register (SPI_I2S_GetFlagStatus()).
-  *   - MODF (Mode Fault) flag is cleared by software sequence: a read/write 
-  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
-  *     write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
-  * @retval None
-  */
-void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
-    
-    /* Clear the selected SPI CRC Error (CRCERR) flag */
-    SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
-}
-
-/**
-  * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  *   - 2 or 3 in I2S mode
-  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
-  *   This parameter can be one of the following values:
-  *     @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
-  *     @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
-  *     @arg SPI_I2S_IT_OVR: Overrun interrupt.
-  *     @arg SPI_IT_MODF: Mode Fault interrupt.
-  *     @arg SPI_IT_CRCERR: CRC Error interrupt.
-  *     @arg I2S_IT_UDR: Underrun Error interrupt.
-  * @retval The new state of SPI_I2S_IT (SET or RESET).
-  */
-ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
-{
-  ITStatus bitstatus = RESET;
-  uint16_t itpos = 0, itmask = 0, enablestatus = 0;
-
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
-
-  /* Get the SPI/I2S IT index */
-  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
-
-  /* Get the SPI/I2S IT mask */
-  itmask = SPI_I2S_IT >> 4;
-
-  /* Set the IT mask */
-  itmask = 0x01 << itmask;
-
-  /* Get the SPI_I2S_IT enable bit status */
-  enablestatus = (SPIx->CR2 & itmask) ;
-
-  /* Check the status of the specified SPI/I2S interrupt */
-  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
-  {
-    /* SPI_I2S_IT is set */
-    bitstatus = SET;
-  }
-  else
-  {
-    /* SPI_I2S_IT is reset */
-    bitstatus = RESET;
-  }
-  /* Return the SPI_I2S_IT status */
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
-  * @param  SPIx: where x can be
-  *   - 1, 2 or 3 in SPI mode 
-  * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
-  *   This function clears only CRCERR interrupt pending bit.   
-  * @note
-  *   - OVR (OverRun Error) interrupt pending bit is cleared by software 
-  *     sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
-  *     followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
-  *   - UDR (UnderRun Error) interrupt pending bit is cleared by a read 
-  *     operation to SPI_SR register (SPI_I2S_GetITStatus()).
-  *   - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
-  *     a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
-  *     followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
-  *     the SPI).
-  * @retval None
-  */
-void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
-{
-  uint16_t itpos = 0;
-  /* Check the parameters */
-  assert_param(IS_SPI_ALL_PERIPH(SPIx));
-  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
-
-  /* Get the SPI IT index */
-  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
-
-  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
-  SPIx->SR = (uint16_t)~itpos;
-}
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_spi.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_spi.h
deleted file mode 100644
index 23cc26d24..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_spi.h
+++ /dev/null
@@ -1,487 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_spi.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the SPI firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_SPI_H
-#define __STM32F10x_SPI_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup SPI
-  * @{
-  */ 
-
-/** @defgroup SPI_Exported_Types
-  * @{
-  */
-
-/** 
-  * @brief  SPI Init structure definition  
-  */
-
-typedef struct
-{
-  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
-                                         This parameter can be a value of @ref SPI_data_direction */
-
-  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
-                                         This parameter can be a value of @ref SPI_mode */
-
-  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
-                                         This parameter can be a value of @ref SPI_data_size */
-
-  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
-                                         This parameter can be a value of @ref SPI_Clock_Polarity */
-
-  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
-                                         This parameter can be a value of @ref SPI_Clock_Phase */
-
-  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
-                                         hardware (NSS pin) or by software using the SSI bit.
-                                         This parameter can be a value of @ref SPI_Slave_Select_management */
- 
-  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
-                                         used to configure the transmit and receive SCK clock.
-                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler.
-                                         @note The communication clock is derived from the master
-                                               clock. The slave clock does not need to be set. */
-
-  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
-                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
-
-  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
-}SPI_InitTypeDef;
-
-/** 
-  * @brief  I2S Init structure definition  
-  */
-
-typedef struct
-{
-
-  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
-                                  This parameter can be a value of @ref I2S_Mode */
-
-  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
-                                  This parameter can be a value of @ref I2S_Standard */
-
-  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
-                                  This parameter can be a value of @ref I2S_Data_Format */
-
-  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
-                                  This parameter can be a value of @ref I2S_MCLK_Output */
-
-  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
-                                  This parameter can be a value of @ref I2S_Audio_Frequency */
-
-  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
-                                  This parameter can be a value of @ref I2S_Clock_Polarity */
-}I2S_InitTypeDef;
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Exported_Constants
-  * @{
-  */
-
-#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
-                                   ((PERIPH) == SPI2) || \
-                                   ((PERIPH) == SPI3))
-
-#define IS_SPI_23_PERIPH(PERIPH) (((PERIPH) == SPI2) || \
-                                  ((PERIPH) == SPI3))
-
-/** @defgroup SPI_data_direction 
-  * @{
-  */
-  
-#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
-#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
-#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
-#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
-#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
-                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
-                                     ((MODE) == SPI_Direction_1Line_Rx) || \
-                                     ((MODE) == SPI_Direction_1Line_Tx))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_mode 
-  * @{
-  */
-
-#define SPI_Mode_Master                 ((uint16_t)0x0104)
-#define SPI_Mode_Slave                  ((uint16_t)0x0000)
-#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
-                           ((MODE) == SPI_Mode_Slave))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_data_size 
-  * @{
-  */
-
-#define SPI_DataSize_16b                ((uint16_t)0x0800)
-#define SPI_DataSize_8b                 ((uint16_t)0x0000)
-#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
-                                   ((DATASIZE) == SPI_DataSize_8b))
-/**
-  * @}
-  */ 
-
-/** @defgroup SPI_Clock_Polarity 
-  * @{
-  */
-
-#define SPI_CPOL_Low                    ((uint16_t)0x0000)
-#define SPI_CPOL_High                   ((uint16_t)0x0002)
-#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
-                           ((CPOL) == SPI_CPOL_High))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Clock_Phase 
-  * @{
-  */
-
-#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
-#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
-#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
-                           ((CPHA) == SPI_CPHA_2Edge))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Slave_Select_management 
-  * @{
-  */
-
-#define SPI_NSS_Soft                    ((uint16_t)0x0200)
-#define SPI_NSS_Hard                    ((uint16_t)0x0000)
-#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
-                         ((NSS) == SPI_NSS_Hard))
-/**
-  * @}
-  */ 
-
-/** @defgroup SPI_BaudRate_Prescaler 
-  * @{
-  */
-
-#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
-#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
-#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
-#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
-#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
-#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
-#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
-#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
-#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
-                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
-/**
-  * @}
-  */ 
-
-/** @defgroup SPI_MSB_LSB_transmission 
-  * @{
-  */
-
-#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
-#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
-#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
-                               ((BIT) == SPI_FirstBit_LSB))
-/**
-  * @}
-  */
-
-/** @defgroup I2S_Mode 
-  * @{
-  */
-
-#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
-#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
-#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
-#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
-#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
-                           ((MODE) == I2S_Mode_SlaveRx) || \
-                           ((MODE) == I2S_Mode_MasterTx) || \
-                           ((MODE) == I2S_Mode_MasterRx) )
-/**
-  * @}
-  */
-
-/** @defgroup I2S_Standard 
-  * @{
-  */
-
-#define I2S_Standard_Phillips           ((uint16_t)0x0000)
-#define I2S_Standard_MSB                ((uint16_t)0x0010)
-#define I2S_Standard_LSB                ((uint16_t)0x0020)
-#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
-#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
-#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
-                                   ((STANDARD) == I2S_Standard_MSB) || \
-                                   ((STANDARD) == I2S_Standard_LSB) || \
-                                   ((STANDARD) == I2S_Standard_PCMShort) || \
-                                   ((STANDARD) == I2S_Standard_PCMLong))
-/**
-  * @}
-  */
-
-/** @defgroup I2S_Data_Format 
-  * @{
-  */
-
-#define I2S_DataFormat_16b              ((uint16_t)0x0000)
-#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
-#define I2S_DataFormat_24b              ((uint16_t)0x0003)
-#define I2S_DataFormat_32b              ((uint16_t)0x0005)
-#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
-                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
-                                    ((FORMAT) == I2S_DataFormat_24b) || \
-                                    ((FORMAT) == I2S_DataFormat_32b))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2S_MCLK_Output 
-  * @{
-  */
-
-#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
-#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
-#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
-                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup I2S_Audio_Frequency 
-  * @{
-  */
-
-#define I2S_AudioFreq_192k               ((uint32_t)192000)
-#define I2S_AudioFreq_96k                ((uint32_t)96000)
-#define I2S_AudioFreq_48k                ((uint32_t)48000)
-#define I2S_AudioFreq_44k                ((uint32_t)44100)
-#define I2S_AudioFreq_32k                ((uint32_t)32000)
-#define I2S_AudioFreq_22k                ((uint32_t)22050)
-#define I2S_AudioFreq_16k                ((uint32_t)16000)
-#define I2S_AudioFreq_11k                ((uint32_t)11025)
-#define I2S_AudioFreq_8k                 ((uint32_t)8000)
-#define I2S_AudioFreq_Default            ((uint32_t)2)
-
-#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
-                                  ((FREQ) <= I2S_AudioFreq_192k)) || \
-                                 ((FREQ) == I2S_AudioFreq_Default))
-/**
-  * @}
-  */ 
-
-/** @defgroup I2S_Clock_Polarity 
-  * @{
-  */
-
-#define I2S_CPOL_Low                    ((uint16_t)0x0000)
-#define I2S_CPOL_High                   ((uint16_t)0x0008)
-#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
-                           ((CPOL) == I2S_CPOL_High))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_I2S_DMA_transfer_requests 
-  * @{
-  */
-
-#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
-#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
-#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_NSS_internal_software_management 
-  * @{
-  */
-
-#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
-#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
-#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
-                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_CRC_Transmit_Receive 
-  * @{
-  */
-
-#define SPI_CRC_Tx                      ((uint8_t)0x00)
-#define SPI_CRC_Rx                      ((uint8_t)0x01)
-#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_direction_transmit_receive 
-  * @{
-  */
-
-#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
-#define SPI_Direction_Tx                ((uint16_t)0x4000)
-#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
-                                     ((DIRECTION) == SPI_Direction_Tx))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_I2S_interrupts_definition 
-  * @{
-  */
-
-#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
-#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
-#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
-#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
-                                 ((IT) == SPI_I2S_IT_RXNE) || \
-                                 ((IT) == SPI_I2S_IT_ERR))
-#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
-#define SPI_IT_MODF                     ((uint8_t)0x55)
-#define SPI_IT_CRCERR                   ((uint8_t)0x54)
-#define I2S_IT_UDR                      ((uint8_t)0x53)
-#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
-#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
-                               ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \
-                               ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_I2S_flags_definition 
-  * @{
-  */
-
-#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
-#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
-#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
-#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
-#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
-#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
-#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
-#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
-#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
-#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
-                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
-                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
-                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
-/**
-  * @}
-  */
-
-/** @defgroup SPI_CRC_polynomial 
-  * @{
-  */
-
-#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup SPI_Exported_Functions
-  * @{
-  */
-
-void SPI_I2S_DeInit(SPI_TypeDef* SPIx);
-void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
-void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
-void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
-void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
-void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
-void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
-void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
-void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
-void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
-uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
-void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
-void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
-void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
-void SPI_TransmitCRC(SPI_TypeDef* SPIx);
-void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
-uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
-uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
-void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
-FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
-void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
-ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
-void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_SPI_H */
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_tim.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_tim.c
deleted file mode 100644
index bfb4dd1da..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_tim.c
+++ /dev/null
@@ -1,2890 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_tim.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the TIM firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_tim.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup TIM 
-  * @brief TIM driver modules
-  * @{
-  */
-
-/** @defgroup TIM_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_Defines
-  * @{
-  */
-
-/* ---------------------- TIM registers bit mask ------------------------ */
-#define SMCR_ETR_Mask               ((uint16_t)0x00FF) 
-#define CCMR_Offset                 ((uint16_t)0x0018)
-#define CCER_CCE_Set                ((uint16_t)0x0001)  
-#define	CCER_CCNE_Set               ((uint16_t)0x0004) 
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_FunctionPrototypes
-  * @{
-  */
-
-static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter);
-static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter);
-static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter);
-static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter);
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @retval None
-  */
-void TIM_DeInit(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
- 
-  if (TIMx == TIM1)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
-  }     
-  else if (TIMx == TIM2)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
-  }
-  else if (TIMx == TIM3)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
-  }
-  else if (TIMx == TIM4)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
-  } 
-  else if (TIMx == TIM5)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
-  } 
-  else if (TIMx == TIM6)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
-  } 
-  else if (TIMx == TIM7)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
-  } 
-  else if (TIMx == TIM8)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
-  }
-  else if (TIMx == TIM9)
-  {      
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
-   }  
-  else if (TIMx == TIM10)
-  {      
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
-  }  
-  else if (TIMx == TIM11) 
-  {     
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
-  }  
-  else if (TIMx == TIM12)
-  {      
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
-  }  
-  else if (TIMx == TIM13) 
-  {       
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
-  }
-  else if (TIMx == TIM14) 
-  {       
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
-  }        
-  else if (TIMx == TIM15)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
-  } 
-  else if (TIMx == TIM16)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
-  } 
-  else
-  {
-    if (TIMx == TIM17)
-    {
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
-      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
-    }  
-  }
-}
-
-/**
-  * @brief  Initializes the TIMx Time Base Unit peripheral according to 
-  *         the specified parameters in the TIM_TimeBaseInitStruct.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
-  *         structure that contains the configuration information for the 
-  *         specified TIM peripheral.
-  * @retval None
-  */
-void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
-{
-  uint16_t tmpcr1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
-  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
-  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
-
-  tmpcr1 = TIMx->CR1;  
-
-  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
-     (TIMx == TIM4) || (TIMx == TIM5)) 
-  {
-    /* Select the Counter Mode */
-    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
-    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
-  }
- 
-  if((TIMx != TIM6) && (TIMx != TIM7))
-  {
-    /* Set the clock division */
-    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
-    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
-  }
-
-  TIMx->CR1 = tmpcr1;
-
-  /* Set the Autoreload value */
-  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
- 
-  /* Set the Prescaler value */
-  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
-    
-  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
-  {
-    /* Set the Repetition Counter value */
-    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
-  }
-
-  /* Generate an update event to reload the Prescaler and the Repetition counter
-     values immediately */
-  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
-}
-
-/**
-  * @brief  Initializes the TIMx Channel1 according to the specified
-  *         parameters in the TIM_OCInitStruct.
-  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-  *         that contains the configuration information for the specified TIM peripheral.
-  * @retval None
-  */
-void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
- /* Disable the Channel 1: Reset the CC1E Bit */
-  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx->CCER;
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx->CR2;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmrx = TIMx->CCMR1;
-    
-  /* Reset the Output Compare Mode Bits */
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
-
-  /* Select the Output Compare Mode */
-  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
-  
-  /* Reset the Output Polarity level */
-  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
-  /* Set the Output Compare Polarity */
-  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
-  
-  /* Set the Output State */
-  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
-    
-  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
-     (TIMx == TIM16)|| (TIMx == TIM17))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
-    /* Set the Output N Polarity */
-    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
-    
-    /* Reset the Output N State */
-    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
-    /* Set the Output N State */
-    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
-    
-    /* Reset the Output Compare and Output Compare N IDLE State */
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
-    
-    /* Set the Output Idle state */
-    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
-    /* Set the Output N Idle state */
-    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
-  }
-  /* Write to TIMx CR2 */
-  TIMx->CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR1 */
-  TIMx->CCMR1 = tmpccmrx;
-
-  /* Set the Capture Compare Register value */
-  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
- 
-  /* Write to TIMx CCER */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Initializes the TIMx Channel2 according to the specified
-  *         parameters in the TIM_OCInitStruct.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
-  *         the TIM peripheral.
-  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-  *         that contains the configuration information for the specified TIM peripheral.
-  * @retval None
-  */
-void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
-   /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
-  
-  /* Get the TIMx CCER register value */  
-  tmpccer = TIMx->CCER;
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx->CR2;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmrx = TIMx->CCMR1;
-    
-  /* Reset the Output Compare mode and Capture/Compare selection Bits */
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
-  
-  /* Reset the Output Polarity level */
-  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
-  /* Set the Output Compare Polarity */
-  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
-  
-  /* Set the Output State */
-  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
-    
-  if((TIMx == TIM1) || (TIMx == TIM8))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
-    /* Set the Output N Polarity */
-    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
-    
-    /* Reset the Output N State */
-    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
-    /* Set the Output N State */
-    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
-    
-    /* Reset the Output Compare and Output Compare N IDLE State */
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
-    
-    /* Set the Output Idle state */
-    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
-    /* Set the Output N Idle state */
-    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
-  }
-  /* Write to TIMx CR2 */
-  TIMx->CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR1 */
-  TIMx->CCMR1 = tmpccmrx;
-
-  /* Set the Capture Compare Register value */
-  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
-  
-  /* Write to TIMx CCER */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Initializes the TIMx Channel3 according to the specified
-  *         parameters in the TIM_OCInitStruct.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-  *         that contains the configuration information for the specified TIM peripheral.
-  * @retval None
-  */
-void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx->CCER;
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx->CR2;
-  
-  /* Get the TIMx CCMR2 register value */
-  tmpccmrx = TIMx->CCMR2;
-    
-  /* Reset the Output Compare mode and Capture/Compare selection Bits */
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
-  
-  /* Reset the Output Polarity level */
-  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
-  /* Set the Output Compare Polarity */
-  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
-  
-  /* Set the Output State */
-  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
-    
-  if((TIMx == TIM1) || (TIMx == TIM8))
-  {
-    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
-    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
-    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
-    
-    /* Reset the Output N Polarity level */
-    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
-    /* Set the Output N Polarity */
-    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
-    /* Reset the Output N State */
-    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
-    
-    /* Set the Output N State */
-    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
-    /* Reset the Output Compare and Output Compare N IDLE State */
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
-    /* Set the Output Idle state */
-    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
-    /* Set the Output N Idle state */
-    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
-  }
-  /* Write to TIMx CR2 */
-  TIMx->CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR2 */
-  TIMx->CCMR2 = tmpccmrx;
-
-  /* Set the Capture Compare Register value */
-  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
-  
-  /* Write to TIMx CCER */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Initializes the TIMx Channel4 according to the specified
-  *         parameters in the TIM_OCInitStruct.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
-  *         that contains the configuration information for the specified TIM peripheral.
-  * @retval None
-  */
-void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
-   
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
-  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
-  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
-  /* Disable the Channel 2: Reset the CC4E Bit */
-  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx->CCER;
-  /* Get the TIMx CR2 register value */
-  tmpcr2 =  TIMx->CR2;
-  
-  /* Get the TIMx CCMR2 register value */
-  tmpccmrx = TIMx->CCMR2;
-    
-  /* Reset the Output Compare mode and Capture/Compare selection Bits */
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
-  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
-  
-  /* Select the Output Compare Mode */
-  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
-  
-  /* Reset the Output Polarity level */
-  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
-  /* Set the Output Compare Polarity */
-  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
-  
-  /* Set the Output State */
-  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
-    
-  if((TIMx == TIM1) || (TIMx == TIM8))
-  {
-    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
-    /* Reset the Output Compare IDLE State */
-    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
-    /* Set the Output Idle state */
-    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
-  }
-  /* Write to TIMx CR2 */
-  TIMx->CR2 = tmpcr2;
-  
-  /* Write to TIMx CCMR2 */  
-  TIMx->CCMR2 = tmpccmrx;
-
-  /* Set the Capture Compare Register value */
-  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
-  
-  /* Write to TIMx CCER */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Initializes the TIM peripheral according to the specified
-  *         parameters in the TIM_ICInitStruct.
-  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
-  *         that contains the configuration information for the specified TIM peripheral.
-  * @retval None
-  */
-void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
-  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
-  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
-  
-  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
-     (TIMx == TIM4) ||(TIMx == TIM5))
-  {
-    assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
-  }
-  else
-  {
-    assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
-  }
-  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
-  {
-    assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-    /* TI1 Configuration */
-    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
-               TIM_ICInitStruct->TIM_ICSelection,
-               TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-  }
-  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
-  {
-    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-    /* TI2 Configuration */
-    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
-               TIM_ICInitStruct->TIM_ICSelection,
-               TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-  }
-  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
-  {
-    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-    /* TI3 Configuration */
-    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
-               TIM_ICInitStruct->TIM_ICSelection,
-               TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-  }
-  else
-  {
-    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-    /* TI4 Configuration */
-    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
-               TIM_ICInitStruct->TIM_ICSelection,
-               TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-  }
-}
-
-/**
-  * @brief  Configures the TIM peripheral according to the specified
-  *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
-  *         that contains the configuration information for the specified TIM peripheral.
-  * @retval None
-  */
-void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
-  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  /* Select the Opposite Input Polarity */
-  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
-  {
-    icoppositepolarity = TIM_ICPolarity_Falling;
-  }
-  else
-  {
-    icoppositepolarity = TIM_ICPolarity_Rising;
-  }
-  /* Select the Opposite Input */
-  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
-  {
-    icoppositeselection = TIM_ICSelection_IndirectTI;
-  }
-  else
-  {
-    icoppositeselection = TIM_ICSelection_DirectTI;
-  }
-  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
-  {
-    /* TI1 Configuration */
-    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
-               TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-    /* TI2 Configuration */
-    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-  }
-  else
-  { 
-    /* TI2 Configuration */
-    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
-               TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-    /* TI1 Configuration */
-    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
-    /* Set the Input Capture Prescaler value */
-    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
-  }
-}
-
-/**
-  * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,
-  *         the OSSR State and the AOE(automatic output enable).
-  * @param  TIMx: where x can be  1 or 8 to select the TIM 
-  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
-  *         contains the BDTR Register configuration  information for the TIM peripheral.
-  * @retval None
-  */
-void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
-  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
-  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
-  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
-  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
-  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
-  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
-  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
-     the OSSI State, the dead time value and the Automatic Output Enable Bit */
-  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
-             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
-             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
-             TIM_BDTRInitStruct->TIM_AutomaticOutput;
-}
-
-/**
-  * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
-  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
-  *         structure which will be initialized.
-  * @retval None
-  */
-void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
-{
-  /* Set the default configuration */
-  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
-  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
-  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
-  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
-  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
-}
-
-/**
-  * @brief  Fills each TIM_OCInitStruct member with its default value.
-  * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
-  *         be initialized.
-  * @retval None
-  */
-void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
-{
-  /* Set the default configuration */
-  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
-  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
-  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
-  TIM_OCInitStruct->TIM_Pulse = 0x0000;
-  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
-  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
-  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
-  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
-}
-
-/**
-  * @brief  Fills each TIM_ICInitStruct member with its default value.
-  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
-  *         be initialized.
-  * @retval None
-  */
-void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
-{
-  /* Set the default configuration */
-  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
-  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
-  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
-  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
-  TIM_ICInitStruct->TIM_ICFilter = 0x00;
-}
-
-/**
-  * @brief  Fills each TIM_BDTRInitStruct member with its default value.
-  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
-  *         will be initialized.
-  * @retval None
-  */
-void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
-{
-  /* Set the default configuration */
-  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
-  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
-  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
-  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
-  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
-  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
-  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
-}
-
-/**
-  * @brief  Enables or disables the specified TIM peripheral.
-  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
-  * @param  NewState: new state of the TIMx peripheral.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the TIM Counter */
-    TIMx->CR1 |= TIM_CR1_CEN;
-  }
-  else
-  {
-    /* Disable the TIM Counter */
-    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
-  }
-}
-
-/**
-  * @brief  Enables or disables the TIM peripheral Main Outputs.
-  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.
-  * @param  NewState: new state of the TIM peripheral Main Outputs.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the TIM Main Output */
-    TIMx->BDTR |= TIM_BDTR_MOE;
-  }
-  else
-  {
-    /* Disable the TIM Main Output */
-    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
-  }  
-}
-
-/**
-  * @brief  Enables or disables the specified TIM interrupts.
-  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.
-  * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
-  *   This parameter can be any combination of the following values:
-  *     @arg TIM_IT_Update: TIM update Interrupt source
-  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
-  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
-  *     @arg TIM_IT_Break: TIM Break Interrupt source
-  * @note 
-  *   - TIM6 and TIM7 can only generate an update interrupt.
-  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
-  *      TIM_IT_CC2 or TIM_IT_Trigger. 
-  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
-  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
-  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
-  * @param  NewState: new state of the TIM interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_IT(TIM_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the Interrupt sources */
-    TIMx->DIER |= TIM_IT;
-  }
-  else
-  {
-    /* Disable the Interrupt sources */
-    TIMx->DIER &= (uint16_t)~TIM_IT;
-  }
-}
-
-/**
-  * @brief  Configures the TIMx event to be generate by software.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_EventSource: specifies the event source.
-  *   This parameter can be one or more of the following values:	   
-  *     @arg TIM_EventSource_Update: Timer update Event source
-  *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
-  *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
-  *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
-  *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
-  *     @arg TIM_EventSource_COM: Timer COM event source  
-  *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
-  *     @arg TIM_EventSource_Break: Timer Break event source
-  * @note 
-  *   - TIM6 and TIM7 can only generate an update event. 
-  *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
-  * @retval None
-  */
-void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
-  
-  /* Set the event sources */
-  TIMx->EGR = TIM_EventSource;
-}
-
-/**
-  * @brief  Configures the TIMx's DMA interface.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
-  *   the TIM peripheral.
-  * @param  TIM_DMABase: DMA Base address.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
-  *          TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
-  *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
-  *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
-  *          TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
-  *          TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
-  *          TIM_DMABase_DCR.
-  * @param  TIM_DMABurstLength: DMA Burst length.
-  *   This parameter can be one value between:
-  *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
-  * @retval None
-  */
-void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
-  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
-  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
-  /* Set the DMA Base and the DMA Burst Length */
-  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
-}
-
-/**
-  * @brief  Enables or disables the TIMx's DMA Requests.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17 
-  *   to select the TIM peripheral. 
-  * @param  TIM_DMASource: specifies the DMA Request sources.
-  *   This parameter can be any combination of the following values:
-  *     @arg TIM_DMA_Update: TIM update Interrupt source
-  *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
-  *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
-  *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
-  *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
-  *     @arg TIM_DMA_COM: TIM Commutation DMA source
-  *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
-  * @param  NewState: new state of the DMA Request sources.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST9_PERIPH(TIMx));
-  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the DMA sources */
-    TIMx->DIER |= TIM_DMASource; 
-  }
-  else
-  {
-    /* Disable the DMA sources */
-    TIMx->DIER &= (uint16_t)~TIM_DMASource;
-  }
-}
-
-/**
-  * @brief  Configures the TIMx internal Clock
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
-  *         to select the TIM peripheral.
-  * @retval None
-  */
-void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  /* Disable slave mode to clock the prescaler directly with the internal clock */
-  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
-}
-
-/**
-  * @brief  Configures the TIMx Internal Trigger as External Clock
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_ITRSource: Trigger source.
-  *   This parameter can be one of the following values:
-  * @param  TIM_TS_ITR0: Internal Trigger 0
-  * @param  TIM_TS_ITR1: Internal Trigger 1
-  * @param  TIM_TS_ITR2: Internal Trigger 2
-  * @param  TIM_TS_ITR3: Internal Trigger 3
-  * @retval None
-  */
-void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
-  /* Select the Internal Trigger */
-  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
-  /* Select the External clock mode1 */
-  TIMx->SMCR |= TIM_SlaveMode_External1;
-}
-
-/**
-  * @brief  Configures the TIMx Trigger as External Clock
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_TIxExternalCLKSource: Trigger source.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
-  *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
-  *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
-  * @param  TIM_ICPolarity: specifies the TIx Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Rising
-  *     @arg TIM_ICPolarity_Falling
-  * @param  ICFilter : specifies the filter value.
-  *   This parameter must be a value between 0x0 and 0xF.
-  * @retval None
-  */
-void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
-                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
-  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
-  assert_param(IS_TIM_IC_FILTER(ICFilter));
-  /* Configure the Timer Input Clock Source */
-  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
-  {
-    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
-  }
-  else
-  {
-    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
-  }
-  /* Select the Trigger source */
-  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
-  /* Select the External clock mode1 */
-  TIMx->SMCR |= TIM_SlaveMode_External1;
-}
-
-/**
-  * @brief  Configures the External clock Mode1
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
-  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
-  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
-  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
-  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
-  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
-  * @param  ExtTRGFilter: External Trigger Filter.
-  *   This parameter must be a value between 0x00 and 0x0F
-  * @retval None
-  */
-void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
-                             uint16_t ExtTRGFilter)
-{
-  uint16_t tmpsmcr = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-  /* Configure the ETR Clock source */
-  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
-  
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx->SMCR;
-  /* Reset the SMS Bits */
-  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
-  /* Select the External clock mode1 */
-  tmpsmcr |= TIM_SlaveMode_External1;
-  /* Select the Trigger selection : ETRF */
-  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
-  tmpsmcr |= TIM_TS_ETRF;
-  /* Write to TIMx SMCR */
-  TIMx->SMCR = tmpsmcr;
-}
-
-/**
-  * @brief  Configures the External clock Mode2
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
-  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
-  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
-  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
-  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
-  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
-  * @param  ExtTRGFilter: External Trigger Filter.
-  *   This parameter must be a value between 0x00 and 0x0F
-  * @retval None
-  */
-void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
-                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-  /* Configure the ETR Clock source */
-  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
-  /* Enable the External clock mode2 */
-  TIMx->SMCR |= TIM_SMCR_ECE;
-}
-
-/**
-  * @brief  Configures the TIMx External Trigger (ETR).
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
-  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
-  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
-  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
-  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
-  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
-  * @param  ExtTRGFilter: External Trigger Filter.
-  *   This parameter must be a value between 0x00 and 0x0F
-  * @retval None
-  */
-void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
-                   uint16_t ExtTRGFilter)
-{
-  uint16_t tmpsmcr = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
-  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
-  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
-  tmpsmcr = TIMx->SMCR;
-  /* Reset the ETR Bits */
-  tmpsmcr &= SMCR_ETR_Mask;
-  /* Set the Prescaler, the Filter value and the Polarity */
-  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
-  /* Write to TIMx SMCR */
-  TIMx->SMCR = tmpsmcr;
-}
-
-/**
-  * @brief  Configures the TIMx Prescaler.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  Prescaler: specifies the Prescaler Register value
-  * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
-  *   This parameter can be one of the following values:
-  *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
-  *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
-  * @retval None
-  */
-void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
-  /* Set the Prescaler value */
-  TIMx->PSC = Prescaler;
-  /* Set or reset the UG Bit */
-  TIMx->EGR = TIM_PSCReloadMode;
-}
-
-/**
-  * @brief  Specifies the TIMx Counter Mode to be used.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_CounterMode: specifies the Counter Mode to be used
-  *   This parameter can be one of the following values:
-  *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
-  *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
-  *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
-  *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
-  *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
-  * @retval None
-  */
-void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
-{
-  uint16_t tmpcr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
-  tmpcr1 = TIMx->CR1;
-  /* Reset the CMS and DIR Bits */
-  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
-  /* Set the Counter Mode */
-  tmpcr1 |= TIM_CounterMode;
-  /* Write to TIMx CR1 register */
-  TIMx->CR1 = tmpcr1;
-}
-
-/**
-  * @brief  Selects the Input Trigger source
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_InputTriggerSource: The Input Trigger source.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_TS_ITR0: Internal Trigger 0
-  *     @arg TIM_TS_ITR1: Internal Trigger 1
-  *     @arg TIM_TS_ITR2: Internal Trigger 2
-  *     @arg TIM_TS_ITR3: Internal Trigger 3
-  *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
-  *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
-  *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
-  *     @arg TIM_TS_ETRF: External Trigger input
-  * @retval None
-  */
-void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
-{
-  uint16_t tmpsmcr = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx->SMCR;
-  /* Reset the TS Bits */
-  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
-  /* Set the Input Trigger source */
-  tmpsmcr |= TIM_InputTriggerSource;
-  /* Write to TIMx SMCR */
-  TIMx->SMCR = tmpsmcr;
-}
-
-/**
-  * @brief  Configures the TIMx Encoder Interface.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
-  *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
-  *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
-  *                                on the level of the other input.
-  * @param  TIM_IC1Polarity: specifies the IC1 Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Falling: IC Falling edge.
-  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
-  * @param  TIM_IC2Polarity: specifies the IC2 Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Falling: IC Falling edge.
-  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
-  * @retval None
-  */
-void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
-                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
-{
-  uint16_t tmpsmcr = 0;
-  uint16_t tmpccmr1 = 0;
-  uint16_t tmpccer = 0;
-    
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
-  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
-  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
-  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
-
-  /* Get the TIMx SMCR register value */
-  tmpsmcr = TIMx->SMCR;
-  
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx->CCMR1;
-  
-  /* Get the TIMx CCER register value */
-  tmpccer = TIMx->CCER;
-  
-  /* Set the encoder Mode */
-  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
-  tmpsmcr |= TIM_EncoderMode;
-  
-  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
-  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
-  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
-  
-  /* Set the TI1 and the TI2 Polarities */
-  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
-  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
-  
-  /* Write to TIMx SMCR */
-  TIMx->SMCR = tmpsmcr;
-  /* Write to TIMx CCMR1 */
-  TIMx->CCMR1 = tmpccmr1;
-  /* Write to TIMx CCER */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Forces the TIMx output 1 waveform to active or inactive level.
-  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
-  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
-  * @retval None
-  */
-void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC1M Bits */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
-  /* Configure The Forced output Mode */
-  tmpccmr1 |= TIM_ForcedAction;
-  /* Write to TIMx CCMR1 register */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Forces the TIMx output 2 waveform to active or inactive level.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
-  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
-  * @retval None
-  */
-void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC2M Bits */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
-  /* Configure The Forced output Mode */
-  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
-  /* Write to TIMx CCMR1 register */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Forces the TIMx output 3 waveform to active or inactive level.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
-  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
-  * @retval None
-  */
-void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC1M Bits */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
-  /* Configure The Forced output Mode */
-  tmpccmr2 |= TIM_ForcedAction;
-  /* Write to TIMx CCMR2 register */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Forces the TIMx output 4 waveform to active or inactive level.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
-  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
-  * @retval None
-  */
-void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC2M Bits */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
-  /* Configure The Forced output Mode */
-  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
-  /* Write to TIMx CCMR2 register */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Enables or disables TIMx peripheral Preload register on ARR.
-  * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.
-  * @param  NewState: new state of the TIMx peripheral Preload register
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the ARR Preload Bit */
-    TIMx->CR1 |= TIM_CR1_ARPE;
-  }
-  else
-  {
-    /* Reset the ARR Preload Bit */
-    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
-  }
-}
-
-/**
-  * @brief  Selects the TIM peripheral Commutation event.
-  * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral
-  * @param  NewState: new state of the Commutation event.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the COM Bit */
-    TIMx->CR2 |= TIM_CR2_CCUS;
-  }
-  else
-  {
-    /* Reset the COM Bit */
-    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
-  }
-}
-
-/**
-  * @brief  Selects the TIMx peripheral Capture Compare DMA source.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select 
-  *         the TIM peripheral.
-  * @param  NewState: new state of the Capture Compare DMA source
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the CCDS Bit */
-    TIMx->CR2 |= TIM_CR2_CCDS;
-  }
-  else
-  {
-    /* Reset the CCDS Bit */
-    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
-  }
-}
-
-/**
-  * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
-  * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15 
-  *         to select the TIMx peripheral
-  * @param  NewState: new state of the Capture Compare Preload Control bit
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
-{ 
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the CCPC Bit */
-    TIMx->CR2 |= TIM_CR2_CCPC;
-  }
-  else
-  {
-    /* Reset the CCPC Bit */
-    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
-  }
-}
-
-/**
-  * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
-  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPreload_Enable
-  *     @arg TIM_OCPreload_Disable
-  * @retval None
-  */
-void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC1PE Bit */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr1 |= TIM_OCPreload;
-  /* Write to TIMx CCMR1 register */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
-  *         the TIM peripheral.
-  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPreload_Enable
-  *     @arg TIM_OCPreload_Disable
-  * @retval None
-  */
-void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC2PE Bit */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
-  /* Write to TIMx CCMR1 register */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPreload_Enable
-  *     @arg TIM_OCPreload_Disable
-  * @retval None
-  */
-void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC3PE Bit */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr2 |= TIM_OCPreload;
-  /* Write to TIMx CCMR2 register */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPreload_Enable
-  *     @arg TIM_OCPreload_Disable
-  * @retval None
-  */
-void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC4PE Bit */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
-  /* Enable or Disable the Output Compare Preload feature */
-  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
-  /* Write to TIMx CCMR2 register */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Configures the TIMx Output Compare 1 Fast feature.
-  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
-  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
-  * @retval None
-  */
-void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC1FE Bit */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr1 |= TIM_OCFast;
-  /* Write to TIMx CCMR1 */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Configures the TIMx Output Compare 2 Fast feature.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select 
-  *         the TIM peripheral.
-  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
-  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
-  * @retval None
-  */
-void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-  /* Get the TIMx CCMR1 register value */
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC2FE Bit */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
-  /* Write to TIMx CCMR1 */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Configures the TIMx Output Compare 3 Fast feature.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
-  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
-  * @retval None
-  */
-void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-  /* Get the TIMx CCMR2 register value */
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC3FE Bit */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr2 |= TIM_OCFast;
-  /* Write to TIMx CCMR2 */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Configures the TIMx Output Compare 4 Fast feature.
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
-  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
-  * @retval None
-  */
-void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
-  /* Get the TIMx CCMR2 register value */
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC4FE Bit */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
-  /* Enable or Disable the Output Compare Fast Bit */
-  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
-  /* Write to TIMx CCMR2 */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Clears or safeguards the OCREF1 signal on an external event
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCClear_Enable: TIM Output clear enable
-  *     @arg TIM_OCClear_Disable: TIM Output clear disable
-  * @retval None
-  */
-void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-
-  tmpccmr1 = TIMx->CCMR1;
-
-  /* Reset the OC1CE Bit */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr1 |= TIM_OCClear;
-  /* Write to TIMx CCMR1 register */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Clears or safeguards the OCREF2 signal on an external event
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCClear_Enable: TIM Output clear enable
-  *     @arg TIM_OCClear_Disable: TIM Output clear disable
-  * @retval None
-  */
-void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
-{
-  uint16_t tmpccmr1 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-  tmpccmr1 = TIMx->CCMR1;
-  /* Reset the OC2CE Bit */
-  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
-  /* Write to TIMx CCMR1 register */
-  TIMx->CCMR1 = tmpccmr1;
-}
-
-/**
-  * @brief  Clears or safeguards the OCREF3 signal on an external event
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCClear_Enable: TIM Output clear enable
-  *     @arg TIM_OCClear_Disable: TIM Output clear disable
-  * @retval None
-  */
-void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC3CE Bit */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr2 |= TIM_OCClear;
-  /* Write to TIMx CCMR2 register */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Clears or safeguards the OCREF4 signal on an external event
-  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCClear_Enable: TIM Output clear enable
-  *     @arg TIM_OCClear_Disable: TIM Output clear disable
-  * @retval None
-  */
-void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
-{
-  uint16_t tmpccmr2 = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
-  tmpccmr2 = TIMx->CCMR2;
-  /* Reset the OC4CE Bit */
-  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
-  /* Enable or Disable the Output Compare Clear Bit */
-  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
-  /* Write to TIMx CCMR2 register */
-  TIMx->CCMR2 = tmpccmr2;
-}
-
-/**
-  * @brief  Configures the TIMx channel 1 polarity.
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_OCPolarity: specifies the OC1 Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPolarity_High: Output Compare active high
-  *     @arg TIM_OCPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
-{
-  uint16_t tmpccer = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC1P Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
-  tmpccer |= TIM_OCPolarity;
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configures the TIMx Channel 1N polarity.
-  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
-  * @param  TIM_OCNPolarity: specifies the OC1N Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCNPolarity_High: Output Compare active high
-  *     @arg TIM_OCNPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
-{
-  uint16_t tmpccer = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-   
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC1NP Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
-  tmpccer |= TIM_OCNPolarity;
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configures the TIMx channel 2 polarity.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_OCPolarity: specifies the OC2 Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPolarity_High: Output Compare active high
-  *     @arg TIM_OCPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
-{
-  uint16_t tmpccer = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC2P Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
-  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configures the TIMx Channel 2N polarity.
-  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
-  * @param  TIM_OCNPolarity: specifies the OC2N Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCNPolarity_High: Output Compare active high
-  *     @arg TIM_OCNPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
-{
-  uint16_t tmpccer = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-  
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC2NP Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
-  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configures the TIMx channel 3 polarity.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCPolarity: specifies the OC3 Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPolarity_High: Output Compare active high
-  *     @arg TIM_OCPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
-{
-  uint16_t tmpccer = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC3P Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
-  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configures the TIMx Channel 3N polarity.
-  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
-  * @param  TIM_OCNPolarity: specifies the OC3N Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCNPolarity_High: Output Compare active high
-  *     @arg TIM_OCNPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
-{
-  uint16_t tmpccer = 0;
- 
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
-  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
-    
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC3NP Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
-  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configures the TIMx channel 4 polarity.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_OCPolarity: specifies the OC4 Polarity
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCPolarity_High: Output Compare active high
-  *     @arg TIM_OCPolarity_Low: Output Compare active low
-  * @retval None
-  */
-void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
-{
-  uint16_t tmpccer = 0;
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
-  tmpccer = TIMx->CCER;
-  /* Set or Reset the CC4P Bit */
-  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
-  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
-  /* Write to TIMx CCER register */
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Enables or disables the TIM Capture Compare Channel x.
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_Channel: specifies the TIM Channel
-  *   This parameter can be one of the following values:
-  *     @arg TIM_Channel_1: TIM Channel 1
-  *     @arg TIM_Channel_2: TIM Channel 2
-  *     @arg TIM_Channel_3: TIM Channel 3
-  *     @arg TIM_Channel_4: TIM Channel 4
-  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
-  *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
-  * @retval None
-  */
-void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
-{
-  uint16_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_CCX(TIM_CCx));
-
-  tmp = CCER_CCE_Set << TIM_Channel;
-
-  /* Reset the CCxE Bit */
-  TIMx->CCER &= (uint16_t)~ tmp;
-
-  /* Set or reset the CCxE Bit */ 
-  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
-}
-
-/**
-  * @brief  Enables or disables the TIM Capture Compare Channel xN.
-  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.
-  * @param  TIM_Channel: specifies the TIM Channel
-  *   This parameter can be one of the following values:
-  *     @arg TIM_Channel_1: TIM Channel 1
-  *     @arg TIM_Channel_2: TIM Channel 2
-  *     @arg TIM_Channel_3: TIM Channel 3
-  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
-  *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
-  * @retval None
-  */
-void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
-{
-  uint16_t tmp = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
-  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_CCXN(TIM_CCxN));
-
-  tmp = CCER_CCNE_Set << TIM_Channel;
-
-  /* Reset the CCxNE Bit */
-  TIMx->CCER &= (uint16_t) ~tmp;
-
-  /* Set or reset the CCxNE Bit */ 
-  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
-}
-
-/**
-  * @brief  Selects the TIM Output Compare Mode.
-  * @note   This function disables the selected channel before changing the Output
-  *         Compare Mode.
-  *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_Channel: specifies the TIM Channel
-  *   This parameter can be one of the following values:
-  *     @arg TIM_Channel_1: TIM Channel 1
-  *     @arg TIM_Channel_2: TIM Channel 2
-  *     @arg TIM_Channel_3: TIM Channel 3
-  *     @arg TIM_Channel_4: TIM Channel 4
-  * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OCMode_Timing
-  *     @arg TIM_OCMode_Active
-  *     @arg TIM_OCMode_Toggle
-  *     @arg TIM_OCMode_PWM1
-  *     @arg TIM_OCMode_PWM2
-  *     @arg TIM_ForcedAction_Active
-  *     @arg TIM_ForcedAction_InActive
-  * @retval None
-  */
-void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
-{
-  uint32_t tmp = 0;
-  uint16_t tmp1 = 0;
-
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_CHANNEL(TIM_Channel));
-  assert_param(IS_TIM_OCM(TIM_OCMode));
-
-  tmp = (uint32_t) TIMx;
-  tmp += CCMR_Offset;
-
-  tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
-
-  /* Disable the Channel: Reset the CCxE Bit */
-  TIMx->CCER &= (uint16_t) ~tmp1;
-
-  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
-  {
-    tmp += (TIM_Channel>>1);
-
-    /* Reset the OCxM bits in the CCMRx register */
-    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
-   
-    /* Configure the OCxM bits in the CCMRx register */
-    *(__IO uint32_t *) tmp |= TIM_OCMode;
-  }
-  else
-  {
-    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
-
-    /* Reset the OCxM bits in the CCMRx register */
-    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
-    
-    /* Configure the OCxM bits in the CCMRx register */
-    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
-  }
-}
-
-/**
-  * @brief  Enables or Disables the TIMx Update event.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  NewState: new state of the TIMx UDIS bit
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the Update Disable Bit */
-    TIMx->CR1 |= TIM_CR1_UDIS;
-  }
-  else
-  {
-    /* Reset the Update Disable Bit */
-    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
-  }
-}
-
-/**
-  * @brief  Configures the TIMx Update Request Interrupt source.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_UpdateSource: specifies the Update source.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
-                                       or the setting of UG bit, or an update generation
-                                       through the slave mode controller.
-  *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
-  * @retval None
-  */
-void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
-  if (TIM_UpdateSource != TIM_UpdateSource_Global)
-  {
-    /* Set the URS Bit */
-    TIMx->CR1 |= TIM_CR1_URS;
-  }
-  else
-  {
-    /* Reset the URS Bit */
-    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
-  }
-}
-
-/**
-  * @brief  Enables or disables the TIMx's Hall sensor interface.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  NewState: new state of the TIMx Hall sensor interface.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Set the TI1S Bit */
-    TIMx->CR2 |= TIM_CR2_TI1S;
-  }
-  else
-  {
-    /* Reset the TI1S Bit */
-    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
-  }
-}
-
-/**
-  * @brief  Selects the TIMx's One Pulse Mode.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_OPMode: specifies the OPM Mode to be used.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_OPMode_Single
-  *     @arg TIM_OPMode_Repetitive
-  * @retval None
-  */
-void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
-  /* Reset the OPM Bit */
-  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
-  /* Configure the OPM Mode */
-  TIMx->CR1 |= TIM_OPMode;
-}
-
-/**
-  * @brief  Selects the TIMx Trigger Output Mode.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_TRGOSource: specifies the Trigger Output source.
-  *   This paramter can be one of the following values:
-  *
-  *  - For all TIMx
-  *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
-  *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
-  *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
-  *
-  *  - For all TIMx except TIM6 and TIM7
-  *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
-  *                              is to be set, as soon as a capture or compare match occurs (TRGO).
-  *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
-  *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
-  *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
-  *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
-  *
-  * @retval None
-  */
-void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
-  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
-  /* Reset the MMS Bits */
-  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
-  /* Select the TRGO source */
-  TIMx->CR2 |=  TIM_TRGOSource;
-}
-
-/**
-  * @brief  Selects the TIMx Slave Mode.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
-  *                               the counter and triggers an update of the registers.
-  *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
-  *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
-  *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
-  * @retval None
-  */
-void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
- /* Reset the SMS Bits */
-  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
-  /* Select the Slave Mode */
-  TIMx->SMCR |= TIM_SlaveMode;
-}
-
-/**
-  * @brief  Sets or Resets the TIMx Master/Slave Mode.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
-  *                                      and its slaves (through TRGO).
-  *     @arg TIM_MasterSlaveMode_Disable: No action
-  * @retval None
-  */
-void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
-  /* Reset the MSM Bit */
-  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
-  
-  /* Set or Reset the MSM Bit */
-  TIMx->SMCR |= TIM_MasterSlaveMode;
-}
-
-/**
-  * @brief  Sets the TIMx Counter Register value
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  Counter: specifies the Counter register new value.
-  * @retval None
-  */
-void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  /* Set the Counter Register value */
-  TIMx->CNT = Counter;
-}
-
-/**
-  * @brief  Sets the TIMx Autoreload Register value
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  Autoreload: specifies the Autoreload register new value.
-  * @retval None
-  */
-void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  /* Set the Autoreload Register value */
-  TIMx->ARR = Autoreload;
-}
-
-/**
-  * @brief  Sets the TIMx Capture Compare1 Register value
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  Compare1: specifies the Capture Compare1 register new value.
-  * @retval None
-  */
-void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  /* Set the Capture Compare1 Register value */
-  TIMx->CCR1 = Compare1;
-}
-
-/**
-  * @brief  Sets the TIMx Capture Compare2 Register value
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  Compare2: specifies the Capture Compare2 register new value.
-  * @retval None
-  */
-void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  /* Set the Capture Compare2 Register value */
-  TIMx->CCR2 = Compare2;
-}
-
-/**
-  * @brief  Sets the TIMx Capture Compare3 Register value
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  Compare3: specifies the Capture Compare3 register new value.
-  * @retval None
-  */
-void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  /* Set the Capture Compare3 Register value */
-  TIMx->CCR3 = Compare3;
-}
-
-/**
-  * @brief  Sets the TIMx Capture Compare4 Register value
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  Compare4: specifies the Capture Compare4 register new value.
-  * @retval None
-  */
-void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  /* Set the Capture Compare4 Register value */
-  TIMx->CCR4 = Compare4;
-}
-
-/**
-  * @brief  Sets the TIMx Input Capture 1 prescaler.
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPSC_DIV1: no prescaler
-  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
-  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
-  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
-  * @retval None
-  */
-void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-  /* Reset the IC1PSC Bits */
-  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
-  /* Set the IC1PSC value */
-  TIMx->CCMR1 |= TIM_ICPSC;
-}
-
-/**
-  * @brief  Sets the TIMx Input Capture 2 prescaler.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPSC_DIV1: no prescaler
-  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
-  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
-  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
-  * @retval None
-  */
-void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-  /* Reset the IC2PSC Bits */
-  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
-  /* Set the IC2PSC value */
-  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
-}
-
-/**
-  * @brief  Sets the TIMx Input Capture 3 prescaler.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPSC_DIV1: no prescaler
-  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
-  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
-  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
-  * @retval None
-  */
-void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-  /* Reset the IC3PSC Bits */
-  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
-  /* Set the IC3PSC value */
-  TIMx->CCMR2 |= TIM_ICPSC;
-}
-
-/**
-  * @brief  Sets the TIMx Input Capture 4 prescaler.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPSC_DIV1: no prescaler
-  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
-  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
-  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
-  * @retval None
-  */
-void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
-  /* Reset the IC4PSC Bits */
-  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
-  /* Set the IC4PSC value */
-  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
-}
-
-/**
-  * @brief  Sets the TIMx Clock Division value.
-  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select 
-  *   the TIM peripheral.
-  * @param  TIM_CKD: specifies the clock division value.
-  *   This parameter can be one of the following value:
-  *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
-  *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
-  *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
-  * @retval None
-  */
-void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
-  /* Reset the CKD Bits */
-  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
-  /* Set the CKD value */
-  TIMx->CR1 |= TIM_CKD;
-}
-
-/**
-  * @brief  Gets the TIMx Input Capture 1 value.
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @retval Capture Compare 1 Register value.
-  */
-uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
-  /* Get the Capture 1 Register value */
-  return TIMx->CCR1;
-}
-
-/**
-  * @brief  Gets the TIMx Input Capture 2 value.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @retval Capture Compare 2 Register value.
-  */
-uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
-  /* Get the Capture 2 Register value */
-  return TIMx->CCR2;
-}
-
-/**
-  * @brief  Gets the TIMx Input Capture 3 value.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @retval Capture Compare 3 Register value.
-  */
-uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
-  /* Get the Capture 3 Register value */
-  return TIMx->CCR3;
-}
-
-/**
-  * @brief  Gets the TIMx Input Capture 4 value.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @retval Capture Compare 4 Register value.
-  */
-uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
-  /* Get the Capture 4 Register value */
-  return TIMx->CCR4;
-}
-
-/**
-  * @brief  Gets the TIMx Counter value.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @retval Counter Register value.
-  */
-uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  /* Get the Counter Register value */
-  return TIMx->CNT;
-}
-
-/**
-  * @brief  Gets the TIMx Prescaler value.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @retval Prescaler Register value.
-  */
-uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  /* Get the Prescaler Register value */
-  return TIMx->PSC;
-}
-
-/**
-  * @brief  Checks whether the specified TIM flag is set or not.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_FLAG: specifies the flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_FLAG_Update: TIM update Flag
-  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
-  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
-  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
-  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
-  *     @arg TIM_FLAG_COM: TIM Commutation Flag
-  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
-  *     @arg TIM_FLAG_Break: TIM Break Flag
-  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
-  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
-  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
-  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
-  * @note
-  *   - TIM6 and TIM7 can have only one update flag. 
-  *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
-  *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
-  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
-  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
-  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
-  * @retval The new state of TIM_FLAG (SET or RESET).
-  */
-FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
-{ 
-  ITStatus bitstatus = RESET;  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
-  
-  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the TIMx's pending flags.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_FLAG: specifies the flag bit to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg TIM_FLAG_Update: TIM update Flag
-  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
-  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
-  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
-  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
-  *     @arg TIM_FLAG_COM: TIM Commutation Flag
-  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
-  *     @arg TIM_FLAG_Break: TIM Break Flag
-  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
-  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
-  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
-  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
-  * @note
-  *   - TIM6 and TIM7 can have only one update flag. 
-  *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,
-  *      TIM_FLAG_CC2 or TIM_FLAG_Trigger. 
-  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
-  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
-  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.   
-  * @retval None
-  */
-void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
-{  
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
-   
-  /* Clear the flags */
-  TIMx->SR = (uint16_t)~TIM_FLAG;
-}
-
-/**
-  * @brief  Checks whether the TIM interrupt has occurred or not.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_IT: specifies the TIM interrupt source to check.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_IT_Update: TIM update Interrupt source
-  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
-  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
-  *     @arg TIM_IT_Break: TIM Break Interrupt source
-  * @note
-  *   - TIM6 and TIM7 can generate only an update interrupt.
-  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
-  *      TIM_IT_CC2 or TIM_IT_Trigger. 
-  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
-  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
-  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.  
-  * @retval The new state of the TIM_IT(SET or RESET).
-  */
-ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
-{
-  ITStatus bitstatus = RESET;  
-  uint16_t itstatus = 0x0, itenable = 0x0;
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_GET_IT(TIM_IT));
-   
-  itstatus = TIMx->SR & TIM_IT;
-  
-  itenable = TIMx->DIER & TIM_IT;
-  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the TIMx's interrupt pending bits.
-  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
-  * @param  TIM_IT: specifies the pending bit to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg TIM_IT_Update: TIM1 update Interrupt source
-  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
-  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
-  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
-  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
-  *     @arg TIM_IT_COM: TIM Commutation Interrupt source
-  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
-  *     @arg TIM_IT_Break: TIM Break Interrupt source
-  * @note
-  *   - TIM6 and TIM7 can generate only an update interrupt.
-  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,
-  *      TIM_IT_CC2 or TIM_IT_Trigger. 
-  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
-  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
-  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
-  * @retval None
-  */
-void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
-{
-  /* Check the parameters */
-  assert_param(IS_TIM_ALL_PERIPH(TIMx));
-  assert_param(IS_TIM_IT(TIM_IT));
-  /* Clear the IT pending Bit */
-  TIMx->SR = (uint16_t)~TIM_IT;
-}
-
-/**
-  * @brief  Configure the TI1 as Input.
-  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
-  * @param  TIM_ICPolarity : The Input Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Rising
-  *     @arg TIM_ICPolarity_Falling
-  * @param  TIM_ICSelection: specifies the input to be used.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
-  *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
-  *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
-  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
-  *   This parameter must be a value between 0x00 and 0x0F.
-  * @retval None
-  */
-static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter)
-{
-  uint16_t tmpccmr1 = 0, tmpccer = 0;
-  /* Disable the Channel 1: Reset the CC1E Bit */
-  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
-  tmpccmr1 = TIMx->CCMR1;
-  tmpccer = TIMx->CCER;
-  /* Select the Input and set the filter */
-  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
-  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
-  
-  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
-     (TIMx == TIM4) ||(TIMx == TIM5))
-  {
-    /* Select the Polarity and set the CC1E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
-    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
-  }
-  else
-  {
-    /* Select the Polarity and set the CC1E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
-    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
-  }
-
-  /* Write to TIMx CCMR1 and CCER registers */
-  TIMx->CCMR1 = tmpccmr1;
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configure the TI2 as Input.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
-  * @param  TIM_ICPolarity : The Input Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Rising
-  *     @arg TIM_ICPolarity_Falling
-  * @param  TIM_ICSelection: specifies the input to be used.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
-  *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
-  *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
-  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
-  *   This parameter must be a value between 0x00 and 0x0F.
-  * @retval None
-  */
-static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter)
-{
-  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
-  /* Disable the Channel 2: Reset the CC2E Bit */
-  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
-  tmpccmr1 = TIMx->CCMR1;
-  tmpccer = TIMx->CCER;
-  tmp = (uint16_t)(TIM_ICPolarity << 4);
-  /* Select the Input and set the filter */
-  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
-  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
-  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
-  
-  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
-     (TIMx == TIM4) ||(TIMx == TIM5))
-  {
-    /* Select the Polarity and set the CC2E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
-    tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
-  }
-  else
-  {
-    /* Select the Polarity and set the CC2E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
-    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
-  }
-  
-  /* Write to TIMx CCMR1 and CCER registers */
-  TIMx->CCMR1 = tmpccmr1 ;
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configure the TI3 as Input.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ICPolarity : The Input Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Rising
-  *     @arg TIM_ICPolarity_Falling
-  * @param  TIM_ICSelection: specifies the input to be used.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
-  *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
-  *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
-  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
-  *   This parameter must be a value between 0x00 and 0x0F.
-  * @retval None
-  */
-static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter)
-{
-  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
-  /* Disable the Channel 3: Reset the CC3E Bit */
-  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
-  tmpccmr2 = TIMx->CCMR2;
-  tmpccer = TIMx->CCER;
-  tmp = (uint16_t)(TIM_ICPolarity << 8);
-  /* Select the Input and set the filter */
-  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
-  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
-    
-  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
-     (TIMx == TIM4) ||(TIMx == TIM5))
-  {
-    /* Select the Polarity and set the CC3E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
-    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
-  }
-  else
-  {
-    /* Select the Polarity and set the CC3E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
-    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
-  }
-  
-  /* Write to TIMx CCMR2 and CCER registers */
-  TIMx->CCMR2 = tmpccmr2;
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @brief  Configure the TI4 as Input.
-  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
-  * @param  TIM_ICPolarity : The Input Polarity.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICPolarity_Rising
-  *     @arg TIM_ICPolarity_Falling
-  * @param  TIM_ICSelection: specifies the input to be used.
-  *   This parameter can be one of the following values:
-  *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
-  *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
-  *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
-  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
-  *   This parameter must be a value between 0x00 and 0x0F.
-  * @retval None
-  */
-static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
-                       uint16_t TIM_ICFilter)
-{
-  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
-
-   /* Disable the Channel 4: Reset the CC4E Bit */
-  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
-  tmpccmr2 = TIMx->CCMR2;
-  tmpccer = TIMx->CCER;
-  tmp = (uint16_t)(TIM_ICPolarity << 12);
-  /* Select the Input and set the filter */
-  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
-  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
-  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
-  
-  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
-     (TIMx == TIM4) ||(TIMx == TIM5))
-  {
-    /* Select the Polarity and set the CC4E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
-    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
-  }
-  else
-  {
-    /* Select the Polarity and set the CC4E Bit */
-    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
-    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
-  }
-  /* Write to TIMx CCMR2 and CCER registers */
-  TIMx->CCMR2 = tmpccmr2;
-  TIMx->CCER = tmpccer;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_tim.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_tim.h
deleted file mode 100644
index 65bf76aa7..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_tim.h
+++ /dev/null
@@ -1,1164 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_tim.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the TIM firmware 
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_TIM_H
-#define __STM32F10x_TIM_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup TIM
-  * @{
-  */ 
-
-/** @defgroup TIM_Exported_Types
-  * @{
-  */ 
-
-/** 
-  * @brief  TIM Time Base Init structure definition
-  * @note   This structure is used with all TIMx except for TIM6 and TIM7.    
-  */
-
-typedef struct
-{
-  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
-                                       This parameter can be a number between 0x0000 and 0xFFFF */
-
-  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
-                                       This parameter can be a value of @ref TIM_Counter_Mode */
-
-  uint16_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
-                                       Auto-Reload Register at the next update event.
-                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
-
-  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
-                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
-
-  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
-                                       reaches zero, an update event is generated and counting restarts
-                                       from the RCR value (N).
-                                       This means in PWM mode that (N+1) corresponds to:
-                                          - the number of PWM periods in edge-aligned mode
-                                          - the number of half PWM period in center-aligned mode
-                                       This parameter must be a number between 0x00 and 0xFF. 
-                                       @note This parameter is valid only for TIM1 and TIM8. */
-} TIM_TimeBaseInitTypeDef;       
-
-/** 
-  * @brief  TIM Output Compare Init structure definition  
-  */
-
-typedef struct
-{
-  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
-                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
-
-  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
-                                   This parameter can be a value of @ref TIM_Output_Compare_state */
-
-  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
-                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
-                                   @note This parameter is valid only for TIM1 and TIM8. */
-
-  uint16_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
-                                   This parameter can be a number between 0x0000 and 0xFFFF */
-
-  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
-                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
-
-  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
-                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
-                                   @note This parameter is valid only for TIM1 and TIM8. */
-
-  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
-                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
-                                   @note This parameter is valid only for TIM1 and TIM8. */
-
-  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
-                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
-                                   @note This parameter is valid only for TIM1 and TIM8. */
-} TIM_OCInitTypeDef;
-
-/** 
-  * @brief  TIM Input Capture Init structure definition  
-  */
-
-typedef struct
-{
-
-  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
-                                  This parameter can be a value of @ref TIM_Channel */
-
-  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
-                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
-
-  uint16_t TIM_ICSelection;  /*!< Specifies the input.
-                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
-
-  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
-                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
-
-  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
-                                  This parameter can be a number between 0x0 and 0xF */
-} TIM_ICInitTypeDef;
-
-/** 
-  * @brief  BDTR structure definition 
-  * @note   This structure is used only with TIM1 and TIM8.    
-  */
-
-typedef struct
-{
-
-  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
-                                      This parameter can be a value of @ref OSSR_Off_State_Selection_for_Run_mode_state */
-
-  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
-                                      This parameter can be a value of @ref OSSI_Off_State_Selection_for_Idle_mode_state */
-
-  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
-                                      This parameter can be a value of @ref Lock_level */ 
-
-  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
-                                      switching-on of the outputs.
-                                      This parameter can be a number between 0x00 and 0xFF  */
-
-  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
-                                      This parameter can be a value of @ref Break_Input_enable_disable */
-
-  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
-                                      This parameter can be a value of @ref Break_Polarity */
-
-  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
-                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
-} TIM_BDTRInitTypeDef;
-
-/** @defgroup TIM_Exported_constants 
-  * @{
-  */
-
-#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
-                                   ((PERIPH) == TIM2) || \
-                                   ((PERIPH) == TIM3) || \
-                                   ((PERIPH) == TIM4) || \
-                                   ((PERIPH) == TIM5) || \
-                                   ((PERIPH) == TIM6) || \
-                                   ((PERIPH) == TIM7) || \
-                                   ((PERIPH) == TIM8) || \
-                                   ((PERIPH) == TIM9) || \
-                                   ((PERIPH) == TIM10)|| \
-                                   ((PERIPH) == TIM11)|| \
-                                   ((PERIPH) == TIM12)|| \
-                                   ((PERIPH) == TIM13)|| \
-                                   ((PERIPH) == TIM14)|| \
-                                   ((PERIPH) == TIM15)|| \
-                                   ((PERIPH) == TIM16)|| \
-                                   ((PERIPH) == TIM17))
-
-/* LIST1: TIM 1 and 8 */
-#define IS_TIM_LIST1_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
-                                      ((PERIPH) == TIM8))
-
-/* LIST2: TIM 1, 8, 15 16 and 17 */
-#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
-                                     ((PERIPH) == TIM8) || \
-                                     ((PERIPH) == TIM15)|| \
-                                     ((PERIPH) == TIM16)|| \
-                                     ((PERIPH) == TIM17)) 
-
-/* LIST3: TIM 1, 2, 3, 4, 5 and 8 */
-#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
-                                     ((PERIPH) == TIM2) || \
-                                     ((PERIPH) == TIM3) || \
-                                     ((PERIPH) == TIM4) || \
-                                     ((PERIPH) == TIM5) || \
-                                     ((PERIPH) == TIM8)) 
-									                                 
-/* LIST4: TIM 1, 2, 3, 4, 5, 8, 15, 16 and 17 */
-#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
-                                     ((PERIPH) == TIM2) || \
-                                     ((PERIPH) == TIM3) || \
-                                     ((PERIPH) == TIM4) || \
-                                     ((PERIPH) == TIM5) || \
-                                     ((PERIPH) == TIM8) || \
-                                     ((PERIPH) == TIM15)|| \
-                                     ((PERIPH) == TIM16)|| \
-                                     ((PERIPH) == TIM17))
-
-/* LIST5: TIM 1, 2, 3, 4, 5, 8 and 15 */                                            
-#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
-                                     ((PERIPH) == TIM2) || \
-                                     ((PERIPH) == TIM3) || \
-                                     ((PERIPH) == TIM4) || \
-                                     ((PERIPH) == TIM5) || \
-                                     ((PERIPH) == TIM8) || \
-                                     ((PERIPH) == TIM15)) 
-
-/* LIST6: TIM 1, 2, 3, 4, 5, 8, 9, 12 and 15 */
-#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
-                                      ((PERIPH) == TIM2) || \
-                                      ((PERIPH) == TIM3) || \
-                                      ((PERIPH) == TIM4) || \
-                                      ((PERIPH) == TIM5) || \
-                                      ((PERIPH) == TIM8) || \
-                                      ((PERIPH) == TIM9) || \
-									  ((PERIPH) == TIM12)|| \
-                                      ((PERIPH) == TIM15))
-
-/* LIST7: TIM 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 and 15 */
-#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
-                                      ((PERIPH) == TIM2) || \
-                                      ((PERIPH) == TIM3) || \
-                                      ((PERIPH) == TIM4) || \
-                                      ((PERIPH) == TIM5) || \
-                                      ((PERIPH) == TIM6) || \
-                                      ((PERIPH) == TIM7) || \
-                                      ((PERIPH) == TIM8) || \
-                                      ((PERIPH) == TIM9) || \
-                                      ((PERIPH) == TIM12)|| \
-                                      ((PERIPH) == TIM15))                                    
-
-/* LIST8: TIM 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16 and 17 */                                        
-#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
-                                      ((PERIPH) == TIM2) || \
-                                      ((PERIPH) == TIM3) || \
-                                      ((PERIPH) == TIM4) || \
-                                      ((PERIPH) == TIM5) || \
-                                      ((PERIPH) == TIM8) || \
-                                      ((PERIPH) == TIM9) || \
-                                      ((PERIPH) == TIM10)|| \
-                                      ((PERIPH) == TIM11)|| \
-                                      ((PERIPH) == TIM12)|| \
-                                      ((PERIPH) == TIM13)|| \
-                                      ((PERIPH) == TIM14)|| \
-                                      ((PERIPH) == TIM15)|| \
-                                      ((PERIPH) == TIM16)|| \
-                                      ((PERIPH) == TIM17))
-
-/* LIST9: TIM 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, and 17 */
-#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
-                                      ((PERIPH) == TIM2) || \
-                                      ((PERIPH) == TIM3) || \
-                                      ((PERIPH) == TIM4) || \
-                                      ((PERIPH) == TIM5) || \
-                                      ((PERIPH) == TIM6) || \
-                                      ((PERIPH) == TIM7) || \
-                                      ((PERIPH) == TIM8) || \
-                                      ((PERIPH) == TIM15)|| \
-                                      ((PERIPH) == TIM16)|| \
-                                      ((PERIPH) == TIM17))  
-                                                                                                                                                                                                                          
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_and_PWM_modes 
-  * @{
-  */
-
-#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
-#define TIM_OCMode_Active                  ((uint16_t)0x0010)
-#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
-#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
-#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
-#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
-#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
-                              ((MODE) == TIM_OCMode_Active) || \
-                              ((MODE) == TIM_OCMode_Inactive) || \
-                              ((MODE) == TIM_OCMode_Toggle)|| \
-                              ((MODE) == TIM_OCMode_PWM1) || \
-                              ((MODE) == TIM_OCMode_PWM2))
-#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
-                          ((MODE) == TIM_OCMode_Active) || \
-                          ((MODE) == TIM_OCMode_Inactive) || \
-                          ((MODE) == TIM_OCMode_Toggle)|| \
-                          ((MODE) == TIM_OCMode_PWM1) || \
-                          ((MODE) == TIM_OCMode_PWM2) ||	\
-                          ((MODE) == TIM_ForcedAction_Active) || \
-                          ((MODE) == TIM_ForcedAction_InActive))
-/**
-  * @}
-  */
-
-/** @defgroup TIM_One_Pulse_Mode 
-  * @{
-  */
-
-#define TIM_OPMode_Single                  ((uint16_t)0x0008)
-#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
-#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
-                               ((MODE) == TIM_OPMode_Repetitive))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Channel 
-  * @{
-  */
-
-#define TIM_Channel_1                      ((uint16_t)0x0000)
-#define TIM_Channel_2                      ((uint16_t)0x0004)
-#define TIM_Channel_3                      ((uint16_t)0x0008)
-#define TIM_Channel_4                      ((uint16_t)0x000C)
-#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
-                                 ((CHANNEL) == TIM_Channel_2) || \
-                                 ((CHANNEL) == TIM_Channel_3) || \
-                                 ((CHANNEL) == TIM_Channel_4))
-#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
-                                      ((CHANNEL) == TIM_Channel_2))
-#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
-                                               ((CHANNEL) == TIM_Channel_2) || \
-                                               ((CHANNEL) == TIM_Channel_3))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Clock_Division_CKD 
-  * @{
-  */
-
-#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
-#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
-#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
-#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
-                             ((DIV) == TIM_CKD_DIV2) || \
-                             ((DIV) == TIM_CKD_DIV4))
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Counter_Mode 
-  * @{
-  */
-
-#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
-#define TIM_CounterMode_Down               ((uint16_t)0x0010)
-#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
-#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
-#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
-#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
-                                   ((MODE) == TIM_CounterMode_Down) || \
-                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
-                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
-                                   ((MODE) == TIM_CounterMode_CenterAligned3))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_Polarity 
-  * @{
-  */
-
-#define TIM_OCPolarity_High                ((uint16_t)0x0000)
-#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
-#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
-                                      ((POLARITY) == TIM_OCPolarity_Low))
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Output_Compare_N_Polarity 
-  * @{
-  */
-  
-#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
-#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
-#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
-                                       ((POLARITY) == TIM_OCNPolarity_Low))
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Output_Compare_state 
-  * @{
-  */
-
-#define TIM_OutputState_Disable            ((uint16_t)0x0000)
-#define TIM_OutputState_Enable             ((uint16_t)0x0001)
-#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
-                                    ((STATE) == TIM_OutputState_Enable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_N_state 
-  * @{
-  */
-
-#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
-#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
-#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
-                                     ((STATE) == TIM_OutputNState_Enable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Capture_Compare_state 
-  * @{
-  */
-
-#define TIM_CCx_Enable                      ((uint16_t)0x0001)
-#define TIM_CCx_Disable                     ((uint16_t)0x0000)
-#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
-                         ((CCX) == TIM_CCx_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Capture_Compare_N_state 
-  * @{
-  */
-
-#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
-#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
-#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
-                           ((CCXN) == TIM_CCxN_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup Break_Input_enable_disable 
-  * @{
-  */
-
-#define TIM_Break_Enable                   ((uint16_t)0x1000)
-#define TIM_Break_Disable                  ((uint16_t)0x0000)
-#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
-                                   ((STATE) == TIM_Break_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup Break_Polarity 
-  * @{
-  */
-
-#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
-#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
-#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
-                                         ((POLARITY) == TIM_BreakPolarity_High))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_AOE_Bit_Set_Reset 
-  * @{
-  */
-
-#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
-#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
-#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
-                                              ((STATE) == TIM_AutomaticOutput_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup Lock_level 
-  * @{
-  */
-
-#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
-#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
-#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
-#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
-#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
-                                  ((LEVEL) == TIM_LOCKLevel_1) || \
-                                  ((LEVEL) == TIM_LOCKLevel_2) || \
-                                  ((LEVEL) == TIM_LOCKLevel_3))
-/**
-  * @}
-  */ 
-
-/** @defgroup OSSI_Off_State_Selection_for_Idle_mode_state 
-  * @{
-  */
-
-#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
-#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
-#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
-                                  ((STATE) == TIM_OSSIState_Disable))
-/**
-  * @}
-  */
-
-/** @defgroup OSSR_Off_State_Selection_for_Run_mode_state 
-  * @{
-  */
-
-#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
-#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
-#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
-                                  ((STATE) == TIM_OSSRState_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_Idle_State 
-  * @{
-  */
-
-#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
-#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
-#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
-                                    ((STATE) == TIM_OCIdleState_Reset))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_N_Idle_State 
-  * @{
-  */
-
-#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
-#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
-#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
-                                     ((STATE) == TIM_OCNIdleState_Reset))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Input_Capture_Polarity 
-  * @{
-  */
-
-#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
-#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
-#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
-#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
-                                      ((POLARITY) == TIM_ICPolarity_Falling))
-#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
-                                           ((POLARITY) == TIM_ICPolarity_Falling)|| \
-                                           ((POLARITY) == TIM_ICPolarity_BothEdge))                                      
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Input_Capture_Selection 
-  * @{
-  */
-
-#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
-                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
-#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
-                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
-#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
-#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
-                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
-                                        ((SELECTION) == TIM_ICSelection_TRC))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Input_Capture_Prescaler 
-  * @{
-  */
-
-#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
-#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
-#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
-#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
-#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
-                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
-                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
-                                        ((PRESCALER) == TIM_ICPSC_DIV8))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_interrupt_sources 
-  * @{
-  */
-
-#define TIM_IT_Update                      ((uint16_t)0x0001)
-#define TIM_IT_CC1                         ((uint16_t)0x0002)
-#define TIM_IT_CC2                         ((uint16_t)0x0004)
-#define TIM_IT_CC3                         ((uint16_t)0x0008)
-#define TIM_IT_CC4                         ((uint16_t)0x0010)
-#define TIM_IT_COM                         ((uint16_t)0x0020)
-#define TIM_IT_Trigger                     ((uint16_t)0x0040)
-#define TIM_IT_Break                       ((uint16_t)0x0080)
-#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
-
-#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
-                           ((IT) == TIM_IT_CC1) || \
-                           ((IT) == TIM_IT_CC2) || \
-                           ((IT) == TIM_IT_CC3) || \
-                           ((IT) == TIM_IT_CC4) || \
-                           ((IT) == TIM_IT_COM) || \
-                           ((IT) == TIM_IT_Trigger) || \
-                           ((IT) == TIM_IT_Break))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_DMA_Base_address 
-  * @{
-  */
-
-#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
-#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
-#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
-#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
-#define TIM_DMABase_SR                     ((uint16_t)0x0004)
-#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
-#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
-#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
-#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
-#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
-#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
-#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
-#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
-#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
-#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
-#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
-#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
-#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
-#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
-#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
-                               ((BASE) == TIM_DMABase_CR2) || \
-                               ((BASE) == TIM_DMABase_SMCR) || \
-                               ((BASE) == TIM_DMABase_DIER) || \
-                               ((BASE) == TIM_DMABase_SR) || \
-                               ((BASE) == TIM_DMABase_EGR) || \
-                               ((BASE) == TIM_DMABase_CCMR1) || \
-                               ((BASE) == TIM_DMABase_CCMR2) || \
-                               ((BASE) == TIM_DMABase_CCER) || \
-                               ((BASE) == TIM_DMABase_CNT) || \
-                               ((BASE) == TIM_DMABase_PSC) || \
-                               ((BASE) == TIM_DMABase_ARR) || \
-                               ((BASE) == TIM_DMABase_RCR) || \
-                               ((BASE) == TIM_DMABase_CCR1) || \
-                               ((BASE) == TIM_DMABase_CCR2) || \
-                               ((BASE) == TIM_DMABase_CCR3) || \
-                               ((BASE) == TIM_DMABase_CCR4) || \
-                               ((BASE) == TIM_DMABase_BDTR) || \
-                               ((BASE) == TIM_DMABase_DCR))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_DMA_Burst_Length 
-  * @{
-  */
-
-#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
-#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
-#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
-#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
-#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
-#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
-#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
-#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
-#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
-#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
-#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
-#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
-#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
-#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
-#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
-#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
-#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
-#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
-#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
-                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
-                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_DMA_sources 
-  * @{
-  */
-
-#define TIM_DMA_Update                     ((uint16_t)0x0100)
-#define TIM_DMA_CC1                        ((uint16_t)0x0200)
-#define TIM_DMA_CC2                        ((uint16_t)0x0400)
-#define TIM_DMA_CC3                        ((uint16_t)0x0800)
-#define TIM_DMA_CC4                        ((uint16_t)0x1000)
-#define TIM_DMA_COM                        ((uint16_t)0x2000)
-#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
-#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
-
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_External_Trigger_Prescaler 
-  * @{
-  */
-
-#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
-#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
-#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
-#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
-#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
-                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
-                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
-                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Internal_Trigger_Selection 
-  * @{
-  */
-
-#define TIM_TS_ITR0                        ((uint16_t)0x0000)
-#define TIM_TS_ITR1                        ((uint16_t)0x0010)
-#define TIM_TS_ITR2                        ((uint16_t)0x0020)
-#define TIM_TS_ITR3                        ((uint16_t)0x0030)
-#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
-#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
-#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
-#define TIM_TS_ETRF                        ((uint16_t)0x0070)
-#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
-                                             ((SELECTION) == TIM_TS_ITR1) || \
-                                             ((SELECTION) == TIM_TS_ITR2) || \
-                                             ((SELECTION) == TIM_TS_ITR3) || \
-                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
-                                             ((SELECTION) == TIM_TS_TI1FP1) || \
-                                             ((SELECTION) == TIM_TS_TI2FP2) || \
-                                             ((SELECTION) == TIM_TS_ETRF))
-#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
-                                                      ((SELECTION) == TIM_TS_ITR1) || \
-                                                      ((SELECTION) == TIM_TS_ITR2) || \
-                                                      ((SELECTION) == TIM_TS_ITR3))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_TIx_External_Clock_Source 
-  * @{
-  */
-
-#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
-#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
-#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
-#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
-                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
-                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_External_Trigger_Polarity 
-  * @{
-  */ 
-#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
-#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
-#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
-                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Prescaler_Reload_Mode 
-  * @{
-  */
-
-#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
-#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
-#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
-                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Forced_Action 
-  * @{
-  */
-
-#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
-#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
-#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
-                                      ((ACTION) == TIM_ForcedAction_InActive))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Encoder_Mode 
-  * @{
-  */
-
-#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
-#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
-#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
-#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
-                                   ((MODE) == TIM_EncoderMode_TI2) || \
-                                   ((MODE) == TIM_EncoderMode_TI12))
-/**
-  * @}
-  */ 
-
-
-/** @defgroup TIM_Event_Source 
-  * @{
-  */
-
-#define TIM_EventSource_Update             ((uint16_t)0x0001)
-#define TIM_EventSource_CC1                ((uint16_t)0x0002)
-#define TIM_EventSource_CC2                ((uint16_t)0x0004)
-#define TIM_EventSource_CC3                ((uint16_t)0x0008)
-#define TIM_EventSource_CC4                ((uint16_t)0x0010)
-#define TIM_EventSource_COM                ((uint16_t)0x0020)
-#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
-#define TIM_EventSource_Break              ((uint16_t)0x0080)
-#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
-
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Update_Source 
-  * @{
-  */
-
-#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
-                                                                   or the setting of UG bit, or an update generation
-                                                                   through the slave mode controller. */
-#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
-#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
-                                      ((SOURCE) == TIM_UpdateSource_Regular))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_Preload_State 
-  * @{
-  */
-
-#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
-#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
-#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
-                                       ((STATE) == TIM_OCPreload_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_Fast_State 
-  * @{
-  */
-
-#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
-#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
-#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
-                                    ((STATE) == TIM_OCFast_Disable))
-                                     
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Output_Compare_Clear_State 
-  * @{
-  */
-
-#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
-#define TIM_OCClear_Disable                ((uint16_t)0x0000)
-#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
-                                     ((STATE) == TIM_OCClear_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Trigger_Output_Source 
-  * @{
-  */
-
-#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
-#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
-#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
-#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
-#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
-#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
-#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
-#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
-#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
-                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
-                                    ((SOURCE) == TIM_TRGOSource_Update) || \
-                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
-                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
-                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
-                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
-                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Slave_Mode 
-  * @{
-  */
-
-#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
-#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
-#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
-#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
-#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
-                                 ((MODE) == TIM_SlaveMode_Gated) || \
-                                 ((MODE) == TIM_SlaveMode_Trigger) || \
-                                 ((MODE) == TIM_SlaveMode_External1))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Master_Slave_Mode 
-  * @{
-  */
-
-#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
-#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
-#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
-                                 ((STATE) == TIM_MasterSlaveMode_Disable))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Flags 
-  * @{
-  */
-
-#define TIM_FLAG_Update                    ((uint16_t)0x0001)
-#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
-#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
-#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
-#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
-#define TIM_FLAG_COM                       ((uint16_t)0x0020)
-#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
-#define TIM_FLAG_Break                     ((uint16_t)0x0080)
-#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
-#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
-#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
-#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
-#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
-                               ((FLAG) == TIM_FLAG_CC1) || \
-                               ((FLAG) == TIM_FLAG_CC2) || \
-                               ((FLAG) == TIM_FLAG_CC3) || \
-                               ((FLAG) == TIM_FLAG_CC4) || \
-                               ((FLAG) == TIM_FLAG_COM) || \
-                               ((FLAG) == TIM_FLAG_Trigger) || \
-                               ((FLAG) == TIM_FLAG_Break) || \
-                               ((FLAG) == TIM_FLAG_CC1OF) || \
-                               ((FLAG) == TIM_FLAG_CC2OF) || \
-                               ((FLAG) == TIM_FLAG_CC3OF) || \
-                               ((FLAG) == TIM_FLAG_CC4OF))
-                               
-                               
-#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Input_Capture_Filer_Value 
-  * @{
-  */
-
-#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_External_Trigger_Filter 
-  * @{
-  */
-
-#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Legacy 
-  * @{
-  */
-
-#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
-#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
-#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
-#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
-#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
-#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
-#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
-#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
-#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
-#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
-#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
-#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
-#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
-#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
-#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
-#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
-#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
-#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup TIM_Exported_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */ 
-
-/** @defgroup TIM_Exported_Functions
-  * @{
-  */
-
-void TIM_DeInit(TIM_TypeDef* TIMx);
-void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
-void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
-void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
-void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
-void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
-void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
-void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
-void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
-void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
-void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
-void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
-void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
-void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
-void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
-void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
-void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
-void TIM_InternalClockConfig(TIM_TypeDef* TIMx);
-void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
-void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
-                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
-void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
-                             uint16_t ExtTRGFilter);
-void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
-                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
-void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
-                   uint16_t ExtTRGFilter);
-void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
-void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
-void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
-void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
-                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
-void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
-void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
-void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
-void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
-void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
-void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
-void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
-void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
-void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
-void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
-void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
-void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
-void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
-void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
-void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
-void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
-void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
-void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
-void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
-void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
-void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
-void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
-void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
-void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
-void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
-void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
-void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
-void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
-void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
-void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
-void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
-void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
-void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);
-void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);
-void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);
-void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);
-void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);
-void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);
-void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
-void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
-void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
-void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
-void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
-uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);
-uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);
-uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);
-uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);
-uint16_t TIM_GetCounter(TIM_TypeDef* TIMx);
-uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
-FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
-void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
-ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
-void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__STM32F10x_TIM_H */
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_usart.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_usart.c
deleted file mode 100644
index e794eae66..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_usart.c
+++ /dev/null
@@ -1,1058 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_usart.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the USART firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_usart.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup USART 
-  * @brief USART driver modules
-  * @{
-  */
-
-/** @defgroup USART_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup USART_Private_Defines
-  * @{
-  */
-
-#define CR1_UE_Set                ((uint16_t)0x2000)  /*!< USART Enable Mask */
-#define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!< USART Disable Mask */
-
-#define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!< USART WakeUp Method Mask */
-
-#define CR1_RWU_Set               ((uint16_t)0x0002)  /*!< USART mute mode Enable Mask */
-#define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!< USART mute mode Enable Mask */
-#define CR1_SBK_Set               ((uint16_t)0x0001)  /*!< USART Break Character send Mask */
-#define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!< USART CR1 Mask */
-#define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!< USART address Mask */
-
-#define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!< USART LIN Enable Mask */
-#define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!< USART LIN Disable Mask */
-
-#define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!< USART LIN Break detection Mask */
-#define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!< USART CR2 STOP Bits Mask */
-#define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!< USART CR2 Clock Mask */
-
-#define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!< USART SC Enable Mask */
-#define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!< USART SC Disable Mask */
-
-#define CR3_NACK_Set              ((uint16_t)0x0010)  /*!< USART SC NACK Enable Mask */
-#define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!< USART SC NACK Disable Mask */
-
-#define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!< USART Half-Duplex Enable Mask */
-#define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!< USART Half-Duplex Disable Mask */
-
-#define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!< USART IrDA LowPower mode Mask */
-#define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!< USART CR3 Mask */
-
-#define CR3_IREN_Set              ((uint16_t)0x0002)  /*!< USART IrDA Enable Mask */
-#define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!< USART IrDA Disable Mask */
-#define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!< Guard Time Register LSB Mask */
-#define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!< Guard Time Register MSB Mask */
-#define IT_Mask                   ((uint16_t)0x001F)  /*!< USART Interrupt Mask */
-
-/* USART OverSampling-8 Mask */
-#define CR1_OVER8_Set             ((u16)0x8000)  /* USART OVER8 mode Enable Mask */
-#define CR1_OVER8_Reset           ((u16)0x7FFF)  /* USART OVER8 mode Disable Mask */
-
-/* USART One Bit Sampling Mask */
-#define CR3_ONEBITE_Set           ((u16)0x0800)  /* USART ONEBITE mode Enable Mask */
-#define CR3_ONEBITE_Reset         ((u16)0xF7FF)  /* USART ONEBITE mode Disable Mask */
-
-/**
-  * @}
-  */
-
-/** @defgroup USART_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup USART_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup USART_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup USART_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values: 
-  *      USART1, USART2, USART3, UART4 or UART5.
-  * @retval None
-  */
-void USART_DeInit(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-
-  if (USARTx == USART1)
-  {
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
-    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
-  }
-  else if (USARTx == USART2)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
-  }
-  else if (USARTx == USART3)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
-  }    
-  else if (USARTx == UART4)
-  {
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
-    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
-  }    
-  else
-  {
-    if (USARTx == UART5)
-    { 
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
-      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
-    }
-  }
-}
-
-/**
-  * @brief  Initializes the USARTx peripheral according to the specified
-  *         parameters in the USART_InitStruct .
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
-  *         that contains the configuration information for the specified USART 
-  *         peripheral.
-  * @retval None
-  */
-void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
-{
-  uint32_t tmpreg = 0x00, apbclock = 0x00;
-  uint32_t integerdivider = 0x00;
-  uint32_t fractionaldivider = 0x00;
-  uint32_t usartxbase = 0;
-  RCC_ClocksTypeDef RCC_ClocksStatus;
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
-  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
-  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
-  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
-  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
-  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
-  /* The hardware flow control is available only for USART1, USART2 and USART3 */
-  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
-  {
-    assert_param(IS_USART_123_PERIPH(USARTx));
-  }
-
-  usartxbase = (uint32_t)USARTx;
-
-/*---------------------------- USART CR2 Configuration -----------------------*/
-  tmpreg = USARTx->CR2;
-  /* Clear STOP[13:12] bits */
-  tmpreg &= CR2_STOP_CLEAR_Mask;
-  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
-  /* Set STOP[13:12] bits according to USART_StopBits value */
-  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
-  
-  /* Write to USART CR2 */
-  USARTx->CR2 = (uint16_t)tmpreg;
-
-/*---------------------------- USART CR1 Configuration -----------------------*/
-  tmpreg = USARTx->CR1;
-  /* Clear M, PCE, PS, TE and RE bits */
-  tmpreg &= CR1_CLEAR_Mask;
-  /* Configure the USART Word Length, Parity and mode ----------------------- */
-  /* Set the M bits according to USART_WordLength value */
-  /* Set PCE and PS bits according to USART_Parity value */
-  /* Set TE and RE bits according to USART_Mode value */
-  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
-            USART_InitStruct->USART_Mode;
-  /* Write to USART CR1 */
-  USARTx->CR1 = (uint16_t)tmpreg;
-
-/*---------------------------- USART CR3 Configuration -----------------------*/  
-  tmpreg = USARTx->CR3;
-  /* Clear CTSE and RTSE bits */
-  tmpreg &= CR3_CLEAR_Mask;
-  /* Configure the USART HFC -------------------------------------------------*/
-  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
-  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
-  /* Write to USART CR3 */
-  USARTx->CR3 = (uint16_t)tmpreg;
-
-/*---------------------------- USART BRR Configuration -----------------------*/
-  /* Configure the USART Baud Rate -------------------------------------------*/
-  RCC_GetClocksFreq(&RCC_ClocksStatus);
-  if (usartxbase == USART1_BASE)
-  {
-    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
-  }
-  else
-  {
-    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
-  }
-  
-  /* Determine the integer part */
-  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
-  {
-    /* Integer part computing in case Oversampling mode is 8 Samples */
-    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
-  }
-  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
-  {
-    /* Integer part computing in case Oversampling mode is 16 Samples */
-    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
-  }
-  tmpreg = (integerdivider / 100) << 4;
-
-  /* Determine the fractional part */
-  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
-
-  /* Implement the fractional part in the register */
-  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
-  {
-    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
-  }
-  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
-  {
-    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
-  }
-  
-  /* Write to USART BRR */
-  USARTx->BRR = (uint16_t)tmpreg;
-}
-
-/**
-  * @brief  Fills each USART_InitStruct member with its default value.
-  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
-  *         which will be initialized.
-  * @retval None
-  */
-void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
-{
-  /* USART_InitStruct members default value */
-  USART_InitStruct->USART_BaudRate = 9600;
-  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
-  USART_InitStruct->USART_StopBits = USART_StopBits_1;
-  USART_InitStruct->USART_Parity = USART_Parity_No ;
-  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
-  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
-}
-
-/**
-  * @brief  Initializes the USARTx peripheral Clock according to the 
-  *          specified parameters in the USART_ClockInitStruct .
-  * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
-  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
-  *         structure that contains the configuration information for the specified 
-  *         USART peripheral.  
-  * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
-  * @retval None
-  */
-void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
-{
-  uint32_t tmpreg = 0x00;
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
-  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
-  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
-  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
-  
-/*---------------------------- USART CR2 Configuration -----------------------*/
-  tmpreg = USARTx->CR2;
-  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
-  tmpreg &= CR2_CLOCK_CLEAR_Mask;
-  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
-  /* Set CLKEN bit according to USART_Clock value */
-  /* Set CPOL bit according to USART_CPOL value */
-  /* Set CPHA bit according to USART_CPHA value */
-  /* Set LBCL bit according to USART_LastBit value */
-  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
-                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
-  /* Write to USART CR2 */
-  USARTx->CR2 = (uint16_t)tmpreg;
-}
-
-/**
-  * @brief  Fills each USART_ClockInitStruct member with its default value.
-  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
-  *         structure which will be initialized.
-  * @retval None
-  */
-void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
-{
-  /* USART_ClockInitStruct members default value */
-  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
-  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
-  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
-  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
-}
-
-/**
-  * @brief  Enables or disables the specified USART peripheral.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *         This parameter can be one of the following values:
-  *           USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the USARTx peripheral.
-  *         This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the selected USART by setting the UE bit in the CR1 register */
-    USARTx->CR1 |= CR1_UE_Set;
-  }
-  else
-  {
-    /* Disable the selected USART by clearing the UE bit in the CR1 register */
-    USARTx->CR1 &= CR1_UE_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the specified USART interrupts.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
-  *   This parameter can be one of the following values:
-  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
-  *     @arg USART_IT_LBD:  LIN Break detection interrupt
-  *     @arg USART_IT_TXE:  Transmit Data Register empty interrupt
-  *     @arg USART_IT_TC:   Transmission complete interrupt
-  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
-  *     @arg USART_IT_IDLE: Idle line detection interrupt
-  *     @arg USART_IT_PE:   Parity Error interrupt
-  *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
-  * @param  NewState: new state of the specified USARTx interrupts.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
-{
-  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
-  uint32_t usartxbase = 0x00;
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CONFIG_IT(USART_IT));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  /* The CTS interrupt is not available for UART4 and UART5 */
-  if (USART_IT == USART_IT_CTS)
-  {
-    assert_param(IS_USART_123_PERIPH(USARTx));
-  }   
-  
-  usartxbase = (uint32_t)USARTx;
-
-  /* Get the USART register index */
-  usartreg = (((uint8_t)USART_IT) >> 0x05);
-
-  /* Get the interrupt position */
-  itpos = USART_IT & IT_Mask;
-  itmask = (((uint32_t)0x01) << itpos);
-    
-  if (usartreg == 0x01) /* The IT is in CR1 register */
-  {
-    usartxbase += 0x0C;
-  }
-  else if (usartreg == 0x02) /* The IT is in CR2 register */
-  {
-    usartxbase += 0x10;
-  }
-  else /* The IT is in CR3 register */
-  {
-    usartxbase += 0x14; 
-  }
-  if (NewState != DISABLE)
-  {
-    *(__IO uint32_t*)usartxbase  |= itmask;
-  }
-  else
-  {
-    *(__IO uint32_t*)usartxbase &= ~itmask;
-  }
-}
-
-/**
-  * @brief  Enables or disables the USARTs DMA interface.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_DMAReq: specifies the DMA request.
-  *   This parameter can be any combination of the following values:
-  *     @arg USART_DMAReq_Tx: USART DMA transmit request
-  *     @arg USART_DMAReq_Rx: USART DMA receive request
-  * @param  NewState: new state of the DMA Request sources.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @note The DMA mode is not available for UART5 except in the STM32
-  *       High density value line devices(STM32F10X_HD_VL).  
-  * @retval None
-  */
-void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-  if (NewState != DISABLE)
-  {
-    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
-       DMAR bits in the USART CR3 register */
-    USARTx->CR3 |= USART_DMAReq;
-  }
-  else
-  {
-    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
-       DMAR bits in the USART CR3 register */
-    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
-  }
-}
-
-/**
-  * @brief  Sets the address of the USART node.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_Address: Indicates the address of the USART node.
-  * @retval None
-  */
-void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_ADDRESS(USART_Address)); 
-    
-  /* Clear the USART address */
-  USARTx->CR2 &= CR2_Address_Mask;
-  /* Set the USART address node */
-  USARTx->CR2 |= USART_Address;
-}
-
-/**
-  * @brief  Selects the USART WakeUp method.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_WakeUp: specifies the USART wakeup method.
-  *   This parameter can be one of the following values:
-  *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
-  *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
-  * @retval None
-  */
-void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_WAKEUP(USART_WakeUp));
-  
-  USARTx->CR1 &= CR1_WAKE_Mask;
-  USARTx->CR1 |= USART_WakeUp;
-}
-
-/**
-  * @brief  Determines if the USART is in mute mode or not.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the USART mute mode.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
-    USARTx->CR1 |= CR1_RWU_Set;
-  }
-  else
-  {
-    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
-    USARTx->CR1 &= CR1_RWU_Reset;
-  }
-}
-
-/**
-  * @brief  Sets the USART LIN Break detection length.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
-  *   This parameter can be one of the following values:
-  *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
-  *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
-  * @retval None
-  */
-void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
-  
-  USARTx->CR2 &= CR2_LBDL_Mask;
-  USARTx->CR2 |= USART_LINBreakDetectLength;  
-}
-
-/**
-  * @brief  Enables or disables the USARTs LIN mode.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the USART LIN mode.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
-    USARTx->CR2 |= CR2_LINEN_Set;
-  }
-  else
-  {
-    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
-    USARTx->CR2 &= CR2_LINEN_Reset;
-  }
-}
-
-/**
-  * @brief  Transmits single data through the USARTx peripheral.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  Data: the data to transmit.
-  * @retval None
-  */
-void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_DATA(Data)); 
-    
-  /* Transmit Data */
-  USARTx->DR = (Data & (uint16_t)0x01FF);
-}
-
-/**
-  * @brief  Returns the most recent received data by the USARTx peripheral.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @retval The received data.
-  */
-uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Receive Data */
-  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
-}
-
-/**
-  * @brief  Transmits break characters.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @retval None
-  */
-void USART_SendBreak(USART_TypeDef* USARTx)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Send break characters */
-  USARTx->CR1 |= CR1_SBK_Set;
-}
-
-/**
-  * @brief  Sets the specified USART guard time.
-  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
-  * @param  USART_GuardTime: specifies the guard time.
-  * @note The guard time bits are not available for UART4 and UART5.   
-  * @retval None
-  */
-void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
-{    
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  
-  /* Clear the USART Guard time */
-  USARTx->GTPR &= GTPR_LSB_Mask;
-  /* Set the USART guard time */
-  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
-}
-
-/**
-  * @brief  Sets the system clock prescaler.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_Prescaler: specifies the prescaler clock.  
-  * @note   The function is used for IrDA mode with UART4 and UART5.
-  * @retval None
-  */
-void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
-{ 
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  
-  /* Clear the USART prescaler */
-  USARTx->GTPR &= GTPR_MSB_Mask;
-  /* Set the USART prescaler */
-  USARTx->GTPR |= USART_Prescaler;
-}
-
-/**
-  * @brief  Enables or disables the USARTs Smart Card mode.
-  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
-  * @param  NewState: new state of the Smart Card mode.
-  *   This parameter can be: ENABLE or DISABLE.     
-  * @note The Smart Card mode is not available for UART4 and UART5. 
-  * @retval None
-  */
-void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
-    USARTx->CR3 |= CR3_SCEN_Set;
-  }
-  else
-  {
-    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
-    USARTx->CR3 &= CR3_SCEN_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables NACK transmission.
-  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral. 
-  * @param  NewState: new state of the NACK transmission.
-  *   This parameter can be: ENABLE or DISABLE.  
-  * @note The Smart Card mode is not available for UART4 and UART5.
-  * @retval None
-  */
-void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_123_PERIPH(USARTx));  
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  if (NewState != DISABLE)
-  {
-    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
-    USARTx->CR3 |= CR3_NACK_Set;
-  }
-  else
-  {
-    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
-    USARTx->CR3 &= CR3_NACK_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the USARTs Half Duplex communication.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the USART Communication.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
-    USARTx->CR3 |= CR3_HDSEL_Set;
-  }
-  else
-  {
-    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
-    USARTx->CR3 &= CR3_HDSEL_Reset;
-  }
-}
-
-
-/**
-  * @brief  Enables or disables the USART's 8x oversampling mode.
-  * @param  USARTx: Select the USART or the UART peripheral.
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the USART one bit sampling method.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @note
-  *     This function has to be called before calling USART_Init()
-  *     function in order to have correct baudrate Divider value.   
-  * @retval None
-  */
-void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
-    USARTx->CR1 |= CR1_OVER8_Set;
-  }
-  else
-  {
-    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
-    USARTx->CR1 &= CR1_OVER8_Reset;
-  }
-}
-
-/**
-  * @brief  Enables or disables the USART's one bit sampling method.
-  * @param  USARTx: Select the USART or the UART peripheral.
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the USART one bit sampling method.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-  
-  if (NewState != DISABLE)
-  {
-    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
-    USARTx->CR3 |= CR3_ONEBITE_Set;
-  }
-  else
-  {
-    /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
-    USARTx->CR3 &= CR3_ONEBITE_Reset;
-  }
-}
-
-/**
-  * @brief  Configures the USART's IrDA interface.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_IrDAMode: specifies the IrDA mode.
-  *   This parameter can be one of the following values:
-  *     @arg USART_IrDAMode_LowPower
-  *     @arg USART_IrDAMode_Normal
-  * @retval None
-  */
-void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
-    
-  USARTx->CR3 &= CR3_IRLP_Mask;
-  USARTx->CR3 |= USART_IrDAMode;
-}
-
-/**
-  * @brief  Enables or disables the USART's IrDA interface.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  NewState: new state of the IrDA mode.
-  *   This parameter can be: ENABLE or DISABLE.
-  * @retval None
-  */
-void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_FUNCTIONAL_STATE(NewState));
-    
-  if (NewState != DISABLE)
-  {
-    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
-    USARTx->CR3 |= CR3_IREN_Set;
-  }
-  else
-  {
-    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
-    USARTx->CR3 &= CR3_IREN_Reset;
-  }
-}
-
-/**
-  * @brief  Checks whether the specified USART flag is set or not.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_FLAG: specifies the flag to check.
-  *   This parameter can be one of the following values:
-  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
-  *     @arg USART_FLAG_LBD:  LIN Break detection flag
-  *     @arg USART_FLAG_TXE:  Transmit data register empty flag
-  *     @arg USART_FLAG_TC:   Transmission Complete flag
-  *     @arg USART_FLAG_RXNE: Receive data register not empty flag
-  *     @arg USART_FLAG_IDLE: Idle Line detection flag
-  *     @arg USART_FLAG_ORE:  OverRun Error flag
-  *     @arg USART_FLAG_NE:   Noise Error flag
-  *     @arg USART_FLAG_FE:   Framing Error flag
-  *     @arg USART_FLAG_PE:   Parity Error flag
-  * @retval The new state of USART_FLAG (SET or RESET).
-  */
-FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
-{
-  FlagStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_FLAG(USART_FLAG));
-  /* The CTS flag is not available for UART4 and UART5 */
-  if (USART_FLAG == USART_FLAG_CTS)
-  {
-    assert_param(IS_USART_123_PERIPH(USARTx));
-  }  
-  
-  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  return bitstatus;
-}
-
-/**
-  * @brief  Clears the USARTx's pending flags.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_FLAG: specifies the flag to clear.
-  *   This parameter can be any combination of the following values:
-  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
-  *     @arg USART_FLAG_LBD:  LIN Break detection flag.
-  *     @arg USART_FLAG_TC:   Transmission Complete flag.
-  *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
-  *   
-  * @note
-  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
-  *     error) and IDLE (Idle line detected) flags are cleared by software 
-  *     sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
-  *     followed by a read operation to USART_DR register (USART_ReceiveData()).
-  *   - RXNE flag can be also cleared by a read to the USART_DR register 
-  *     (USART_ReceiveData()).
-  *   - TC flag can be also cleared by software sequence: a read operation to 
-  *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
-  *     to USART_DR register (USART_SendData()).
-  *   - TXE flag is cleared only by a write to the USART_DR register 
-  *     (USART_SendData()).
-  * @retval None
-  */
-void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
-{
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
-  /* The CTS flag is not available for UART4 and UART5 */
-  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
-  {
-    assert_param(IS_USART_123_PERIPH(USARTx));
-  } 
-   
-  USARTx->SR = (uint16_t)~USART_FLAG;
-}
-
-/**
-  * @brief  Checks whether the specified USART interrupt has occurred or not.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_IT: specifies the USART interrupt source to check.
-  *   This parameter can be one of the following values:
-  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
-  *     @arg USART_IT_LBD:  LIN Break detection interrupt
-  *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
-  *     @arg USART_IT_TC:   Transmission complete interrupt
-  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
-  *     @arg USART_IT_IDLE: Idle line detection interrupt
-  *     @arg USART_IT_ORE:  OverRun Error interrupt
-  *     @arg USART_IT_NE:   Noise Error interrupt
-  *     @arg USART_IT_FE:   Framing Error interrupt
-  *     @arg USART_IT_PE:   Parity Error interrupt
-  * @retval The new state of USART_IT (SET or RESET).
-  */
-ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
-{
-  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
-  ITStatus bitstatus = RESET;
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_GET_IT(USART_IT));
-  /* The CTS interrupt is not available for UART4 and UART5 */ 
-  if (USART_IT == USART_IT_CTS)
-  {
-    assert_param(IS_USART_123_PERIPH(USARTx));
-  }   
-  
-  /* Get the USART register index */
-  usartreg = (((uint8_t)USART_IT) >> 0x05);
-  /* Get the interrupt position */
-  itmask = USART_IT & IT_Mask;
-  itmask = (uint32_t)0x01 << itmask;
-  
-  if (usartreg == 0x01) /* The IT  is in CR1 register */
-  {
-    itmask &= USARTx->CR1;
-  }
-  else if (usartreg == 0x02) /* The IT  is in CR2 register */
-  {
-    itmask &= USARTx->CR2;
-  }
-  else /* The IT  is in CR3 register */
-  {
-    itmask &= USARTx->CR3;
-  }
-  
-  bitpos = USART_IT >> 0x08;
-  bitpos = (uint32_t)0x01 << bitpos;
-  bitpos &= USARTx->SR;
-  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
-  {
-    bitstatus = SET;
-  }
-  else
-  {
-    bitstatus = RESET;
-  }
-  
-  return bitstatus;  
-}
-
-/**
-  * @brief  Clears the USARTx's interrupt pending bits.
-  * @param  USARTx: Select the USART or the UART peripheral. 
-  *   This parameter can be one of the following values:
-  *   USART1, USART2, USART3, UART4 or UART5.
-  * @param  USART_IT: specifies the interrupt pending bit to clear.
-  *   This parameter can be one of the following values:
-  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
-  *     @arg USART_IT_LBD:  LIN Break detection interrupt
-  *     @arg USART_IT_TC:   Transmission complete interrupt. 
-  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
-  *   
-  * @note
-  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
-  *     error) and IDLE (Idle line detected) pending bits are cleared by 
-  *     software sequence: a read operation to USART_SR register 
-  *     (USART_GetITStatus()) followed by a read operation to USART_DR register 
-  *     (USART_ReceiveData()).
-  *   - RXNE pending bit can be also cleared by a read to the USART_DR register 
-  *     (USART_ReceiveData()).
-  *   - TC pending bit can be also cleared by software sequence: a read 
-  *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
-  *     operation to USART_DR register (USART_SendData()).
-  *   - TXE pending bit is cleared only by a write to the USART_DR register 
-  *     (USART_SendData()).
-  * @retval None
-  */
-void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
-{
-  uint16_t bitpos = 0x00, itmask = 0x00;
-  /* Check the parameters */
-  assert_param(IS_USART_ALL_PERIPH(USARTx));
-  assert_param(IS_USART_CLEAR_IT(USART_IT));
-  /* The CTS interrupt is not available for UART4 and UART5 */
-  if (USART_IT == USART_IT_CTS)
-  {
-    assert_param(IS_USART_123_PERIPH(USARTx));
-  }   
-  
-  bitpos = USART_IT >> 0x08;
-  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
-  USARTx->SR = (uint16_t)~itmask;
-}
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_usart.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_usart.h
deleted file mode 100644
index 162fa87cc..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_usart.h
+++ /dev/null
@@ -1,412 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_usart.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the USART 
-  *          firmware library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_USART_H
-#define __STM32F10x_USART_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup USART
-  * @{
-  */ 
-
-/** @defgroup USART_Exported_Types
-  * @{
-  */ 
-
-/** 
-  * @brief  USART Init Structure definition  
-  */ 
-  
-typedef struct
-{
-  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
-                                           The baud rate is computed using the following formula:
-                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))
-                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */
-
-  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
-                                           This parameter can be a value of @ref USART_Word_Length */
-
-  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
-                                           This parameter can be a value of @ref USART_Stop_Bits */
-
-  uint16_t USART_Parity;              /*!< Specifies the parity mode.
-                                           This parameter can be a value of @ref USART_Parity
-                                           @note When parity is enabled, the computed parity is inserted
-                                                 at the MSB position of the transmitted data (9th bit when
-                                                 the word length is set to 9 data bits; 8th bit when the
-                                                 word length is set to 8 data bits). */
- 
-  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
-                                           This parameter can be a value of @ref USART_Mode */
-
-  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
-                                           or disabled.
-                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
-} USART_InitTypeDef;
-
-/** 
-  * @brief  USART Clock Init Structure definition  
-  */ 
-  
-typedef struct
-{
-
-  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
-                               This parameter can be a value of @ref USART_Clock */
-
-  uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
-                               This parameter can be a value of @ref USART_Clock_Polarity */
-
-  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
-                               This parameter can be a value of @ref USART_Clock_Phase */
-
-  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
-                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
-                               This parameter can be a value of @ref USART_Last_Bit */
-} USART_ClockInitTypeDef;
-
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Exported_Constants
-  * @{
-  */ 
-  
-#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
-                                     ((PERIPH) == USART2) || \
-                                     ((PERIPH) == USART3) || \
-                                     ((PERIPH) == UART4) || \
-                                     ((PERIPH) == UART5))
-
-#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \
-                                     ((PERIPH) == USART2) || \
-                                     ((PERIPH) == USART3))
-
-#define IS_USART_1234_PERIPH(PERIPH) (((PERIPH) == USART1) || \
-                                      ((PERIPH) == USART2) || \
-                                      ((PERIPH) == USART3) || \
-                                      ((PERIPH) == UART4))
-/** @defgroup USART_Word_Length 
-  * @{
-  */ 
-  
-#define USART_WordLength_8b                  ((uint16_t)0x0000)
-#define USART_WordLength_9b                  ((uint16_t)0x1000)
-                                    
-#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
-                                      ((LENGTH) == USART_WordLength_9b))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Stop_Bits 
-  * @{
-  */ 
-  
-#define USART_StopBits_1                     ((uint16_t)0x0000)
-#define USART_StopBits_0_5                   ((uint16_t)0x1000)
-#define USART_StopBits_2                     ((uint16_t)0x2000)
-#define USART_StopBits_1_5                   ((uint16_t)0x3000)
-#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
-                                     ((STOPBITS) == USART_StopBits_0_5) || \
-                                     ((STOPBITS) == USART_StopBits_2) || \
-                                     ((STOPBITS) == USART_StopBits_1_5))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Parity 
-  * @{
-  */ 
-  
-#define USART_Parity_No                      ((uint16_t)0x0000)
-#define USART_Parity_Even                    ((uint16_t)0x0400)
-#define USART_Parity_Odd                     ((uint16_t)0x0600) 
-#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
-                                 ((PARITY) == USART_Parity_Even) || \
-                                 ((PARITY) == USART_Parity_Odd))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Mode 
-  * @{
-  */ 
-  
-#define USART_Mode_Rx                        ((uint16_t)0x0004)
-#define USART_Mode_Tx                        ((uint16_t)0x0008)
-#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Hardware_Flow_Control 
-  * @{
-  */ 
-#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
-#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
-#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
-#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
-#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
-                              (((CONTROL) == USART_HardwareFlowControl_None) || \
-                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
-                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
-                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Clock 
-  * @{
-  */ 
-#define USART_Clock_Disable                  ((uint16_t)0x0000)
-#define USART_Clock_Enable                   ((uint16_t)0x0800)
-#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
-                               ((CLOCK) == USART_Clock_Enable))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Clock_Polarity 
-  * @{
-  */
-  
-#define USART_CPOL_Low                       ((uint16_t)0x0000)
-#define USART_CPOL_High                      ((uint16_t)0x0400)
-#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
-
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Clock_Phase
-  * @{
-  */
-
-#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
-#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
-#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
-
-/**
-  * @}
-  */
-
-/** @defgroup USART_Last_Bit
-  * @{
-  */
-
-#define USART_LastBit_Disable                ((uint16_t)0x0000)
-#define USART_LastBit_Enable                 ((uint16_t)0x0100)
-#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
-                                   ((LASTBIT) == USART_LastBit_Enable))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Interrupt_definition 
-  * @{
-  */
-  
-#define USART_IT_PE                          ((uint16_t)0x0028)
-#define USART_IT_TXE                         ((uint16_t)0x0727)
-#define USART_IT_TC                          ((uint16_t)0x0626)
-#define USART_IT_RXNE                        ((uint16_t)0x0525)
-#define USART_IT_IDLE                        ((uint16_t)0x0424)
-#define USART_IT_LBD                         ((uint16_t)0x0846)
-#define USART_IT_CTS                         ((uint16_t)0x096A)
-#define USART_IT_ERR                         ((uint16_t)0x0060)
-#define USART_IT_ORE                         ((uint16_t)0x0360)
-#define USART_IT_NE                          ((uint16_t)0x0260)
-#define USART_IT_FE                          ((uint16_t)0x0160)
-#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
-                               ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
-                               ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
-                               ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
-#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
-                            ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
-                            ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
-                            ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
-                            ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
-#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
-                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
-/**
-  * @}
-  */
-
-/** @defgroup USART_DMA_Requests 
-  * @{
-  */
-
-#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
-#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
-#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))
-
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_WakeUp_methods
-  * @{
-  */
-
-#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
-#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
-#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
-                                 ((WAKEUP) == USART_WakeUp_AddressMark))
-/**
-  * @}
-  */
-
-/** @defgroup USART_LIN_Break_Detection_Length 
-  * @{
-  */
-  
-#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
-#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
-#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
-                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
-                                ((LENGTH) == USART_LINBreakDetectLength_11b))
-/**
-  * @}
-  */
-
-/** @defgroup USART_IrDA_Low_Power 
-  * @{
-  */
-
-#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
-#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
-#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
-                                  ((MODE) == USART_IrDAMode_Normal))
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Flags 
-  * @{
-  */
-
-#define USART_FLAG_CTS                       ((uint16_t)0x0200)
-#define USART_FLAG_LBD                       ((uint16_t)0x0100)
-#define USART_FLAG_TXE                       ((uint16_t)0x0080)
-#define USART_FLAG_TC                        ((uint16_t)0x0040)
-#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
-#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
-#define USART_FLAG_ORE                       ((uint16_t)0x0008)
-#define USART_FLAG_NE                        ((uint16_t)0x0004)
-#define USART_FLAG_FE                        ((uint16_t)0x0002)
-#define USART_FLAG_PE                        ((uint16_t)0x0001)
-#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
-                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
-                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
-                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
-                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
-                              
-#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))
-#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(uint32_t*)&(PERIPH)) != UART4_BASE) &&\
-                                                  ((*(uint32_t*)&(PERIPH)) != UART5_BASE)) \
-                                                  || ((USART_FLAG) != USART_FLAG_CTS)) 
-#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x0044AA21))
-#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
-#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Exported_Macros
-  * @{
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup USART_Exported_Functions
-  * @{
-  */
-
-void USART_DeInit(USART_TypeDef* USARTx);
-void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
-void USART_StructInit(USART_InitTypeDef* USART_InitStruct);
-void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
-void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
-void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
-void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
-void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
-void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
-void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
-void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
-uint16_t USART_ReceiveData(USART_TypeDef* USARTx);
-void USART_SendBreak(USART_TypeDef* USARTx);
-void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
-void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
-void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
-void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
-void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
-FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
-void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
-ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
-void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_USART_H */
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_wwdg.c b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_wwdg.c
deleted file mode 100644
index 4a901e4ed..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_wwdg.c
+++ /dev/null
@@ -1,224 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_wwdg.c
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file provides all the WWDG firmware functions.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x_wwdg.h"
-#include "stm32f10x_rcc.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @defgroup WWDG 
-  * @brief WWDG driver modules
-  * @{
-  */
-
-/** @defgroup WWDG_Private_TypesDefinitions
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup WWDG_Private_Defines
-  * @{
-  */
-
-/* ----------- WWDG registers bit address in the alias region ----------- */
-#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
-
-/* Alias word address of EWI bit */
-#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
-#define EWI_BitNumber     0x09
-#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))
-
-/* --------------------- WWDG registers bit mask ------------------------ */
-
-/* CR register bit mask */
-#define CR_WDGA_Set       ((uint32_t)0x00000080)
-
-/* CFR register bit mask */
-#define CFR_WDGTB_Mask    ((uint32_t)0xFFFFFE7F)
-#define CFR_W_Mask        ((uint32_t)0xFFFFFF80)
-#define BIT_Mask          ((uint8_t)0x7F)
-
-/**
-  * @}
-  */
-
-/** @defgroup WWDG_Private_Macros
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup WWDG_Private_Variables
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup WWDG_Private_FunctionPrototypes
-  * @{
-  */
-
-/**
-  * @}
-  */
-
-/** @defgroup WWDG_Private_Functions
-  * @{
-  */
-
-/**
-  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
-  * @param  None
-  * @retval None
-  */
-void WWDG_DeInit(void)
-{
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
-  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
-}
-
-/**
-  * @brief  Sets the WWDG Prescaler.
-  * @param  WWDG_Prescaler: specifies the WWDG Prescaler.
-  *   This parameter can be one of the following values:
-  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
-  *     @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
-  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
-  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
-  * @retval None
-  */
-void WWDG_SetPrescaler(uint32_t WWDG_Prescaler)
-{
-  uint32_t tmpreg = 0;
-  /* Check the parameters */
-  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
-  /* Clear WDGTB[1:0] bits */
-  tmpreg = WWDG->CFR & CFR_WDGTB_Mask;
-  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
-  tmpreg |= WWDG_Prescaler;
-  /* Store the new value */
-  WWDG->CFR = tmpreg;
-}
-
-/**
-  * @brief  Sets the WWDG window value.
-  * @param  WindowValue: specifies the window value to be compared to the downcounter.
-  *   This parameter value must be lower than 0x80.
-  * @retval None
-  */
-void WWDG_SetWindowValue(uint8_t WindowValue)
-{
-  __IO uint32_t tmpreg = 0;
-
-  /* Check the parameters */
-  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
-  /* Clear W[6:0] bits */
-
-  tmpreg = WWDG->CFR & CFR_W_Mask;
-
-  /* Set W[6:0] bits according to WindowValue value */
-  tmpreg |= WindowValue & (uint32_t) BIT_Mask;
-
-  /* Store the new value */
-  WWDG->CFR = tmpreg;
-}
-
-/**
-  * @brief  Enables the WWDG Early Wakeup interrupt(EWI).
-  * @param  None
-  * @retval None
-  */
-void WWDG_EnableIT(void)
-{
-  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
-}
-
-/**
-  * @brief  Sets the WWDG counter value.
-  * @param  Counter: specifies the watchdog counter value.
-  *   This parameter must be a number between 0x40 and 0x7F.
-  * @retval None
-  */
-void WWDG_SetCounter(uint8_t Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_WWDG_COUNTER(Counter));
-  /* Write to T[6:0] bits to configure the counter value, no need to do
-     a read-modify-write; writing a 0 to WDGA bit does nothing */
-  WWDG->CR = Counter & BIT_Mask;
-}
-
-/**
-  * @brief  Enables WWDG and load the counter value.                  
-  * @param  Counter: specifies the watchdog counter value.
-  *   This parameter must be a number between 0x40 and 0x7F.
-  * @retval None
-  */
-void WWDG_Enable(uint8_t Counter)
-{
-  /* Check the parameters */
-  assert_param(IS_WWDG_COUNTER(Counter));
-  WWDG->CR = CR_WDGA_Set | Counter;
-}
-
-/**
-  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.
-  * @param  None
-  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
-  */
-FlagStatus WWDG_GetFlagStatus(void)
-{
-  return (FlagStatus)(WWDG->SR);
-}
-
-/**
-  * @brief  Clears Early Wakeup interrupt flag.
-  * @param  None
-  * @retval None
-  */
-void WWDG_ClearFlag(void)
-{
-  WWDG->SR = (uint32_t)RESET;
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_wwdg.h b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_wwdg.h
deleted file mode 100644
index bdfa177b0..000000000
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/DeviceCode/stmlib/stm32f10x_wwdg.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    stm32f10x_wwdg.h
-  * @author  MCD Application Team
-  * @version V3.5.0
-  * @date    11-March-2011
-  * @brief   This file contains all the functions prototypes for the WWDG firmware
-  *          library.
-  ******************************************************************************
-  * @attention
-  *
-  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
-  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
-  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
-  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
-  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-  *
-  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
-  ******************************************************************************
-  */
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __STM32F10x_WWDG_H
-#define __STM32F10x_WWDG_H
-
-#ifdef __cplusplus
- extern "C" {
-#endif
-
-/* Includes ------------------------------------------------------------------*/
-#include "stm32f10x.h"
-
-/** @addtogroup STM32F10x_StdPeriph_Driver
-  * @{
-  */
-
-/** @addtogroup WWDG
-  * @{
-  */ 
-
-/** @defgroup WWDG_Exported_Types
-  * @{
-  */ 
-  
-/**
-  * @}
-  */ 
-
-/** @defgroup WWDG_Exported_Constants
-  * @{
-  */ 
-  
-/** @defgroup WWDG_Prescaler 
-  * @{
-  */ 
-  
-#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
-#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
-#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
-#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
-#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
-                                      ((PRESCALER) == WWDG_Prescaler_2) || \
-                                      ((PRESCALER) == WWDG_Prescaler_4) || \
-                                      ((PRESCALER) == WWDG_Prescaler_8))
-#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
-#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/** @defgroup WWDG_Exported_Macros
-  * @{
-  */ 
-/**
-  * @}
-  */ 
-
-/** @defgroup WWDG_Exported_Functions
-  * @{
-  */ 
-  
-void WWDG_DeInit(void);
-void WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
-void WWDG_SetWindowValue(uint8_t WindowValue);
-void WWDG_EnableIT(void);
-void WWDG_SetCounter(uint8_t Counter);
-void WWDG_Enable(uint8_t Counter);
-FlagStatus WWDG_GetFlagStatus(void);
-void WWDG_ClearFlag(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __STM32F10x_WWDG_H */
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/**
-  * @}
-  */ 
-
-/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
diff --git a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/SmartFusion2.settings b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/SmartFusion2.settings
index c4864aa87..97b2ffeb8 100644
--- a/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/SmartFusion2.settings
+++ b/MicroFrameworkPK_v4_3/DeviceCode/Targets/Native/SmartFusion2/SmartFusion2.settings
@@ -27,6 +27,6 @@
   </PropertyGroup>
   <ItemGroup>
     <IncludePaths Include="devicecode\Targets\Native\SmartFusion2" />
-	<IncludePaths Include="devicecode\Targets\Native\STM32F10x" />
+	<!--<IncludePaths Include="devicecode\Targets\Native\STM32F10x" /> -->
   </ItemGroup>
 </Project>
diff --git a/MicroFrameworkPK_v4_3/Samraksh/APPS/Cryptoki/Cryptoki/Encryption.csproj b/MicroFrameworkPK_v4_3/Samraksh/APPS/Cryptoki/Cryptoki/Encryption.csproj
index 4338a2685..b47316a10 100644
--- a/MicroFrameworkPK_v4_3/Samraksh/APPS/Cryptoki/Cryptoki/Encryption.csproj
+++ b/MicroFrameworkPK_v4_3/Samraksh/APPS/Cryptoki/Cryptoki/Encryption.csproj
@@ -41,6 +41,18 @@
     </Compile>
   </ItemGroup>
 
+
+  
+  <ItemGroup>
+    <EmbeddedResource Include="Resources.resx">
+      <SubType>Designer</SubType>
+      <Generator>ResXFileCodeGenerator</Generator>
+      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
+    </EmbeddedResource>
+  </ItemGroup>
+ 
+  <!-- If building in Visual Studio use the block under this 
+  
   <ItemGroup>
     <Reference Include="Microsoft.SPOT.Native">
 		<HintPath>$(SPOCLIENT)\BuildOutput\public\Debug\Client\</HintPath>
@@ -53,25 +65,28 @@
     </Reference>
   </ItemGroup>
   
-  <ItemGroup>
-    <EmbeddedResource Include="Resources.resx">
-      <SubType>Designer</SubType>
-      <Generator>ResXFileCodeGenerator</Generator>
-      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
-    </EmbeddedResource>
-  </ItemGroup>
- 
-  <!-- If building in Visual Studio use the block under this -->
   <Import Condition="EXISTS('$(NetMfTargetsBaseDir)$(TargetFrameworkVersion)\CSharp.Targets')" Project="$(NetMfTargetsBaseDir)$(TargetFrameworkVersion)\CSharp.Targets" />
   <Import Condition="!EXISTS('$(NetMfTargetsBaseDir)$(TargetFrameworkVersion)\CSharp.Targets')" Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  -->
   
-  
- <!-- If building on command line use the block under this 
+ <!-- If building on command line use the block under this  -->
+ 
+ <ItemGroup>
+    <Reference Include="Microsoft.SPOT.Native">
+		<HintPath>$(SPOCLIENT)\BuildOutput\public\Debug\Client\dll\Microsoft.SPOT.Native.dll</HintPath>
+    </Reference>
+    <Reference Include="Microsoft.SPOT.Security.PKCS11">
+		<HintPath>$(SPOCLIENT)\BuildOutput\public\Debug\Client\dll\Microsoft.SPOT.Security.PKCS11.dll</HintPath>
+    </Reference>
+    <Reference Include="System.Security">
+		<HintPath>$(SPOCLIENT)\BuildOutput\public\Debug\Client\dll\System.Security.dll</HintPath>
+    </Reference>
+  </ItemGroup>
+ 
  <Import Project="$(SPOCLIENT)\tools\Targets\Microsoft.SPOT.CSharp.Targets" /> 
   <PropertyGroup>
     <MMP_PE_NoBitmapCompression>true</MMP_PE_NoBitmapCompression>
     <MMP_DAT_SKIP>false</MMP_DAT_SKIP>
     <MMP_DAT_CreateDatabaseFile>bin\$(Configuration)\aes.dat</MMP_DAT_CreateDatabaseFile>
   </PropertyGroup>
- -->
 </Project>
\ No newline at end of file
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Crypto.c b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Crypto.c
new file mode 100644
index 000000000..268c4f780
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Crypto.c
@@ -0,0 +1,85 @@
+/*
+ * Crypto.c
+ *
+ *  Created on: Apr 6, 2018
+ *      Author: MukundanSridharan
+ */
+#include "Crypto.h"
+
+CRYPTO_RESULT Crypto_GetFingerprint(BYTE *key, BYTE *Signature, int cbSignatureSize)
+{
+    return CRYPTO_SUCCESS;
+}
+BOOL Crypto_GetActivationStringFromSeed(char *pString, int cbStringSize, KeySeed *Seed, UINT16 region, UINT16 model)
+{
+    return FALSE;
+}
+
+// Encrypts a buffer using a symmetric algorithm.
+BOOL Crypto_Encrypt(BYTE *Key, BYTE *IV, DWORD cbIVSize, BYTE* pPlainText, DWORD cbPlainText, BYTE *pCypherText, DWORD cbCypherText)
+{
+    return FALSE;
+}
+
+// Decrypts a buffer using a symmetric algorithm
+BOOL Crypto_Decrypt(BYTE *Key, BYTE *IV, DWORD cbIVSize, BYTE *pCypherText, DWORD cbCypherText, BYTE* pPlainText, DWORD cbPlainText)
+{
+    return FALSE;
+}
+
+const RSABuffer MSPublicKeyModulus = {0};
+
+CRYPTO_RESULT Crypto_StartRSAOperationWithKey(enum RSAOperations operation, RSAKey *pRSAKey, BYTE *pSourceText, DWORD cbSourceText, BYTE *pDestText, DWORD cbDestText,
+                               void **ppHandle)
+{
+    return CRYPTO_SUCCESS;
+}
+
+//
+// this function continues a RSA operation (using the handle returned by a previous call to
+// Crypto_StartRsaOperationWithKey or Crypto_StepRsaOperation). It returns an error code(< 0), CRYPTO_SUCCESS (= 0), or CRYPTO_CONTINUE (=1)
+// For the client, the caller may either call this function in a loop itself and use the return value to check for the end of the process
+// or use the continuation mechanism and check the contents of pResult parameter at intervals.
+// The continuation mechanism is stubbed out on the server, so the caller needs to keep calling the function until it stops returning CRYPTO_CONTINUE
+// !!! Mar 12: removed continuation mechanism - coscor !!!
+
+//CRYPTO_RESULT Crypto_StepRSAOperation(void** pHandle);
+
+CRYPTO_RESULT Crypto_AbortRSAOperation(void** pHandle)
+{
+    return CRYPTO_SUCCESS;
+}
+
+CRYPTO_RESULT Crypto_GeneratePrivateKey(KeySeed *pSeed, RSAKey* pPrivateKey)
+{
+    return CRYPTO_SUCCESS;
+}
+
+CRYPTO_RESULT Crypto_PublicKeyFromPrivate(const RSAKey *privateKey, RSAKey*publicKey)
+{
+    return CRYPTO_SUCCESS;
+}
+
+CRYPTO_RESULT Crypto_PublicKeyFromModulus(const RSABuffer *modulus, RSAKey *key)
+{
+    return CRYPTO_SUCCESS;
+}
+
+CRYPTO_RESULT GetC1Value(BYTE *key, BYTE *C1, int cbC1)
+{
+    return CRYPTO_SUCCESS;
+}
+
+CRYPTO_RESULT Crypto_KeySeedFromLaser(const BYTE *laserData, KeySeed* keySeed)
+{
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_RESULT Crypto_StepRSAOperation(void** pHandle)
+{
+    return CRYPTO_SUCCESS;
+}
+
+
+
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Tokens/SF2_HW_PKCS11_objects.cpp b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Tokens/SF2_HW_PKCS11_objects.cpp
index 62a052560..34686f174 100644
--- a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Tokens/SF2_HW_PKCS11_objects.cpp
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/DeviceCode/Crypto/Tokens/SF2_HW_PKCS11_objects.cpp
@@ -199,7 +199,7 @@ CK_RV SF2_HW_PKCS11_Objects::DestroyObject(Cryptoki_Session_Context* pSessionCtx
 			return CKR_FUNCTION_NOT_SUPPORTED;
 		}
 
-		return FreeObject(pSessionCtx, hObject) == NULL ? CKR_OBJECT_HANDLE_INVALID : CKR_OK;
+		return FreeObject(pSessionCtx, hObject) ? CKR_OK:CKR_OBJECT_HANDLE_INVALID;
 	}
 
 	return CKR_OK;
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooter.h b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooter.h
deleted file mode 100644
index 1c396b52a..000000000
--- a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooter.h
+++ /dev/null
@@ -1,24 +0,0 @@
-//-----------------------------------------------------------------------------
-//
-//  <No description>
-//
-//  Microsoft dotNetMF Project
-//  Copyright ï¿½2001,2002 Microsoft Corporation
-//  One Microsoft Way, Redmond, Washington 98052-6399 U.S.A.
-//  All rights reserved.
-//  MICROSOFT CONFIDENTIAL
-//
-//-----------------------------------------------------------------------------
-
-#ifndef __MICROBOOTER_H__
-#define __MICROBOOTER_H__
-
-/////////////////////////////////////////////////////////////////////////////
-
-#include <Tinyhal.h>
-#include <MicroBooter_decl.h>
-
-
-/////////////////////////////////////////////////////////////////////////////
-
-#endif /* __MICROBOOTER_H__ */
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooter.proj b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooter.proj
deleted file mode 100644
index 013362b0f..000000000
--- a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooter.proj
+++ /dev/null
@@ -1,261 +0,0 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
-  <PropertyGroup>
-    <AssemblyName>MicroBooter</AssemblyName>
-    <ProjectGuid>{58b019a8-d75e-4b74-89c9-62babf77044f}</ProjectGuid>
-    <Description />
-    <Documentation />
-    <Directory>Solutions\SmartFusion2\MicroBooter</Directory>
-    <IsClrProject>False</IsClrProject>
-    <InteropFeatures />
-    <ExtraAssemblies />
-    <ProjectPath>$(SPOCLIENT)\Solutions\SmartFusion2\MicroBooter\MicroBooter.proj</ProjectPath>
-    <MFSettingsFile>$(SPOCLIENT)\Solutions\SmartFusion2\SmartFusion2.settings</MFSettingsFile>
-    <IsSolutionWizardVisible>True</IsSolutionWizardVisible>
-  </PropertyGroup>
-  <PropertyGroup>
-    <SamAppName>MICROBOOTER</SamAppName>
-  </PropertyGroup>
-  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Settings" />
-  <PropertyGroup>
-    <Size />
-    <Level />
-    <ProjectPath>$(SPOCLIENT)\ProjectTemplates\MicroBooter\MicroBooter.proj</ProjectPath>
-    <ManifestFile />
-    <Groups />
-    <CustomSpecific />
-    <IsStub>False</IsStub>
-    <reducesize>true</reducesize>
-    <OutputType>Executable</OutputType>
-    <ADD_LOAD_IMAGE_CRC>true</ADD_LOAD_IMAGE_CRC>
-    <CustomAssemblyName>MicroBooter</CustomAssemblyName>
-    <ExtraTargets>BuildSigFiles</ExtraTargets>
-    <EXEScatterFileDefinition>$(SRC_DIR)\scatterfile_microbooter_$(COMPILER_TOOL).$(SCATTER_EXT)</EXEScatterFileDefinition>
-  </PropertyGroup>
-  <ItemGroup />
-  <ItemGroup>
-    <Compile Include="$(SPOCLIENT)\DeviceCode\Cores\arm\AssemblyCode\arm\$(AS_SUBDIR)\FirstEntry.s" Condition=" '$(INSTRUCTION_SET)'=='arm' or '$(INSTRUCTION_SET)'=='thumb'" />
-    <Compile Include="$(SPOCLIENT)\DeviceCode\Cores\arm\AssemblyCode\arm\$(AS_SUBDIR)\IDelayLoop.s" Condition=" '$(INSTRUCTION_SET)'=='arm' or '$(INSTRUCTION_SET)'=='thumb'" />
-    <Compile Include="$(SPOCLIENT)\DeviceCode\Cores\arm\AssemblyCode\arm\$(AS_SUBDIR)\VectorsTrampolines.s" Condition=" '$(INSTRUCTION_SET)'=='arm' or '$(INSTRUCTION_SET)'=='thumb'" />
-    <Compile Include="$(SPOCLIENT)\DeviceCode\Cores\arm\AssemblyCode\thumb2\$(AS_SUBDIR)\FirstEntry.s" Condition=" '$(INSTRUCTION_SET)'=='thumb2'" />
-    <Compile Include="$(SPOCLIENT)\DeviceCode\Cores\arm\AssemblyCode\thumb2\$(AS_SUBDIR)\IDelayLoop.s" Condition=" '$(INSTRUCTION_SET)'=='thumb2'" />
-    <Compile Include="$(SPOCLIENT)\DeviceCode\Cores\arm\AssemblyCode\thumb2\$(AS_SUBDIR)\VectorsTrampolines.s" Condition=" '$(INSTRUCTION_SET)'=='thumb2'" />
-    <Compile Include="$(SRC_DIR)\MicrobooterExt.cpp" />
-    <HFiles Include="$(SPOCLIENT)\devicecode\include\mfupdate_decl.h" />
-    <HFiles Include="$(SPOCLIENT)\devicecode\include\microbooter_decl.h" />
-    <HFiles Include="microbooter.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="MicroBooterLib.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\Application\MicroBooter\MicroBooter.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_analog_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_analog\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="asyncproccall_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\AsyncProcCall\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_bootstrap_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\drivers\stubs\processor\stubs_bootstrap\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_cache_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_cache\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="usart_pal.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\USART\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="usb_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\USB\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="config_pal_loader.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Configuration\dotNetMF_loader.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <PlatformIndependentLibs Include="CRC.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\Support\CRC\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Crypto_stub.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\Crypto\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="diagnostics_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Diagnostics\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_ebiu_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_EBIU\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="events_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Events\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="GlobalLock_hal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\GlobalLock\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="SH7264_Keypad.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\sh7264\DeviceCode\Keypad\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="system_initialization_hal_loader.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Initialization\dotNetMF_loader.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Time_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\Time\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_intc_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\drivers\stubs\processor\stubs_INTC\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_power_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_power\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_prestackinit_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\Stubs\Processor\stubs_PreStackInit\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_pwm_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_PWM\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="SimpleHeap_config_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\SimpleHeap_config\Stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="SimpleHeap_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\SimpleHeap\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_time_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\drivers\stubs\processor\stubs_time\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="tinycrt_pal_loader.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\devicecode\pal\TinyCRT\dotNetMF_loader.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="TinyHal_loader.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\cores\arm\dotNetMF_loader.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_watchdog_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\Processor\stubs_watchdog\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Watchdog_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\Watchdog\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <PlatformIndependentLibs Include="WireProtocol.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\Support\WireProtocol\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="heap_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Heap\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="TimeService_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\TimeService\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="palevent_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\palevent\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Gesture_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\Gesture\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Ink_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\Ink\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_spi_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\drivers\stubs\processor\stubs_spi\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="piezo_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Piezo\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_mmu_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_MMU\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="lcd_hal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\Display\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_LCD_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\stubs\processor\stubs_lcd\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="i2c_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\I2C\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="fs_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\fs\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="FS_Config_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\FS\stubs\config\dotnetmf.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="sockets_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\Sockets\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="COM_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Buttons_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Buttons\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="BlockStorage_AddDevices_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\drivers\stubs\Blockstorage\addDevices\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="blockstorage_pal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\BlockStorage\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="batterymeasurement_hal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\BatteryMeasurement\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="batterycharger_hal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\BatteryCharger\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="backlight_hal_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\Backlight\stubs\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="cpu_usart_stubs.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Drivers\Stubs\processor\stubs_USART\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="Analog_DA_HAL_EmoteDotNow.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\Solutions\SmartFusion2\DeviceCode\Analog_DA_HAL\dotNetMF.proj" />
-  </ItemGroup>
-  <ItemGroup>
-    <DriverLibs Include="native_double_pal.$(LIB_EXT)" />
-    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Double\dotNetMF.proj" />
-  </ItemGroup>
-  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Targets" />
-</Project>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/scatterfile_microbooter_rvds.xml b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/scatterfile_microbooter_rvds.xml
deleted file mode 100644
index d1612e015..000000000
--- a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/scatterfile_microbooter_rvds.xml
+++ /dev/null
@@ -1,118 +0,0 @@
-<?xml version="1.0"?>
-<ScatterFile xmlns="http://schemas.microsoft.com/netmf/ScatterfileSchema.xsd">
-
-    <!-- Freescale MC9328L, NO SRAM, SDRAM 32M/64M -->
-
-    <Set Name="Valid" Value="false"/>
-
-    <!-- ################################################################################ -->
-
-    <Set Name="Heap_Begin"      Value="0x08100000"/>
-    <Set Name="Heap_End"        Value="0x084FFFF8"/>
-    <Set Name="Stack_Bottom"    Value="+0"/>
-    <Set Name="Stack_Top"       Value="0x08502000"/>
-
-    
-    <If Name="TARGETLOCATION" In="FLASH">
-
-        <!-- iMXS has 8MB of 32-bit FLASH at 0x10000000 -->
-        <Set Name="Code_BaseAddress" Value="0x10000000"/>
-        <Set Name="Code_Size"        Value="0x00020000"/>
-        <Set Name="RAM_RO_Base"      Value="0x00000000"/>
-        <Set Name="Valid"            Value="true"/>
-
-    </If>
-
-    <If Name="TARGETLOCATION" In="RAM">
-
-        <Set Name="Code_BaseAddress" Value="0x08200000"/> 
-        <Set Name="Code_Size"        Value="0x00030000"/>
-        <Set Name="RAM_RO_Base"      Value="+0"/>
-        <Set Name="Valid"            Value="true"/>
-        
-    </If>
-
-
-    <!-- ################################################################################ -->
-
-    <If Name="Valid" Value="false">
-        <Error Message="Configuration not recognized"/>
-    </If>
-
-    <!-- we start at 0x10080000 since PortBooter lives at 0x10000000 -->
-    <!-- the address and sizes for both load regions (LR_*) are chosen to start and completely fill a flash partition in the 28F320W18 flash chip -->
-
-    <LoadRegion Name="LR_%TARGETLOCATION%" Base="%Code_BaseAddress%" Options="ABSOLUTE" Size="%Code_Size%">
-
-        <!-- we have arbitrarily asigned 0x00080000 offset in FLASH for the CLR code, and size of 0x00080000 -->
-
-        <ExecRegion Name="ER_%TARGETLOCATION%" Base="%Code_BaseAddress%" Options="FIXED" Size="">
-
-            <FileMapping Name="FirstEntry.obj" Options="(+RO, +FIRST)" /> <!-- the entry pointer section goes into this region -->
-
-            <FileMapping Name="*" Options="(SectionForBootstrapOperations)" />
-            <FileMapping Name="*" Options="(+RO)" />
-
-        </ExecRegion>
-
-        <!-- skip vector area -->
-
-        <ExecRegion Name="ER_RAM_RO" Base="%RAM_RO_Base%" Options="ABSOLUTE" Size="">
-
-            <FileMapping Name="VectorsTrampolines.obj" Options="(+RO, +FIRST)" /> <!-- for vector handlers to be far from the vectors -->
-
-            <FileMapping Name="*" Options="(i.IDelayLoop)" Comment="00004a98 24 16 IDelayLoop" />
-            <FileMapping Name="*" Options="(i._Z23Time_Sleep_MicroSecondsj)" Comment="_Z23Time_Sleep_MicroSecondsj" />
-            <FileMapping Name="*" Options="(i._Z40Time_Sleep_MicroSeconds_InterruptEnabledj)" Comment="_Z40Time_Sleep_MicroSeconds_InterruptEnabledj" />
-            <FileMapping Name="*" Options="(i._Z23CPU_MicrosecondsToTicksj)" Comment="_Z23CPU_MicrosecondsToTicksj" />    
-            <FileMapping Name="*" Options="(i._Z17Events_MaskedReadj)" Comment="000070ec 20 20787 Events_MaskedRead__FUi" />
-            <FileMapping Name="*" Options="(i._ZN16MC9328MXL_Driver5PauseEv)" />
-            <FileMapping Name="*" Options="(i._ZN21MC9328MXL_TIME_Driver12CounterValueEv)" Comment="00007840 40 712150 _ZN21MC9328MXL_TIME_Driver12CounterValueEv" />
-            <FileMapping Name="*" Options="(i._ZN21MC9328MXL_AITC_Driver17ActivateInterruptEjjPFvPvES0_h)" Comment="00007604 76 231095 _ZN21MC9328MXL_AITC_Driver17ActivateInterruptEjjPFvPvES0_h" />
-            <FileMapping Name="*" Options="(i._ZN21MC9328MXL_AITC_Driver19DeactivateInterruptEj)" Comment="00007604 76 231095 _ZN21MC9328MXL_AITC_Driver19DeactivateInterruptEj" />
-            <FileMapping Name="*" Options="(i._ZN21MC9328MXL_TIME_Driver15SetCompareValueEy)" Comment="00007868 96 181492 _ZN21MC9328MXL_TIME_Driver15SetCompareValueEy" />
-            <FileMapping Name="*" Options="(i._ZN21MC9328MXL_TIME_Driver11CurrentTimeEv)" Comment="000079d0 88 94500 _ZN21MC9328MXL_TIME_Driver11CurrentTimeEv" />
-            <FileMapping Name="*" Options="(i._ZN25MC9328MXL_WATCHDOG_Driver12ResetCounterEv)" Comment="00007adc 24 22218 _ZN25MC9328MXL_WATCHDOG_Driver12ResetCounterEv" />
-            <FileMapping Name="*" Options="(i._Z18SUPPORT_ComputeCRCPKvij)" Comment="00006654 72 1709347 SUPPORT_ComputeCRC__FPCviUi" />
-            <FileMapping Name="rt_sdiv.o" Options="(+RO)" />
-            <FileMapping Name="rt_memclr.o" Options="(+RO)" />
-            <FileMapping Name="rt_memclr_w.o" Options="(+RO)" />
-            <FileMapping Name="rt_memcpy.o" Options="(+RO)" />
-            <FileMapping Name="rt_memcpy_w.o" Options="(+RO)" />
-            <FileMapping Name="llshl.o" Options="(+RO)" />
-            <FileMapping Name="llsdiv.o" Options="(+RO)" />
-            <FileMapping Name="llushr.o" Options="(+RO)" />
-            <FileMapping Name="lludiv.o" Options="(+RO)" />
-
-            <FileMapping Name="*" Options="(SectionForFlashOperations)" />
-
-        </ExecRegion>
-
-        <ExecRegion Name="ER_RAM_RW" Base="+0" Options="ABSOLUTE" Size="">
-
-            <FileMapping Name="*" Options="(+RW-DATA, +ZI)" />
-
-        </ExecRegion>
-
-        <ExecRegion Name="ER_HEAP_BEGIN" Base="%Heap_Begin%" Options="ABSOLUTE" Size="UNINIT">
-            <FileMapping Name="*" Options="(SectionForHeapBegin)" />
-        </ExecRegion>
-
-        <!-- everything between heapbegin and heapend will be allocated for a heap -->
-
-        <ExecRegion Name="ER_HEAP_END" Base="%Heap_End%" Options="ABSOLUTE" Size="UNINIT">
-            <FileMapping Name="*" Options="(SectionForHeapEnd)" />
-        </ExecRegion>
-
-
-        <ExecRegion Name="ER_STACK_BOTTOM" Base="%Stack_Bottom%" Options="ABSOLUTE" Size="UNINIT">
-            <FileMapping Name="*" Options="(SectionForStackBottom)" />
-        </ExecRegion>
-	    
-        <ExecRegion Name="ER_STACK_TOP" Base="%Stack_Top%" Options="ABSOLUTE" Size="UNINIT">
-            <FileMapping Name="*" Options="(SectionForStackTop)" />
-        </ExecRegion>
-
-    </LoadRegion>
-
-</ScatterFile>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooterExt.cpp b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/MicroBooter.cpp
similarity index 100%
rename from MicroFrameworkPK_v4_3/Solutions/SmartFusion2/MicroBooter/MicroBooterExt.cpp
rename to MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/MicroBooter.cpp
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.cpp b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.cpp
new file mode 100644
index 000000000..d07499f7a
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.cpp
@@ -0,0 +1,233 @@
+/*
+ * RoT.cpp
+ *
+ *  Created on: Apr 25, 2018
+ *      Author: MukundanSridharan
+ */
+
+//include
+#include <Tinyhal.h>
+
+void BootEntryLoader();
+
+void EntryPoint(){
+	while(1){
+		BootEntryLoader();
+	}
+}
+
+/*
+int hal_vsnprintf( char* buffer, size_t len, const char* format, va_list arg )
+{
+    NATIVE_PROFILE_PAL_CRT();
+
+#if defined(HAL_REDUCESIZE) || defined(PLATFORM_EMULATED_FLOATINGPOINT)
+
+#undef _vsnprintf
+
+    // _vsnprintf do not support floating point, vs vsnprintf supports floating point
+
+    return _vsnprintf( buffer, len, format, arg );
+
+#define _vsnprintf  DoNotUse_*printf []
+
+#else
+
+#undef vsnprintf
+
+    return vsnprintf( buffer, len, format, arg );
+
+#define vsnprintf  DoNotUse_*printf []
+
+#endif
+
+}
+*/
+
+/*
+void debug_printf( const char* format, ... )
+{
+    char    buffer[256];
+    va_list arg_ptr;
+
+    va_start( arg_ptr, format );
+
+   //int len = hal_vsnprintf( buffer, sizeof(buffer)-1, format, arg_ptr );
+   int len = hal_vsnprintf( buffer, sizeof(buffer)-1, format, arg_ptr );
+
+    // flush existing characters
+    USART_Flush( DEBUG_TEXT_PORT );
+
+    // write string
+    USART_Write( DEBUG_TEXT_PORT, buffer, len );
+
+    // flush new characters
+    USART_Flush( DEBUG_TEXT_PORT );
+
+    va_end( arg_ptr );
+}
+*/
+
+void BootEntryLoader()
+{
+	debug_printf("In bootentry");
+
+/*
+	INT32 timeout = 0;
+    COM_HANDLE hComm = HalSystemConfig.DebuggerPorts[0];
+
+    BlockStorageStream stream;
+    FLASH_WORD ProgramWordCheck;
+    const UINT32 c_NoProgramFound = 0xFFFFFFFF;
+    UINT32 Program = c_NoProgramFound;
+
+#if defined(COMPILE_THUMB2)
+    // Don't initialize floating-point on small builds.
+#else
+    setlocale( LC_ALL, "" );
+#endif
+
+    CPU_Initialize();
+
+    HAL_Time_Initialize();
+
+    HAL_CONTINUATION::InitializeList();
+    HAL_COMPLETION  ::InitializeList();
+
+    Events_Initialize();
+
+    UINT8* BaseAddress;
+    UINT32 SizeInBytes;
+
+    HeapLocation( BaseAddress, SizeInBytes );
+
+    // Initialize custom heap with heap block returned from CustomHeapLocation
+    SimpleHeap_Initialize( BaseAddress, SizeInBytes );
+
+    // this is the place where interrupts are enabled after boot for the first time after boot
+    ENABLE_INTERRUPTS();
+
+    BlockStorageList::Initialize();
+
+    BlockStorage_AddDevices();
+
+    BlockStorageList::InitializeDevices();
+
+    if(!EnterMicroBooter(timeout))
+    {
+        HAL_UPDATE_CONFIG cfg;
+
+        timeout = 0;
+
+        if(HAL_CONFIG_BLOCK::ApplyConfig(HAL_UPDATE_CONFIG::GetDriverName(), &cfg, sizeof(cfg)))
+        {
+            MicroBooter_Install(cfg);
+
+            HAL_CONFIG_BLOCK::InvalidateBlockWithName(HAL_UPDATE_CONFIG::GetDriverName(), FALSE);
+
+            CPU_Reset();
+        }
+    }
+
+    if(stream.Initialize(BlockUsage::CODE))
+    {
+        do
+        {
+            while(TRUE)
+            {
+                FLASH_WORD *pWord = &ProgramWordCheck;
+                UINT32 Address = stream.CurrentAddress();
+
+                if(!stream.Read((BYTE**)&pWord, sizeof(FLASH_WORD))) break;
+
+                if(*pWord == MicroBooter_ProgramMarker())
+                {
+                    Program = (UINT32)Address;
+                    break;
+                }
+
+                if(!stream.Seek(BlockStorageStream::STREAM_SEEK_NEXT_BLOCK))
+                {
+                    if(!stream.NextStream())
+                    {
+                        break;
+                    }
+                }
+            }
+
+            if(Program != c_NoProgramFound) break;
+        }
+        while(stream.NextStream());
+    }
+
+    if(Program == c_NoProgramFound)
+    {
+        timeout = -1;
+    }
+
+#ifdef MICROBOOTER_NO_SREC_PROCESSING
+    while(true)
+    {
+        if(Program != c_NoProgramFound && stream.Device != NULL)
+        {
+            Program = MicroBooter_PrepareForExecution(Program);
+
+            DISABLE_INTERRUPTS();
+            ((void (*)())Program)();
+        }
+
+        Events_WaitForEvents(0, 1000);
+    }
+#else
+    while(true)
+    {
+        if(timeout != 0)
+        {
+            g_SREC.Initialize();
+
+            DebuggerPort_Initialize(hComm);
+
+            //--//
+
+            while(true)
+            {
+                char buf[1024];
+                INT32 cnt;
+
+                if(0 == Events_WaitForEvents(ExtractEventFromTransport(hComm) | SYSTEM_EVENT_FLAG_SYSTEM_TIMER, timeout))
+                {
+                    break;
+                }
+
+                // wait for chars to build up
+                Events_WaitForEvents(0, 8);
+
+                while(0 < (cnt = DebuggerPort_Read(hComm, buf, sizeof(buf))))
+                {
+                    for(INT32 i=0; i<cnt; i++)
+                    {
+                        g_SREC.Process(buf[i]);
+                    }
+                }
+
+            }
+        }
+
+        if(Program != c_NoProgramFound && stream.Device != NULL)
+        {
+            Program = MicroBooter_PrepareForExecution(Program);
+
+            DISABLE_INTERRUPTS();
+            ((void (*)())Program)();
+        }
+
+        timeout = -1;
+    }
+#endif
+*/
+}
+
+void FIQ_SubHandler() {}
+void UNDEF_SubHandler() {ASSERT(FALSE);}
+void ABORTP_SubHandler(){ASSERT(FALSE);}
+void ABORTD_SubHandler(){ASSERT(FALSE);}
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.h b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.h
new file mode 100644
index 000000000..d99b6b825
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.h
@@ -0,0 +1,7 @@
+#ifndef __ROT_H__
+#define __ROT_H__
+
+
+#include <Tinyhal.h>
+
+#endif /* __ROT_H__ */
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.proj b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.proj
new file mode 100644
index 000000000..9904aff33
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT.proj
@@ -0,0 +1,56 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
+  <PropertyGroup>
+    <AssemblyName>RoT</AssemblyName>
+    <ProjectGuid>{58b019a8-d75e-4b74-89c9-62babf77044f}</ProjectGuid>
+    <Description />
+    <Documentation />
+    <Directory>Solutions\SmartFusion2\RoT</Directory>
+    <IsClrProject>False</IsClrProject>
+    <InteropFeatures />
+    <ExtraAssemblies />
+    <ProjectPath>$(SPOCLIENT)\Solutions\SmartFusion2\RoT\RoT.proj</ProjectPath>
+    <MFSettingsFile>$(SPOCLIENT)\Solutions\SmartFusion2\SmartFusion2.settings</MFSettingsFile>
+    <IsSolutionWizardVisible>True</IsSolutionWizardVisible>
+  </PropertyGroup>
+  
+  <PropertyGroup>
+    <SamAppName>RoT</SamAppName>
+  </PropertyGroup>
+  
+  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Settings" />
+  <Import Project="$(SPOCLIENT)\tools\Targets\Microsoft.SPOT.Build.Targets" />
+  
+  <PropertyGroup>
+    <Size />
+    <Level />
+    <ProjectPath>$(SPOCLIENT)\ProjectTemplates\RoT\RoT.proj</ProjectPath>
+    <ManifestFile />
+    <Groups />
+    <CustomSpecific />
+    <IsStub>False</IsStub>
+    <reducesize>true</reducesize>
+    <OutputType>Executable</OutputType>
+    <ADD_LOAD_IMAGE_CRC>true</ADD_LOAD_IMAGE_CRC>
+    <CustomAssemblyName>RoT</CustomAssemblyName>
+    <ExtraTargets>BuildSigFiles</ExtraTargets>
+    <EXEScatterFileDefinition>$(SRC_DIR)\scatterfile_RoT_$(COMPILER_TOOL).$(SCATTER_EXT)</EXEScatterFileDefinition>
+  </PropertyGroup>
+  
+  
+  <ItemGroup>
+    <Compile Include="allocator.cpp" />
+    <Compile Include="RoT.cpp" />
+    <HFiles Include="$(SPOCLIENT)\DeviceCode\include\tinyhal.h" />
+    <!--<ObjFiles Include="$(OBJ_DIR)\rot_dat.$(OBJ_EXT)" /> -->
+    <ScatterFileReferences Include="$(SRC_DIR)\scatterfile_rot_$(COMPILER_TOOL).$(SCATTER_EXT)" />
+    <!-- <ScatterFileReferences Include="$(SRC_DIR)\scatterfile_ram_functions.$(SCATTER_EXT)" />
+    <ScatterFileReferences Include="$(SRC_DIR)\scatterfile_rot_ram_functions.$(SCATTER_EXT)" />-->
+  </ItemGroup>
+  
+  
+  <!-- Include other projects -->
+  <Import Project="$(SPOCLIENT)\Solutions\SmartFusion2\RoT\RoT_Projects.proj" />
+  
+  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Targets" />
+</Project>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT_Projects.proj b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT_Projects.proj
new file mode 100644
index 000000000..df49bdcd6
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/RoT_Projects.proj
@@ -0,0 +1,208 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
+
+  <!--Secure Boot and Higher level stuff-->
+  <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\Application\RoT\dotNetMF.proj" />
+    <DriverLibs Include="RoT.$(LIB_EXT)" />
+  </ItemGroup>
+  
+  
+  <!--   Some CLR stuff we might need       --> 
+  <!--
+  <ItemGroup>
+    <PlatformIndependentLibs Include="Messaging.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\CLR\Messaging\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <PlatformIndependentLibs Include="SPOT_Messaging_stub.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\CLR\Libraries\SPOT\SPOT_Messaging\dotNetMF_Stub.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <PlatformIndependentLibs Include="Diagnostics.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\CLR\Diagnostics\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="events_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Events\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="heap_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Heap\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SimpleHeap_config.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\SimpleHeap_config\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SimpleHeap.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\SimpleHeap\dotNetMF.proj" />
+  </ItemGroup>
+   
+  <ItemGroup>
+    <DriverLibs Include="Time_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\Time\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="tinycrt_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\devicecode\pal\TinyCRT\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="Watchdog_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Pal\Watchdog\dotNetMF.proj" />
+  </ItemGroup>
+  
+  -->
+  
+  <!--  - - - - - -  - uart, com , debug, only in debug mode  - - - -  -->
+  
+  <ItemGroup>
+    <DriverLibs Include="system_initialization_hal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Initialization\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="usart_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\USART\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="COM_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <PlatformIndependentLibs Include="WireProtocol.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\Support\WireProtocol\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SmartFusion2_usart.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\usart\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="tinycrt_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\devicecode\pal\TinyCRT\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="TinyHal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\cores\arm\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="asyncproccall_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\AsyncProcCall\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="events_pal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Events\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="usb_pal_stubs.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\USB\stubs\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="sockets_pal_stubs.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\COM\Sockets\stubs\dotNetMF.proj" />
+  </ItemGroup>
+  
+  
+  <!--  - - - - - - - - - -what does these do? 
+  <ItemGroup>
+    <DriverLibs Include="STM32F10x_bootstrap.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\STM32F10x\DeviceCode\drivers\bootstrap\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="STM32F10x_ID.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\STM32F10x\DeviceCode\drivers\id\dotNetMF.proj" />
+  </ItemGroup>
+  -->
+  
+  
+  <!-- - - - - - - - - -Crypto stuff needed by RoT   -->
+  <!-- ItemGroup>
+    <DriverLibs Include="Crypto.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\Crypto\dotNetMF.proj" />
+  </ItemGroup -->
+  
+  
+  <!-- - - - - - - - - -drivers, be very careful what you include -->
+  <ItemGroup>
+    <DriverLibs Include="GlobalLock_hal.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\cores\arm\Common\GlobalLock\gcc-thumb2\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SmartFusion2_SimplePower.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\SimplePower\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SmartFusion2_gpio.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\gpio\dotNetMF.proj" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="SmartFusion2_eNVM.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\eNVM\dotNetMF.proj" />
+  </ItemGroup>
+    
+  <!--  Time and Timer drivers  -->  
+  
+  <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Samraksh\eMote_Time\dotNetMF.proj" />
+    <DriverLibs Include="eMote_time.$(LIB_EXT)" />
+  </ItemGroup>
+    <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\PAL\Samraksh\VirtualTimer\dotNetMF.proj" />
+    <DriverLibs Include="VirtualTimer.$(LIB_EXT)" />
+  </ItemGroup>
+  <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\Timer\dotNetMF.proj" />
+    <DriverLibs Include="SmartFusion2_timer.$(LIB_EXT)" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\bl\dotNetMF.proj" />
+    <DriverLibs Include="SF2_M2S090_bl.$(LIB_EXT)" />
+  </ItemGroup>
+  <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\Timer\dotNetMF.proj" />
+    <DriverLibs Include="SmartFusion2_timer.$(LIB_EXT)" />
+  </ItemGroup>
+  
+  <ItemGroup>
+    <DriverLibs Include="M2SXXX.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\microsemi_lib\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SmartFusion2_sys_services.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\sys_services\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="SmartFusion2_intc.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\intc\dotNetMF.proj" />
+  </ItemGroup>
+  <ItemGroup>
+    <DriverLibs Include="sf2_spi.$(LIB_EXT)" />
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers\spi\dotNetMF.proj" />
+  </ItemGroup>
+  
+ 
+  
+  <!--     - - - - - - - -               Samraksh's Extensions   - - - - - - - -                  -->
+  
+  <!-- 									Samraksh Time Extension        								-->
+   <ItemGroup>
+    <RequiredProjects Include="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\DeviceCode\dotNetMF.proj" />
+    <DriverLibs Include="SmartFusion2_driver_control.$(LIB_EXT)" />
+  </ItemGroup>
+  
+  
+  <!--                      	    Wireless Networking Stack ::End                      -->
+  
+  <!--     - - - - - - - -        Samraksh's Extensions   End    - - - - - - - -           -->
+  
+  
+  
+ 
+</Project>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/TinyCLR.proj b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/TinyCLR.proj
new file mode 100644
index 000000000..ef130dac2
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/TinyCLR.proj
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Build">
+  <PropertyGroup>
+    <AssemblyName>tinyclr</AssemblyName>
+    <ProjectGuid>{d280cd35-8481-4eda-b878-6370c17e6273}</ProjectGuid>
+    <Description />
+    <Documentation />
+    <Directory>Solutions\SmartFusion2\TinyCLR</Directory>
+    <IsClrProject>True</IsClrProject>
+    <InteropFeatures />
+    <ExtraAssemblies />
+    <ProjectPath>$(SPOCLIENT)\Solutions\SmartFusion2\TinyCLR\TinyCLR.proj</ProjectPath>
+    <MFSettingsFile>$(SPOCLIENT)\Solutions\SmartFusion2\SmartFusion2.settings</MFSettingsFile>
+    <IsSolutionWizardVisible>True</IsSolutionWizardVisible>
+  </PropertyGroup>
+  <PropertyGroup>
+    <SamAppName>TINYCLR</SamAppName>
+  </PropertyGroup>
+
+  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Settings" />
+  <Import Project="$(SPOCLIENT)\tools\Targets\Microsoft.SPOT.Build.Targets" />
+  <PropertyGroup>
+    <ProjectPath>$(SPOCLIENT)\ProjectTemplates\TinyCLR\TinyCLR.proj</ProjectPath>
+    <OutputType>Executable</OutputType>
+    <MultipleOutputSections Condition="'$(MEMORY)'=='FLASH'">true</MultipleOutputSections>
+    <ADD_LOAD_IMAGE_CRC>true</ADD_LOAD_IMAGE_CRC>
+    <ExtraTargets>BuildSigFiles</ExtraTargets>
+    <ExtraEXETargets>MetaDataProcessorDat;TinyClrDat</ExtraEXETargets>
+    <ImageLocation Condition="'$(MEMORY)'=='FLASH'">\ER_FLASH</ImageLocation>
+    <LINK_FLAGS Condition="'$(COMPILER_TOOL)'!='GCC'">$(LINK_FLAGS) $(SWTC)keep *(.init_array)</LINK_FLAGS>
+    <MMP_DAT_SKIP>false</MMP_DAT_SKIP>
+    <MMP_DAT_CreateDatabaseFile>$(BIN_DIR)\tinyclr.dat</MMP_DAT_CreateDatabaseFile>
+    <EXEScatterFileDefinition>$(SRC_DIR)\scatterfile_tinyclr_$(COMPILER_TOOL).$(SCATTER_EXT)</EXEScatterFileDefinition>
+  </PropertyGroup>
+  
+  
+  <ItemGroup>
+    <Compile Include="allocator.cpp" />
+    <Compile Include="tinyclr.cpp" />
+    <HFiles Include="$(SPOCLIENT)\clr\include\tinyclr_application.h" />
+    <ObjFiles Include="$(OBJ_DIR)\tinyclr_dat.$(OBJ_EXT)" />
+    <ScatterFileReferences Include="$(SRC_DIR)\scatterfile_ram_functions.$(SCATTER_EXT)" />
+    <ScatterFileReferences Include="$(SRC_DIR)\scatterfile_tinyclr_$(COMPILER_TOOL).$(SCATTER_EXT)" />
+    <ScatterFileReferences Include="$(SRC_DIR)\scatterfile_tinyclr_ram_functions.$(SCATTER_EXT)" />
+  </ItemGroup>
+  
+  
+  <!-- Include other projects -->
+  <Import Project="$(SPOCLIENT)\Solutions\SmartFusion2\TinyCLR\TinyCLR_Projects.proj" />
+  
+  
+  <Import Project="$(SPOCLIENT)\tools\targets\Microsoft.SPOT.System.Targets" />
+</Project>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/allocator.cpp b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/allocator.cpp
new file mode 100644
index 000000000..fc623f727
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/allocator.cpp
@@ -0,0 +1,42 @@
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#include <stddef.h>
+#include <tinyhal.h>
+
+////////////////////////////////////////////////////////////////////////////////
+
+static void RuntimeFault( const char* szText )
+{
+    lcd_printf("\014ERROR:\r\n%s\r\n", szText );
+    debug_printf( "ERROR: %s\r\n", szText );
+
+    HARD_BREAKPOINT();
+}
+
+void *operator new(size_t) 
+{
+    RuntimeFault( "new(size_t)" );
+
+    return NULL;
+}
+
+void *operator new[](size_t)
+{
+    RuntimeFault( "new[](size_t)" );
+
+    return NULL;
+}
+
+void operator delete (void*)
+{
+    RuntimeFault( "delete(void*)" );
+}
+
+void operator delete[] (void*)
+{
+    RuntimeFault( "delete[](void*)" );
+}
+
+////////////////////////////////////////////////////////////////////////////////
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/scatterfile_rot_gcc.xml b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/scatterfile_rot_gcc.xml
new file mode 100644
index 000000000..a80555b2a
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/scatterfile_rot_gcc.xml
@@ -0,0 +1,196 @@
+<?xml version="1.0"?>
+<ScatterFile xmlns="http://schemas.microsoft.com/netmf/ScatterfileSchema.xsd">
+
+    <Set Name="Valid" Value="false"/>
+
+    <!-- ################################################################################ -->
+    <!-- SAM_$ are defined inside Solutions\EmoteDotNow\EmoteDotNow.settings -->
+    <Set Name="Heap_Begin"          Value="%SAM_HEAP_BEGIN%"/>
+    <Set Name="Heap_End"            Value="%SAM_HEAP_END%"/>
+    <Set Name="Stack_Bottom"        Value="%SAM_STACK_BOTTOM%"/>
+    <Set Name="Stack_Top"           Value="%SAM_STACK_TOP%"/>
+    <Set Name="Custom_Heap_Begin"   Value="%SAM_CUSTOM_HEAP_BEGIN%"/><!-- Graphics, WearLeveling, and LargeBuffer use SimpleHeap Library that uses CustomHeap location-->
+    <Set Name="Custom_Heap_End"     Value="%SAM_CUSTOM_HEAP_END%"/>
+    <IfDefined Name="PROFILE_BUILD">
+        <Set Name="ProfilerBufferBegin" Value="%SAM_PROFILER_BUFFER_BEGIN%"/>
+        <Set Name="ProfilerBufferEnd"   Value="%SAM_PROFILER_BUFFER_END%"/>
+    </IfDefined>
+    <!--Set Name="Data_BaseAddress" Value=... if using malloc and want separate section -->
+
+    <If Name="TARGETLOCATION" In="FLASH">
+        <!-- The M2S010 has  devices have 256 KB of flash starting at 0x60000000 -->
+		<!-- The M2S090 has  devices have 512 KB of flash starting at 0x60000000 -->
+        <!-- THIS MUST MATCH THE BLOCK STORAGE DRIVER! -->
+        <!-- Regular build: -->
+        <Set Name="Config_BaseAddress"  Value="0x6007F000"/><!-- Config_BaseAddress MUST MATCH TINYBOOTER SCATTERFILE -->
+        <Set Name="Config_Size"         Value="0x00001000"/><!--        Config_Size MUST MATCH TINYBOOTER SCATTERFILE -->
+        <Set Name="Code_BaseAddress"    Value="0x60000000"/>
+		<Set Name="Code_BaseAddress_Mirror"    Value="0x00000000"/>
+        <Set Name="Deploy_BaseAddress"  Value="0x60064800"/>
+        <Set Name="Code_Size"           Value="%Deploy_BaseAddress - Code_BaseAddress%"/>
+        <Set Name="Valid"               Value="true"/>
+		<Set Name="AltName"		Value="LR_FLASH"/>
+		<!-- In SmartFusion seems always start running from the address 0x00000000. At run time, the code space needs to get mapped to this space.
+		* The below symbol controls the relocation address. This is actually a parameter for a gdb relocation script.
+		*  0: remap eNVM to address 0x00000000                 Production mode or debugging from eNVM   
+		*  1: remap eSRAM to address 0x00000000                Debugging from eSRAM
+		*  2: remap external DDR memory to address 0x00000000  Debugging from DDR memory
+		*/-->
+		<!--<FileMapping Name="PROVIDE(__smartfusion2_memory_remap = 0);"/>--> <!--This for running from internal eNVM on cortex m3 -->
+    </If>
+
+    <!-- No Ram Build for the STM32F10x, since we can not fit it into 96K RAM -->
+    <If Name="TARGETLOCATION" In="RAM">
+        <Error Message="EmoteDotNow cannot target memory=RAM. Use memory=FLASH instead."/>
+        <Set Name="Heap_Begin"          Value="0x08300000"/>
+        <Set Name="Heap_End"            Value="0x084FEFFC"/>
+        <Set Name="Code_BaseAddress" Value="0x08020000"/>
+		<Set Name="Code_BaseAddress_Mirror"    Value="0x00000000"/>
+        <Set Name="Code_Size"        Value="0x002D0000"/>
+        <!-- RAM with FLASH config is not needed -->
+        <Set Name="Valid"            Value="true"/>
+		<Set Name="AltName"		Value="LR_RAM"/>
+    </If>
+
+    <!-- ################################################################################ -->
+
+    <If Name="Valid" Value="false">
+        <Error Message="Configuration not recognized"/>
+    </If>
+
+    <!-- we start at 0x10080000 since PortBooter lives at 0x10000000 -->
+
+    <NamedGroup Name="MEMORY">
+      <LoadRegion Name="LR_%TARGETLOCATION%" Base="%Code_BaseAddress%" Size="%Code_Size%"/>
+	  <LoadRegion Name="LR_%TARGETLOCATION%_Mirror" Base="%Code_BaseAddress_Mirror%" Size="%Code_Size%"/>
+      <LoadRegion Name="STACK" Base="%Stack_Bottom%" Size="%Stack_Top - Stack_Bottom% + 1"/>
+      <LoadRegion Name="HEAP" Base="%Heap_Begin%" Size="%Heap_End - Heap_Begin% + 1"/>
+      <LoadRegion Name="CUSTOMHEAP" Base="%Custom_Heap_Begin%" Size="%Custom_Heap_End - Custom_Heap_Begin% + 1"/>
+      <IfDefined Name="Config_BaseAddress">
+        <LoadRegion Name="LR_CONFIG" Base="%Config_BaseAddress%" Size="%Config_Size%"/>
+      </IfDefined>
+      <IfDefined Name="Data_BaseAddress">
+        <LoadRegion Name="LR_DAT" Base="%Data_BaseAddress%" Size="%Data_Size%"/>
+      </IfDefined>
+      <LoadRegion Name="RELOC_RAM" Base="%Stack_Top% + 8" Size="%Heap_Begin - Stack_Top%"/>
+    </NamedGroup>
+
+
+	<!--<FileMapping Name="PROVIDE (__main_stack_start = RAM_START_ADDRESS + RAM_SIZE);"/>
+	<FileMapping Name="PROVIDE (__process_stack_start = __main_stack_start - MAIN_STACK_SIZE);" />
+	<FileMapping Name="PROVIDE (_estack = __main_stack_start);"/>-->
+<FileMapping Name="PROVIDE (__mirrored_nvm = 0);"/>  <!-- Indicate to startup code that NVM is not mirrored to VMA address .text copy is required. -->
+
+	<!-- Remap instruction for startup code and debugger:
+	 *  0: remap eNVM to address 0x00000000
+	 *  1: remap eSRAM to address 0x00000000
+	 *  2: remap external DDR memory to address 0x00000000
+	 -->
+	<If Name="TARGETLOCATION" In="RAM">
+<FileMapping Name="PROVIDE (__smartfusion2_memory_remap = 2);" />
+	</If>
+	<If Name="TARGETLOCATION" In="FLASH">
+		<FileMapping Name="PROVIDE (__smartfusion2_memory_remap = 0);" />
+	</If>
+	
+    <EntryPoint Name="EntryPoint"/>
+	
+    <NamedGroup Name="SECTIONS">
+		
+		<ExecRegion Name="ER_%TARGETLOCATION%" Options="&gt;LR_%TARGETLOCATION%_Mirror AT>%AltName%">
+        <FileMapping Name="*" Options="(VectorsTrampolines)" />
+        <FileMapping Name="*" Options="(i.EntryPoint)" />
+        <FileMapping Name="*" Options="(SectionForBootstrapOperations)" />
+        <FileMapping Name="*" Options="(.text*)" />
+        <FileMapping Name="*" Options="(i.*)" />
+        <FileMapping Name="*" Options="(t.*)" />
+        <If Name="TARGETLOCATION" In="RAM">     
+          <FileMapping Name="*" Options="(SectionForFlashOperations)" />       
+        </If>
+        <FileMapping Name="*" Options="(.rodata*)" />
+        <FileMapping Name="*" Options="(rodata)" />
+        <FileMapping Name="*" Options="(.constdata*)" />
+        <FileMapping Name="*" Options="(.conststring*)" />
+        <IfNotDefined Name="Data_BaseAddress">
+          <FileMapping Name="*" Options="(tinyclr_metadata)" />
+        </IfNotDefined>
+        <IfNotDefined Name="Config_BaseAddress">
+          <FileMapping Name="*" Options="(SectionForConfig)" />
+        </IfNotDefined>
+
+        <!-- libc thinks that it needs these routines, but they are never called -->
+        <Include File="%SPOCLIENT%\Solutions\%PLATFORM%\scatterfile_gcc_missing_symbols.xml"/>
+
+      </ExecRegion>
+      <ExecRegion Name="ER_STACK_BOTTOM" Base="%Stack_Bottom%">
+        <FileMapping Name="*" Options="(SectionForStackBottom)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_STACK_TOP" Base="%Stack_Top%">
+        <FileMapping Name="*" Options="(SectionForStackTop)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_RAM_RO" Align="0x10" Options="&gt;RELOC_RAM AT&gt;LR_%TARGETLOCATION%">
+        <!--<FileMapping Name="*" Options="(VectorsTrampolines)" />--><!-- if vector table copied to RAM, must also set Vector Table Offset Register-->
+        <!--<Include File="%SPOCLIENT%\Solutions\%PLATFORM%\TinyCLR\scatterfile_ram_functions.xml"/>--><!--CLR RT functions to be placed in SRAM-->
+        <!--<Include File="%SPOCLIENT%\Solutions\%PLATFORM%\TinyCLR\scatterfile_tinyclr_ram_functions.xml"/>--><!--Samraksh HAL functions to be placed in SRAM-->
+        <If Name="TARGETLOCATION" In="FLASH">     
+          <FileMapping Name="*" Options="(SectionForFlashOperations)" />       
+        </If>
+      </ExecRegion>      
+      <ExecRegion Name="ER_RAM_RW" Align="0x10" Options="&gt;RELOC_RAM AT&gt;LR_%TARGETLOCATION%">
+        <FileMapping Name="*" Options="(rwdata)" />
+        <FileMapping Name="*" Options="(.data*)" />
+        <FileMapping Name="*" Options="(.zidata*)" />
+      </ExecRegion>      
+      <ExecRegion Name=".bss" Align="0x10" Options="&gt;RELOC_RAM AT&gt;LR_%TARGETLOCATION%">
+        <FileMapping Name="*" Options="(.bss*)" />
+        <FileMapping Name="PROVIDE(__exidx_start = .);" />
+        <FileMapping Name="PROVIDE(__exidx_end = .);" />
+      </ExecRegion>
+      <ExecRegion Name="/DISCARD/">
+        <FileMapping Name="*" Options="(.glue*)" />
+        <FileMapping Name="*" Options="(.vfp11*)" />
+        <FileMapping Name="*" Options="(.ARM.exidx*)" />
+        <FileMapping Name="*" Options="(.ARM.extab*)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_HEAP_BEGIN" Align="0x10" Options="&gt;RELOC_RAM"> <!-- Base="%Heap_Begin%"> --><!-- experimental: let the linker choose the heap start address -->
+        <FileMapping Name="*" Options="(SectionForHeapBegin)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_HEAP_END" Base="%Heap_End%">
+        <FileMapping Name="*" Options="(SectionForHeapEnd)" />
+      </ExecRegion>
+      <IfDefined Name="Custom_Heap_Begin">
+        <ExecRegion Name="ER_CUSTOMHEAP_BEGIN" Align="0x10" Base="%Custom_Heap_Begin%">
+            <FileMapping Name="*" Options="(SectionForCustomHeapBegin)" />
+        </ExecRegion>
+        <ExecRegion Name="ER_CUSTOMHEAP_END" Base="%Custom_Heap_End%">
+            <FileMapping Name="*" Options="(SectionForCustomHeapEnd)" />
+        </ExecRegion>
+      </IfDefined>
+
+    <IfDefined Name="Config_BaseAddress">         
+      <ExecRegion Name="ER_CONFIG" Options="&gt;LR_CONFIG">
+        <FileMapping Name="*" Options="(SectionForConfig)" />
+      </ExecRegion>
+    </IfDefined>    
+    <IfDefined Name="Data_BaseAddress">      
+      <ExecRegion Name="ER_DAT" Options="&gt;LR_DAT">
+        <FileMapping Name="*" Options="(tinyclr_metadata)" />
+      </ExecRegion>
+    </IfDefined>
+    </NamedGroup>
+
+    <!-- The following variables are used to simulate the ones autogenerated by RVDS -->
+    <!-- The address calculations must follow the desired layout order -->
+    <GlobalVariable Name="Load$$ER_%TARGETLOCATION%$$Base"          Value="ADDR(ER_%TARGETLOCATION%)"/>
+    <GlobalVariable Name="Image$$ER_%TARGETLOCATION%$$Length"       Value="SIZEOF(ER_%TARGETLOCATION%)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RO$$Base"                   Value="ADDR(ER_STACK_TOP) + 8"/>
+    <GlobalVariable Name="Image$$ER_RAM_RO$$Length"                 Value="ADDR(ER_RAM_RW) - ADDR(ER_RAM_RO)"/>
+    <GlobalVariable Name="Load$$ER_RAM_RO$$Base"                    Value="LOADADDR(ER_RAM_RO)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$Base"                   Value="ADDR(ER_RAM_RW)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$Length"                 Value="(ADDR(.bss) + SIZEOF(.bss)) - ADDR(ER_RAM_RW)"/>
+    <GlobalVariable Name="Load$$ER_RAM_RW$$Base"                    Value="LOADADDR(ER_RAM_RO) + (ADDR(ER_RAM_RW) - ADDR(ER_RAM_RO))"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$ZI$$Base"               Value="ADDR(.bss)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$ZI$$Length"             Value="SIZEOF(.bss)"/>
+    <GlobalVariable Name="__use_no_semihosting_swi"                 Value="0"/>
+
+</ScatterFile>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/scatterfile_rot_gcc.xml.old b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/scatterfile_rot_gcc.xml.old
new file mode 100644
index 000000000..a80555b2a
--- /dev/null
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/RoT/scatterfile_rot_gcc.xml.old
@@ -0,0 +1,196 @@
+<?xml version="1.0"?>
+<ScatterFile xmlns="http://schemas.microsoft.com/netmf/ScatterfileSchema.xsd">
+
+    <Set Name="Valid" Value="false"/>
+
+    <!-- ################################################################################ -->
+    <!-- SAM_$ are defined inside Solutions\EmoteDotNow\EmoteDotNow.settings -->
+    <Set Name="Heap_Begin"          Value="%SAM_HEAP_BEGIN%"/>
+    <Set Name="Heap_End"            Value="%SAM_HEAP_END%"/>
+    <Set Name="Stack_Bottom"        Value="%SAM_STACK_BOTTOM%"/>
+    <Set Name="Stack_Top"           Value="%SAM_STACK_TOP%"/>
+    <Set Name="Custom_Heap_Begin"   Value="%SAM_CUSTOM_HEAP_BEGIN%"/><!-- Graphics, WearLeveling, and LargeBuffer use SimpleHeap Library that uses CustomHeap location-->
+    <Set Name="Custom_Heap_End"     Value="%SAM_CUSTOM_HEAP_END%"/>
+    <IfDefined Name="PROFILE_BUILD">
+        <Set Name="ProfilerBufferBegin" Value="%SAM_PROFILER_BUFFER_BEGIN%"/>
+        <Set Name="ProfilerBufferEnd"   Value="%SAM_PROFILER_BUFFER_END%"/>
+    </IfDefined>
+    <!--Set Name="Data_BaseAddress" Value=... if using malloc and want separate section -->
+
+    <If Name="TARGETLOCATION" In="FLASH">
+        <!-- The M2S010 has  devices have 256 KB of flash starting at 0x60000000 -->
+		<!-- The M2S090 has  devices have 512 KB of flash starting at 0x60000000 -->
+        <!-- THIS MUST MATCH THE BLOCK STORAGE DRIVER! -->
+        <!-- Regular build: -->
+        <Set Name="Config_BaseAddress"  Value="0x6007F000"/><!-- Config_BaseAddress MUST MATCH TINYBOOTER SCATTERFILE -->
+        <Set Name="Config_Size"         Value="0x00001000"/><!--        Config_Size MUST MATCH TINYBOOTER SCATTERFILE -->
+        <Set Name="Code_BaseAddress"    Value="0x60000000"/>
+		<Set Name="Code_BaseAddress_Mirror"    Value="0x00000000"/>
+        <Set Name="Deploy_BaseAddress"  Value="0x60064800"/>
+        <Set Name="Code_Size"           Value="%Deploy_BaseAddress - Code_BaseAddress%"/>
+        <Set Name="Valid"               Value="true"/>
+		<Set Name="AltName"		Value="LR_FLASH"/>
+		<!-- In SmartFusion seems always start running from the address 0x00000000. At run time, the code space needs to get mapped to this space.
+		* The below symbol controls the relocation address. This is actually a parameter for a gdb relocation script.
+		*  0: remap eNVM to address 0x00000000                 Production mode or debugging from eNVM   
+		*  1: remap eSRAM to address 0x00000000                Debugging from eSRAM
+		*  2: remap external DDR memory to address 0x00000000  Debugging from DDR memory
+		*/-->
+		<!--<FileMapping Name="PROVIDE(__smartfusion2_memory_remap = 0);"/>--> <!--This for running from internal eNVM on cortex m3 -->
+    </If>
+
+    <!-- No Ram Build for the STM32F10x, since we can not fit it into 96K RAM -->
+    <If Name="TARGETLOCATION" In="RAM">
+        <Error Message="EmoteDotNow cannot target memory=RAM. Use memory=FLASH instead."/>
+        <Set Name="Heap_Begin"          Value="0x08300000"/>
+        <Set Name="Heap_End"            Value="0x084FEFFC"/>
+        <Set Name="Code_BaseAddress" Value="0x08020000"/>
+		<Set Name="Code_BaseAddress_Mirror"    Value="0x00000000"/>
+        <Set Name="Code_Size"        Value="0x002D0000"/>
+        <!-- RAM with FLASH config is not needed -->
+        <Set Name="Valid"            Value="true"/>
+		<Set Name="AltName"		Value="LR_RAM"/>
+    </If>
+
+    <!-- ################################################################################ -->
+
+    <If Name="Valid" Value="false">
+        <Error Message="Configuration not recognized"/>
+    </If>
+
+    <!-- we start at 0x10080000 since PortBooter lives at 0x10000000 -->
+
+    <NamedGroup Name="MEMORY">
+      <LoadRegion Name="LR_%TARGETLOCATION%" Base="%Code_BaseAddress%" Size="%Code_Size%"/>
+	  <LoadRegion Name="LR_%TARGETLOCATION%_Mirror" Base="%Code_BaseAddress_Mirror%" Size="%Code_Size%"/>
+      <LoadRegion Name="STACK" Base="%Stack_Bottom%" Size="%Stack_Top - Stack_Bottom% + 1"/>
+      <LoadRegion Name="HEAP" Base="%Heap_Begin%" Size="%Heap_End - Heap_Begin% + 1"/>
+      <LoadRegion Name="CUSTOMHEAP" Base="%Custom_Heap_Begin%" Size="%Custom_Heap_End - Custom_Heap_Begin% + 1"/>
+      <IfDefined Name="Config_BaseAddress">
+        <LoadRegion Name="LR_CONFIG" Base="%Config_BaseAddress%" Size="%Config_Size%"/>
+      </IfDefined>
+      <IfDefined Name="Data_BaseAddress">
+        <LoadRegion Name="LR_DAT" Base="%Data_BaseAddress%" Size="%Data_Size%"/>
+      </IfDefined>
+      <LoadRegion Name="RELOC_RAM" Base="%Stack_Top% + 8" Size="%Heap_Begin - Stack_Top%"/>
+    </NamedGroup>
+
+
+	<!--<FileMapping Name="PROVIDE (__main_stack_start = RAM_START_ADDRESS + RAM_SIZE);"/>
+	<FileMapping Name="PROVIDE (__process_stack_start = __main_stack_start - MAIN_STACK_SIZE);" />
+	<FileMapping Name="PROVIDE (_estack = __main_stack_start);"/>-->
+<FileMapping Name="PROVIDE (__mirrored_nvm = 0);"/>  <!-- Indicate to startup code that NVM is not mirrored to VMA address .text copy is required. -->
+
+	<!-- Remap instruction for startup code and debugger:
+	 *  0: remap eNVM to address 0x00000000
+	 *  1: remap eSRAM to address 0x00000000
+	 *  2: remap external DDR memory to address 0x00000000
+	 -->
+	<If Name="TARGETLOCATION" In="RAM">
+<FileMapping Name="PROVIDE (__smartfusion2_memory_remap = 2);" />
+	</If>
+	<If Name="TARGETLOCATION" In="FLASH">
+		<FileMapping Name="PROVIDE (__smartfusion2_memory_remap = 0);" />
+	</If>
+	
+    <EntryPoint Name="EntryPoint"/>
+	
+    <NamedGroup Name="SECTIONS">
+		
+		<ExecRegion Name="ER_%TARGETLOCATION%" Options="&gt;LR_%TARGETLOCATION%_Mirror AT>%AltName%">
+        <FileMapping Name="*" Options="(VectorsTrampolines)" />
+        <FileMapping Name="*" Options="(i.EntryPoint)" />
+        <FileMapping Name="*" Options="(SectionForBootstrapOperations)" />
+        <FileMapping Name="*" Options="(.text*)" />
+        <FileMapping Name="*" Options="(i.*)" />
+        <FileMapping Name="*" Options="(t.*)" />
+        <If Name="TARGETLOCATION" In="RAM">     
+          <FileMapping Name="*" Options="(SectionForFlashOperations)" />       
+        </If>
+        <FileMapping Name="*" Options="(.rodata*)" />
+        <FileMapping Name="*" Options="(rodata)" />
+        <FileMapping Name="*" Options="(.constdata*)" />
+        <FileMapping Name="*" Options="(.conststring*)" />
+        <IfNotDefined Name="Data_BaseAddress">
+          <FileMapping Name="*" Options="(tinyclr_metadata)" />
+        </IfNotDefined>
+        <IfNotDefined Name="Config_BaseAddress">
+          <FileMapping Name="*" Options="(SectionForConfig)" />
+        </IfNotDefined>
+
+        <!-- libc thinks that it needs these routines, but they are never called -->
+        <Include File="%SPOCLIENT%\Solutions\%PLATFORM%\scatterfile_gcc_missing_symbols.xml"/>
+
+      </ExecRegion>
+      <ExecRegion Name="ER_STACK_BOTTOM" Base="%Stack_Bottom%">
+        <FileMapping Name="*" Options="(SectionForStackBottom)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_STACK_TOP" Base="%Stack_Top%">
+        <FileMapping Name="*" Options="(SectionForStackTop)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_RAM_RO" Align="0x10" Options="&gt;RELOC_RAM AT&gt;LR_%TARGETLOCATION%">
+        <!--<FileMapping Name="*" Options="(VectorsTrampolines)" />--><!-- if vector table copied to RAM, must also set Vector Table Offset Register-->
+        <!--<Include File="%SPOCLIENT%\Solutions\%PLATFORM%\TinyCLR\scatterfile_ram_functions.xml"/>--><!--CLR RT functions to be placed in SRAM-->
+        <!--<Include File="%SPOCLIENT%\Solutions\%PLATFORM%\TinyCLR\scatterfile_tinyclr_ram_functions.xml"/>--><!--Samraksh HAL functions to be placed in SRAM-->
+        <If Name="TARGETLOCATION" In="FLASH">     
+          <FileMapping Name="*" Options="(SectionForFlashOperations)" />       
+        </If>
+      </ExecRegion>      
+      <ExecRegion Name="ER_RAM_RW" Align="0x10" Options="&gt;RELOC_RAM AT&gt;LR_%TARGETLOCATION%">
+        <FileMapping Name="*" Options="(rwdata)" />
+        <FileMapping Name="*" Options="(.data*)" />
+        <FileMapping Name="*" Options="(.zidata*)" />
+      </ExecRegion>      
+      <ExecRegion Name=".bss" Align="0x10" Options="&gt;RELOC_RAM AT&gt;LR_%TARGETLOCATION%">
+        <FileMapping Name="*" Options="(.bss*)" />
+        <FileMapping Name="PROVIDE(__exidx_start = .);" />
+        <FileMapping Name="PROVIDE(__exidx_end = .);" />
+      </ExecRegion>
+      <ExecRegion Name="/DISCARD/">
+        <FileMapping Name="*" Options="(.glue*)" />
+        <FileMapping Name="*" Options="(.vfp11*)" />
+        <FileMapping Name="*" Options="(.ARM.exidx*)" />
+        <FileMapping Name="*" Options="(.ARM.extab*)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_HEAP_BEGIN" Align="0x10" Options="&gt;RELOC_RAM"> <!-- Base="%Heap_Begin%"> --><!-- experimental: let the linker choose the heap start address -->
+        <FileMapping Name="*" Options="(SectionForHeapBegin)" />
+      </ExecRegion>
+      <ExecRegion Name="ER_HEAP_END" Base="%Heap_End%">
+        <FileMapping Name="*" Options="(SectionForHeapEnd)" />
+      </ExecRegion>
+      <IfDefined Name="Custom_Heap_Begin">
+        <ExecRegion Name="ER_CUSTOMHEAP_BEGIN" Align="0x10" Base="%Custom_Heap_Begin%">
+            <FileMapping Name="*" Options="(SectionForCustomHeapBegin)" />
+        </ExecRegion>
+        <ExecRegion Name="ER_CUSTOMHEAP_END" Base="%Custom_Heap_End%">
+            <FileMapping Name="*" Options="(SectionForCustomHeapEnd)" />
+        </ExecRegion>
+      </IfDefined>
+
+    <IfDefined Name="Config_BaseAddress">         
+      <ExecRegion Name="ER_CONFIG" Options="&gt;LR_CONFIG">
+        <FileMapping Name="*" Options="(SectionForConfig)" />
+      </ExecRegion>
+    </IfDefined>    
+    <IfDefined Name="Data_BaseAddress">      
+      <ExecRegion Name="ER_DAT" Options="&gt;LR_DAT">
+        <FileMapping Name="*" Options="(tinyclr_metadata)" />
+      </ExecRegion>
+    </IfDefined>
+    </NamedGroup>
+
+    <!-- The following variables are used to simulate the ones autogenerated by RVDS -->
+    <!-- The address calculations must follow the desired layout order -->
+    <GlobalVariable Name="Load$$ER_%TARGETLOCATION%$$Base"          Value="ADDR(ER_%TARGETLOCATION%)"/>
+    <GlobalVariable Name="Image$$ER_%TARGETLOCATION%$$Length"       Value="SIZEOF(ER_%TARGETLOCATION%)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RO$$Base"                   Value="ADDR(ER_STACK_TOP) + 8"/>
+    <GlobalVariable Name="Image$$ER_RAM_RO$$Length"                 Value="ADDR(ER_RAM_RW) - ADDR(ER_RAM_RO)"/>
+    <GlobalVariable Name="Load$$ER_RAM_RO$$Base"                    Value="LOADADDR(ER_RAM_RO)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$Base"                   Value="ADDR(ER_RAM_RW)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$Length"                 Value="(ADDR(.bss) + SIZEOF(.bss)) - ADDR(ER_RAM_RW)"/>
+    <GlobalVariable Name="Load$$ER_RAM_RW$$Base"                    Value="LOADADDR(ER_RAM_RO) + (ADDR(ER_RAM_RW) - ADDR(ER_RAM_RO))"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$ZI$$Base"               Value="ADDR(.bss)"/>
+    <GlobalVariable Name="Image$$ER_RAM_RW$$ZI$$Length"             Value="SIZEOF(.bss)"/>
+    <GlobalVariable Name="__use_no_semihosting_swi"                 Value="0"/>
+
+</ScatterFile>
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/SmartFusion2.settings b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/SmartFusion2.settings
index b4ffd403c..adcce901d 100644
--- a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/SmartFusion2.settings
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/SmartFusion2.settings
@@ -19,11 +19,12 @@
     <IncludePaths Include="Solutions\SmartFusion2" />
     <IncludePaths Include="DeviceCode\Targets\Native\SmartFusion2\DeviceCode\microsemi_lib" />
     <IncludePaths Include="DeviceCode\Targets\Native\SmartFusion2\DeviceCode\drivers" />
-    <IncludePaths Include="DeviceCode\Targets\Native\STM32F10x\DeviceCode\drivers" />
+    <!-- <IncludePaths Include="DeviceCode\Targets\Native\STM32F10x\DeviceCode\drivers" />
     <IncludePaths Include="DeviceCode\Targets\Native\STM32F10x\DeviceCode\processor" />
+    -->
     
   </ItemGroup>
-  <Import Project="$(SPOCLIENT)\DeviceCode\Targets\Native\STM32F10x\STM32F10x.settings" />
+  <Import Project="$(SPOCLIENT)\DeviceCode\Targets\Native\SmartFusion2\SmartFusion2.settings" />
   <!-- Samraksh Heap and Stack settings to be propagated across ASM, C/C++, and Linker Script targets -->
   <PropertyGroup>
     <!-- BEFORE YOU CHANGE THIS: check size of ER_RAM_RO + ER_RAM_RW + .bss in map file and accommodate accordingly. -->
diff --git a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/platform_selector.h b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/platform_selector.h
index d80e9ce5e..4fc5dac4a 100644
--- a/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/platform_selector.h
+++ b/MicroFrameworkPK_v4_3/Solutions/SmartFusion2/platform_selector.h
@@ -5,6 +5,8 @@
 #ifndef _PLATFORM_SmartFusion2_SELECTOR_H_
 #define _PLATFORM_SmartFusion2_SELECTOR_H_ 1
 
+#define NO_HAL_BUILD 1
+
 // Properly declare them since they are not ANSI
 // Previously declared by accident in compiler setup because we used _GNU_SOURCE (default)
 // In future, prefer not to use.
@@ -96,6 +98,19 @@ typedef uint16_t ushort;
 #define ASSERT_IRQ_MUST_BE_ON()
 #endif
 
+#if defined(NO_HAL_BUILD)
+#define INTERRUPT_START GLOBAL_LOCK(x)
+#define INTERRUPT_END
+
+#else
+#define INTERRUPT_START SystemState_SetNoLock( SYSTEM_STATE_ISR              );   \
+                        SystemState_SetNoLock( SYSTEM_STATE_NO_CONTINUATIONS );
+#define INTERRUPT_END   SystemState_ClearNoLock( SYSTEM_STATE_NO_CONTINUATIONS ); \
+                        SystemState_ClearNoLock( SYSTEM_STATE_ISR              );
+#endif
+
+
+
 //
 // macros
 //
diff --git a/MicroFrameworkPK_v4_3/setenv_base.cmd b/MicroFrameworkPK_v4_3/setenv_base.cmd
index 3d09819f8..7671bfde1 100644
--- a/MicroFrameworkPK_v4_3/setenv_base.cmd
+++ b/MicroFrameworkPK_v4_3/setenv_base.cmd
@@ -4,6 +4,8 @@ set PORT_BUILD=
 set NO_ADS_WRAPPER=
 SET COMPILER_TOOL=
 
+ECHO "VSPath %COMPILER_TOOL% %VS140COMNTOOLS%"
+
 if NOT "%1"=="" GOTO :ARGSOK
 if NOT "%2"=="" GOTO :ARGSOK
 
@@ -78,26 +80,34 @@ set CURRENTCD=
 rem @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 rem set tool-chains variables 
 
+ECHO "VSPath %COMPILER_TOOL% %VS140COMNTOOLS%"
+
 IF /I NOT "%COMPILER_TOOL%" == "VS" (
-    IF NOT "%VS120COMNTOOLS%" == "" ( 
-        CALL "%VS120COMNTOOLS%vsvars32.bat"
+	ECHO "Checking visual studio version..."
+	IF NOT "%VS140COMNTOOLS%" == "" (
+		ECHO "Found Visual Studio 14.0"
+        CALL "%VS140COMNTOOLS%vsvars32.bat"
     ) ELSE (
-        IF NOT "%VS110COMNTOOLS%" == "" (
-            CALL "%VS110COMNTOOLS%vsvars32.bat"
-        ) ELSE (
-            IF NOT "%VS100COMNTOOLS%" == "" (
-            CALL "%VS100COMNTOOLS%vsvars32.bat"
-            ) ELSE (
-                IF NOT "%VS90COMNTOOLS%" == "" (
-                    CALL "%VS90COMNTOOLS%vsvars32.bat"    
-                ) ELSE ( 
-                    @ECHO WARNING: Could not find vsvars32.bat.
-                    @ECHO WARNING: VISUAL C++ DOES NOT APPEAR TO BE INSTALLED ON THIS MACHINE
-                    GOTO :EOF
-                )
-            )
-        )
-    )	
+		IF NOT "%VS120COMNTOOLS%" == "" ( 
+			CALL "%VS120COMNTOOLS%vsvars32.bat"
+		) ELSE (
+			IF NOT "%VS110COMNTOOLS%" == "" (
+				CALL "%VS110COMNTOOLS%vsvars32.bat"
+			) ELSE (
+				IF NOT "%VS100COMNTOOLS%" == "" (
+				CALL "%VS100COMNTOOLS%vsvars32.bat"
+				) ELSE (
+					IF NOT "%VS90COMNTOOLS%" == "" (
+						CALL "%VS90COMNTOOLS%vsvars32.bat"    
+					) ELSE ( 
+						@ECHO WARNING: Could not find vsvars32.bat.
+						@ECHO WARNING: VISUAL C++ DOES NOT APPEAR TO BE INSTALLED ON THIS MACHINE
+						GOTO :EOF
+					)
+				)
+			)
+		)
+	)		
 )
 
 set TINYCLR_USE_MSBUILD=1   
diff --git a/MicroFrameworkPK_v4_3/tools/Targets/Microsoft.Spot.system.gcc.targets b/MicroFrameworkPK_v4_3/tools/Targets/Microsoft.Spot.system.gcc.targets
index 5ba2d1bdb..e7a065a28 100644
--- a/MicroFrameworkPK_v4_3/tools/Targets/Microsoft.Spot.system.gcc.targets
+++ b/MicroFrameworkPK_v4_3/tools/Targets/Microsoft.Spot.system.gcc.targets
@@ -112,6 +112,7 @@
     <AS_FLAGS Condition="'$(INSTRUCTION_SET)'=='thumb' and '$(COMPILER_TOOL)'!='GCCOP'">$(AS_FLAGS) --defsym COMPILE_THUMB=1 -mthumb-interwork</AS_FLAGS>
     <AS_FLAGS Condition="'$(INSTRUCTION_SET)'=='thumb2'"  >$(AS_FLAGS) --defsym COMPILE_THUMB2=1 -mthumb</AS_FLAGS>
     <AS_FLAGS Condition="'$(INSTRUCTION_SET)'=='thumb2fp'">$(AS_FLAGS) --defsym COMPILE_THUMB2=1</AS_FLAGS>
+	<AS_FLAGS Condition="'$(DEVICE_TYPE)'=='Cortex-M3'"> $(AS_FLAGS) -mcpu=cortex-m3</AS_FLAGS>
 
     <!-- Assembler flags -->
     <!-- TODO: There are no string macros in the GDD assembler, so this must be done another way
@@ -289,7 +290,7 @@
 
 	  <!--<GNU_LIB_DIR     Condition="'$(DEVICE_TYPE)'=='Cortex-M3' and '$(GCC_VER)'!='5.4.1'">$(GNU_TOOLS)\$(GNU_TARGET)\lib\armv7-m</GNU_LIB_DIR>-->
     <GNU_LIB_DIR     Condition="'$(DEVICE_TYPE)'=='Cortex-M3' and '$(GCC_VER)'=='6.3.1'">$(GNU_TOOLS)\$(GNU_TARGET)\lib\thumb\v7-m</GNU_LIB_DIR>
-	  <GNU_LIB_DIR     Condition="'$(DEVICE_TYPE)'=='Cortex-M3' and '$(GCC_VER)'=='5.4.1'">$(SPOCLIENT)\DeviceCode\Targets\Native\STM32F10x\DeviceCode\newlib\armv7-m</GNU_LIB_DIR>
+	<GNU_LIB_DIR     Condition="'$(DEVICE_TYPE)'=='Cortex-M3' and '$(GCC_VER)'=='5.4.1'">$(SPOCLIENT)\DeviceCode\Targets\Native\STM32F10x\DeviceCode\newlib\armv7-m</GNU_LIB_DIR>
     <GNU_LIBGCC_DIR  Condition="'$(DEVICE_TYPE)'=='Cortex-M3' and '$(GCC_VER)'=='6.3.1'">$(GNU_TOOLS)\lib\gcc\$(GNU_TARGET)\$(GCC_VER)\thumb</GNU_LIBGCC_DIR>
     <GNU_LIBGCC_DIR  Condition="'$(DEVICE_TYPE)'=='Cortex-M3' and '$(GCC_VER)'=='5.4.1'">$(GNU_TOOLS)\lib\gcc\$(GNU_TARGET)\$(GCC_VER)\armv7-m</GNU_LIBGCC_DIR>
 
