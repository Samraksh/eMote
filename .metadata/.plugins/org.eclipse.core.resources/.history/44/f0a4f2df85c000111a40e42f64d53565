/*
 * 	Name : PriorityQueue.cpp
 *
 *  Author : nived.sivadas@samraksh.com
 *
 *  Description : Used by the timer to maintain a min heap of virtual timers
 *
 *
 *
 */
#include <PriorityQueue.h>

VOID PriorityQueue::ReorderUp(INT32 elementID)
{
	// Check if am already at the root
	if(parent(elementID) == -1)
	{
			return;
	}

	if(queue[parent(elementID)] > queue[elementID])
	{
		INT32 temp = queue[parent(elementID )];
		queue[parent(elementID )] = queue[elementID];
		queue[elementID] = temp;
		ReorderUp(parent(elementID));
	}

}

VOID PriorityQueue::ReorderDown(INT32 elementID)
{
	INT32 childId = child(elementID);
	INT32 minIndex = elementID;

	for(INT32 i = 0; i <= 1; i++)
	{
		if((childId + 1) <= numberOfElements - 1)
		{
			if(queue[minIndex] > queue[childId + i]) minIndex = childId + i;
		}
	}

	if(minIndex != elementID)
	{
		INT32 temp = queue[elementID];
		queue[elementID] = queue[minIndex];
		queue[minIndex] = temp;
		ReorderDown(minIndex);
	}
}

INT32 PriorityQueue::parent(INT32 elementId)
{
	// At root, no parent possible
	if(elementID == 1) return -1;
	// taking the floor
	else return((INT32) elementId/2);
}

INT32 PriorityQueue::child(INT32 elementId)
{
	return (2 * elementId);
}
