// Name : Radio_decl.h
//
// Author : nived.sivadas@samraksh.com
//
// Description : Contains the interfaces used by the pal layer
//
#ifndef _RADIO_DECL_H_
#define _RADIO_DECL_H_

#include <tinyhal.h>

typedef enum RADIO_STATUS
{
	BUSY = (0x0),
	FAIL =  (0x1),
	SUCCESS = (0x2),

}RADIO_STATUS_TYPE;

// This structure defines the interface for clear channel assessment
struct CCA
{
	////////////////////////////////////////////////
	// Description : Starts clear channel assesment procedure. Returns BUSY if the radio is
	// currently busy servicing another request and SUCCESS otherwise
	////////////////////////////////////////////////
	RADIO_STATUS_TYPE request();

};

// This structure defines an interface for radio events
struct IRadioEvents
{
	///////////////////////////////////////////////
	// Description : Called on an sfd event from the radio driver layer
	///////////////////////////////////////////////
	BOOL (*SFDEvent)(void *data);

	///////////////////////////////////////////////
	// Description : Called on an efd event from the radio driver layer
	///////////////////////////////////////////////
	BOOL (*EFDEvent)(void *data);

	//////////////////////////////////////////////
	// Description : Called on completion of a CCA send command,
	//				 SUCCESS means the channel is clear
	//				 EBUSY means that the channel is not clear
	//				 FAIL means that CCA could not be finished or the operation was cancelled
	//////////////////////////////////////////////
	RADIO_STATUS_TYPE (*CCADoneEvent)();

	/////////////////////////////////////////////
	// Description : Called on completion of send
	//
	// Return Values :
	//				 SUCCESS means that send was successful
	//				 FAIL means that the send was not
	/////////////////////////////////////////////
	RADIO_STATUS_TYPE (*sendDoneEvent)();

};

// This function is reponsible for adding event handlers that will be called by the driver layer
void Radio_AddEventHandlers(IRadioEvents *handlers);

BOOL Radio_LoadPacket(void *data);

BOOL Radio_SendPacket();


// Enables timestamping of radio packets, identical to the timestamping interface suggested by TEP132 in tinyos and closely follows
// their rf230 implementation
template<class T>
class TimeStampLayer
{


public:
	static BOOL isValid(T *msg)
	{
		return TRUE;
	}

	static UINT32 timestamp(T *msg)
	{
		return 0;
	}

	static void clear(T *msg)
	{

	}

	static void set(T *msg, UINT32 value)
	{

	}

	static void set(T *msg)
	{

	}

};


#endif
